/**
 * Ders Değerlendirme Sistemi
 * -------------------------
 * Bu script ders değerlendirme kriterlerini ve öğrenci notlarını
 * yönetmek için kullanılan web uygulamasını kontrol eder.
 * 
 * @version 2.0.0
 * @author Ders Değerlendirme Sistemi Geliştirme Ekibi
 */

'use strict';

// =====================================================
// SABITLER VE GLOBAL DEĞIŞKENLER
// =====================================================

/**
 * Değerlendirme etkinlik türleri
 */
const ACTIVITY_TYPES = {
    term: [
        "Ara Sınav",
        "Laboratuvar Sınavı",
        "Deney",
        "Deney Sonrası Quiz",
        "Performans",
        "Quiz",
        "Rapor",
        "Rapor Sunma",
        "Makale Kritik Etme",
        "Makale Yazma",
        "Proje Hazırlama",
        "Proje Sunma",
        "Rehberli Problem Çözümü",
        "Seminer",
        "Sözlü Sınav",
        "Ödev Problemleri İçin Çalışma",
        "Proje Tasarımı/Yönetimi",
        "Derse Katılım",
        "Ev Ödevi"
    ],
    final: [
        "Final Sınavı",
        "Laboratuvar Ara Sınavı",
        "Makale Yazma",
        "Proje Hazırlama",
        "Proje Sunma",
        "Proje Tasarımı/Yönetimi",
        "Quiz",
        "Rapor",
        "Rapor Hazırlama",
        "Rapor Sunma",
        "Seminer",
        "Sözlü Sınav",
        "Gözlem"
    ],
    subItem: [
        "Soru",
        "Rubrik",
        "Test"
    ]
};

/**
 * Uygulama durum değişkenleri
 */
const APP_STATE = {
    courseData: null,        // Ders bilgileri
    learningOutcomes: [],    // Öğrenme çıktıları
    programOutcomes: [],     // Program çıktıları
    outcomeMatrix: null,     // ÖÇ-PÇ İlişki Matrisi
    assessmentTree: [],      // Değerlendirme ağacı
    selectedNode: null,      // Seçili düğüm
	testDetailsNode: null,   // Test detayları için geçici düğüm
    multipleItemsNode: null, // Çoklu öğe eklemek için geçici düğüm
    multipleItemsType: '',   // Eklenecek öğelerin tipi (soru veya rubrik)
    termWeight: 40,          // Yarıyıl içi ağırlığı
    finalWeight: 60,         // Yarıyıl sonu ağırlığı
    jsonFileName: '',        // Yüklenen JSON dosyasının adı
    studentData: [],         // Öğrenci verileri
    gradesData: {},          // Not verileri
    testDetailsNode: null,   // Test detayları için geçici düğüm
    currentActiveTabId: 'definition', // Aktif sekme ID'si
    currentMappingNode: null, // Haritalama düzenlenen düğüm
    selectedStudentId: null  // Seçili öğrenci ID'si (student grades view için)
};

// =====================================================
// DOM ELEMENTLERINI SEÇME
// =====================================================

// Ana konteynerlar
const treeContainer = document.getElementById('treeContainer');
const outcomesList = document.getElementById('outcomesList');
const programOutcomesList = document.getElementById('programOutcomesList');
const matrixContainer = document.getElementById('matrixContainer');
const courseDetailsContainer = document.getElementById('courseDetailsContainer');
const courseTitle = document.getElementById('courseTitle');
const courseDetails = document.getElementById('courseDetails');
const courseTerm = document.getElementById('courseTerm');
const termWeightSpan = document.getElementById('termWeight');
const finalWeightSpan = document.getElementById('finalWeight');
const termProgress = document.getElementById('termProgress');
const finalProgress = document.getElementById('finalProgress');

// Modaller
const importModal = document.getElementById('importModal');
const exportModal = document.getElementById('exportModal');
const importStudentsModal = document.getElementById('importStudentsModal');
const exportGradesModal = document.getElementById('exportGradesModal');
const testDetailsModal = document.getElementById('testDetailsModal');
const closeImportModal = document.getElementById('closeImportModal');
const closeExportModal = document.getElementById('closeExportModal');
const closeImportStudentsModal = document.getElementById('closeImportStudentsModal');
const closeExportGradesModal = document.getElementById('closeExportGradesModal');
const closeTestDetailsModal = document.getElementById('closeTestDetailsModal');

const multipleItemsModal = document.getElementById('multipleItemsModal');
const closeMultipleItemsModal = document.getElementById('closeMultipleItemsModal');
const multipleItemsTitle = document.getElementById('multipleItemsTitle');
const itemCount = document.getElementById('itemCount');
const itemType = document.getElementById('itemType');
const questionType = document.getElementById('questionType');
const rubricType = document.getElementById('rubricType');
const questionTypeContainer = document.getElementById('questionTypeContainer');
const rubricTypeContainer = document.getElementById('rubricTypeContainer');
const btnAddMultipleItems = document.getElementById('btnAddMultipleItems');

const toast = document.getElementById('toast');
const toastMessage = document.getElementById('toastMessage');

// Form ve input elementleri
const jsonContent = document.getElementById('jsonContent');
const exportJsonContent = document.getElementById('exportJsonContent');
const studentJsonContent = document.getElementById('studentJsonContent');
const exportGradesContent = document.getElementById('exportGradesContent');
const fileInput = document.getElementById('fileInput');
const selectedFileName = document.getElementById('selectedFileName');
const selectedStudentFileName = document.getElementById('selectedStudentFileName');
const studentFileInput = document.getElementById('studentFileInput');
const studentJsonInput = document.getElementById('studentJsonInput');
const studentTable = document.getElementById('studentTable');
const assessmentContainer = document.getElementById('assessmentContainer');
const gradesTable = document.getElementById('gradesTable');
const statsContent = document.getElementById('statsContent');
const chartContainer = document.getElementById('chartContainer');
const totalQuestionsInput = document.getElementById('totalQuestions');
const correctWeightInput = document.getElementById('correctWeight');
const wrongPenaltyInput = document.getElementById('wrongPenalty');

// Butonları seçme
const btnImport = document.getElementById('btnImport');
const btnExport = document.getElementById('btnExport');
const btnAddTerm = document.getElementById('btnAddTerm');
const btnAddFinal = document.getElementById('btnAddFinal');
const btnAddQuestion = document.getElementById('btnAddQuestion');
const btnAddRubric = document.getElementById('btnAddRubric');
const btnRemove = document.getElementById('btnRemove');
const btnExpandAll = document.getElementById('btnExpandAll');
const btnCollapseAll = document.getElementById('btnCollapseAll');
const btnSelectFile = document.getElementById('btnSelectFile');
const btnApplyJson = document.getElementById('btnApplyJson');
const btnCopyJson = document.getElementById('btnCopyJson');
const btnSaveJson = document.getElementById('btnSaveJson');
const btnImportStudents = document.getElementById('btnImportStudents');
const btnClearStudents = document.getElementById('btnClearStudents');
const btnSelectStudentFile = document.getElementById('btnSelectStudentFile');
const btnApplyStudentJson = document.getElementById('btnApplyStudentJson');
const btnImportGrades = document.getElementById('btnImportGrades');
const btnSaveGrades = document.getElementById('btnSaveGrades');
const btnSaveGradesToFile = document.getElementById('btnSaveGradesToFile');
const btnExportGradesJSON = document.getElementById('btnExportGradesJSON');
const btnExportGradesExcel = document.getElementById('btnExportGradesExcel');
const btnCalculateGrades = document.getElementById('btnCalculateGrades');
const btnExportFinalGrades = document.getElementById('btnExportFinalGrades');
const btnCopyGrades = document.getElementById('btnCopyGrades');
const btnSaveTestDetails = document.getElementById('btnSaveTestDetails');

// Grup yönetimi elementleri (aktif gruplar gösterimi kaldırıldı)
const groupMappingModal = document.getElementById('groupMappingModal');
const mappingContainer = document.getElementById('mappingContainer');
const addMappingRowBtn = document.getElementById('addMappingRow');
const saveMappingBtn = document.getElementById('saveMappingBtn');
const mappingActivityName = document.getElementById('mappingActivityName');

// =====================================================
// GUID SİSTEMİ KALDIRILDI - Basitleştirme
// =====================================================

// GUID sistemi geliştirmeleri kaldırıldı
// Temel ID tabanlı sistem korundu

// =====================================================
// ETKİNLİK SEÇENEK MODAL SİSTEMİ
// =====================================================

/**
 * Etkinlik eklendikten sonra seçenek modalını göster
 * @param {string} activityType - 'term' veya 'final'
 * @param {Object} activityNode - Eklenen etkinlik düğümü
 */
function showActivityOptionsModal(activityType, activityNode) {
    const modal = document.getElementById('activityOptionsModal');
    const title = document.getElementById('activityOptionsTitle');
    const successText = document.getElementById('activitySuccessText');
    
    if (!modal || !title || !successText) {
        console.error('Etkinlik seçenek modal elementleri bulunamadı!');
        return;
    }
    
    // Modal içeriğini güncelle
    const activityTypeText = activityType === 'term' ? 'Yarıyıl içi' : 'Yarıyıl sonu';
    
    if (activityNode === null) {
        // Etkinlik henüz eklenmedi - önce seçim yapılacak
        title.textContent = `🎯 ${activityTypeText} Etkinlik Ekleme`;
        successText.textContent = `${activityTypeText} etkinlik eklemek istiyorsunuz. Bu etkinliğe nasıl bir içerik eklemek istersiniz?`;
    } else {
        // Etkinlik zaten eklendi - eski davranış
    title.textContent = `🎯 ${activityTypeText} Etkinlik Başarıyla Eklendi!`;
    successText.textContent = `${activityTypeText} etkinlik başarıyla oluşturuldu. Şimdi bu etkinliğe soru veya rubrik eklemek ister misiniz?`;
    }
    
    // ÖÇ seçim alanını doldur
    populateActivityOutcomesSelect();
    
    // Modal'ı göster
    modal.classList.add('active');
    modal.style.display = 'flex';
    
    // Aktif etkinlik bilgisini sakla
    window.currentActivityNode = activityNode;
    window.currentActivityType = activityType;
    
    // ÖÇ'leri yükle
    populateActivityOutcomesSelect();
    
    // İlk seçeneği varsayılan olarak seç
    const firstCard = modal.querySelector('.activity-option-card');
    if (firstCard) {
        selectActivityOption(firstCard);
    }
    
    // Puan alanlarının durumunu kontrol et
    setTimeout(() => {
        updatePointsFieldVisibility();
    }, 100);
}

/**
 * Yeni etkinlik oluştur
 * @param {string} activityType - Etkinlik türü ('term' veya 'final')
 * @returns {Object} Oluşturulan etkinlik node'u
 */
function createNewActivity(activityType) {
    try {
        let newNode, newId;
        
        if (activityType === 'term') {
            // Mevcut yarıyıl içi etkinlikleri say
            const termCount = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A')).length;
            newId = `A${termCount + 1}`;
            newNode = {
                id: newId,
                name: 'Yarıyıl İçi Etkinlik',
                type: ACTIVITY_TYPES.term[0],
                weight: 0,
                points: 100,
                outcomes: [],
                description: 'Yarıyıl içi değerlendirme',
                expanded: true,
                children: []
            };
            
            // Yarıyıl içi etkinliklerini başa ekleyin
            // Var olan yarıyıl içi etkinliklerini bul
            const termNodes = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            
            // Diğer tüm etkinlikleri al
            const otherNodes = APP_STATE.assessmentTree.filter(node => !node.id.startsWith('A'));
            
            // Yeni düğümü yarıyıl içi etkinliklerine ekle
            termNodes.push(newNode);
            
            // Ağacı güncelle - önce tüm yarıyıl içi, sonra diğer etkinlikler
            APP_STATE.assessmentTree = [...termNodes, ...otherNodes];
            
        } else if (activityType === 'final') {
            // Mevcut yarıyıl sonu etkinlikleri say
            const finalCount = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F')).length;
            newId = `F${finalCount + 1}`;
            newNode = {
                id: newId,
                name: 'Yarıyıl Sonu Etkinlik',
                type: ACTIVITY_TYPES.final[0],
                weight: 0,
                points: 100,
                outcomes: [],
                description: 'Yarıyıl sonu değerlendirme',
                expanded: true,
                children: []
            };
            
            // Yarıyıl sonu etkinliklerini sona ekle
            APP_STATE.assessmentTree.push(newNode);
        }
        
        selectNode(newNode);
        
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        // Yeni eklenen etkinlik için otomatik grup ataması
        assignDefaultGroupsToNewActivity(newNode);
        
        // Öğrenci grup bilgilerini güncelle
        updateStudentGroupInfoDisplay();
        
        const activityTypeText = activityType === 'term' ? 'Yarıyıl içi' : 'Yarıyıl sonu';
        showModernToast(`${activityTypeText} etkinlik eklendi.`);
        
        return newNode;
        
    } catch (error) {
        console.error("Etkinlik oluşturulurken hata oluştu:", error);
        showModernToast("Etkinlik oluşturulamadı!", "error");
        return null;
    }
}

/**
 * Etkinlik seçeneği seçimi
 * @param {HTMLElement} cardElement - Seçilen kart elementi
 */
function selectActivityOption(cardElement) {
    const modal = document.getElementById('activityOptionsModal');
    if (!modal) return;
    
    // Tüm kartları deselect et
    modal.querySelectorAll('.activity-option-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    // Seçilen kartı select et
    cardElement.classList.add('selected');
    
    // Apply butonunu aktif et
    const applyBtn = document.getElementById('applyActivityOptions');
    if (applyBtn) {
        applyBtn.disabled = false;
    }
}

/**
 * Etkinlik seçeneklerini uygula
 */
function applyActivityOptions() {
    const modal = document.getElementById('activityOptionsModal');
    const selectedCard = modal.querySelector('.activity-option-card.selected');
    
    if (!selectedCard) {
        showModernToast("Bir seçenek seçin!", "warning");
        return;
    }
    
    const option = selectedCard.dataset.option;
    
    try {
        // Eğer etkinlik henüz eklenmemişse, önce etkinliği oluştur
        if (window.currentActivityNode === null) {
            const newNode = createNewActivity(window.currentActivityType);
            window.currentActivityNode = newNode;
        }
        
        switch (option) {
            case 'questions':
                applyQuestionOption();
                break;
            case 'rubrics':
                applyRubricOption();
                break;
            case 'empty':
                applyEmptyOption();
                break;
            default:
                showModernToast("Geçersiz seçenek!", "error");
                return;
        }
        
        // Modal'ı kapat
        closeActivityOptionsModal();
        
    } catch (error) {
        console.error('Etkinlik seçeneği uygulanırken hata:', error);
        showModernToast("Seçenek uygulanamadı!", "error");
    }
}

/**
 * Soru ekleme seçeneğini uygula
 */
function applyQuestionOption() {
    const questionCount = parseInt(document.getElementById('questionCount').value) || 3;
    const questionType = document.getElementById('questionTypeSelect').value;
    const defaultPoints = parseInt(document.getElementById('questionDefaultPoints').value) || 10;
    const weightDistribution = document.getElementById('questionWeightDistribution').value;
    const selectedOutcomes = getSelectedActivityOutcomes();
    
    const parentNode = window.currentActivityNode;
    if (!parentNode.children) {
        parentNode.children = [];
    }
    
    // Mevcut alt bileşenlerin toplam ağırlığını hesapla
    const existingTotalWeight = parentNode.children.reduce((sum, child) => sum + (parseFloat(child.weight) || 0), 0);
    const availableWeight = Math.max(0, 100 - existingTotalWeight);
    
    // Ağırlık hesaplama - mevcut bileşenleri dikkate al
    let weights = [];
    if (weightDistribution === 'equal') {
        const equalWeight = Math.floor(availableWeight / questionCount);
        weights = Array(questionCount).fill(equalWeight);
        // Kalan ağırlığı son öğeye ekle
        const remainder = availableWeight - (equalWeight * questionCount);
        if (remainder > 0 && weights.length > 0) weights[weights.length - 1] += remainder;
    } else if (weightDistribution === 'random') {
        weights = generateRandomWeights(questionCount, availableWeight);
    } else {
        // Manuel - eşit başla, kullanıcı sonra değiştirebilir
        const equalWeight = Math.floor(availableWeight / questionCount);
        weights = Array(questionCount).fill(equalWeight);
        const remainder = availableWeight - (equalWeight * questionCount);
        if (remainder > 0 && weights.length > 0) weights[weights.length - 1] += remainder;
    }
    
    // Puan hesaplama - ağırlığa göre otomatik dağıtım (varsayılan puan kullanılmaz)
    const totalActivityPoints = 100; // Her etkinlik 100 puan
    let points = weights.map(weight => Math.round((weight / 100) * totalActivityPoints));
    
    // Puanların toplamının tam 100 olmasını sağla
    const currentTotal = points.reduce((a, b) => a + b, 0);
    if (currentTotal !== totalActivityPoints) {
        const diff = totalActivityPoints - currentTotal;
        // Farkı en büyük puana ekle/çıkar
        const maxIndex = points.indexOf(Math.max(...points));
        points[maxIndex] += diff;
        points[maxIndex] = Math.max(1, points[maxIndex]);
    }
    
    // Soru açıklamasını belirle
    const questionDescriptions = {
        'Soru': 'Genel değerlendirme sorusu',
        'Çoktan Seçmeli': 'Birden fazla şık arasından doğru cevabın seçilmesi',
        'Doğru/Yanlış': 'İfadenin doğru veya yanlış olduğunu belirtme',
        'Kısa Cevaplı': 'Kısa ve öz cevap gerektiren soru',
        'Boşluk Doldurma': 'Metindeki boşlukların doldurulması',
        'Eşleştirme': 'Birbirine uygun olan kavramların eşleştirilmesi',
        'Açık Uçlu': 'Kapsamlı ve detaylı cevap gerektiren soru',
        'Problem Çözme': 'Matematiksel veya mantıksal problem çözümü',
        'Kod Yazma': 'Belirli bir programlama dilinde kod yazma',
        'Kod Analiz': 'Verilen kodu analiz etme ve hata bulma',
        'Vaka Analizi': 'Verilen durumu analiz etme ve değerlendirme',
        'Tasarım': 'Ürün, sistem veya süreç tasarımı yapma',
        'Görsel İnceleme': 'Grafik, diyagram veya görsel analizi'
    };
    
    for (let i = 0; i < questionCount; i++) {
        const childCount = parentNode.children.length;
        const newId = `${parentNode.id}.${childCount + 1}`;
        
        const newNode = {
            id: newId,
            name: `${questionType} ${childCount + 1}`,
            type: questionType,
            weight: weights[i],
            points: points[i], // Ağırlığa göre hesaplanan puan
            outcomes: selectedOutcomes.length > 0 ? selectedOutcomes : (parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : []),
            description: questionDescriptions[questionType] || `${questionType} sorusu`,
            expanded: false
        };
        
        parentNode.children.push(newNode);
        
        // Yeni bileşen için default mapping ataması
        assignDefaultMappingToNewComponent(parentNode.id, newNode);
    }
    
    // Etkinliğin toplam puanını kontrol et ve 100'e tamamla
    ensureActivityTotalPoints(parentNode);
    
    parentNode.expanded = true;
    renderTree();
    updateAssessmentView();
    
    // DÜZELTME: Yeni sorular eklendikten sonra grup haritalamalarını güncelle
    updateGroupMappingsAfterNodeAdd(parentNode.id);
    
    // Öğrenci grup bilgilerini güncelle
    updateStudentGroupInfoDisplay();
    
    const outcomeText = selectedOutcomes.length > 0 ? ` (${selectedOutcomes.join(', ')} ÖÇleri ile)` : '';
    const totalWeight = weights.reduce((a,b) => a+b, 0);
    const totalPoints = points.reduce((a,b) => a+b, 0);
    showModernToast(`${questionCount} adet ${questionType} sorusu eklendi! (${totalWeight}% ağırlık, ${totalPoints} puan)${outcomeText}`, "success");
}

/**
 * Rubrik ekleme seçeneğini uygula
 */
function applyRubricOption() {
    const rubricCount = parseInt(document.getElementById('rubricCount').value) || 2;
    const rubricType = document.getElementById('rubricTypeSelect').value;
    const defaultPoints = parseInt(document.getElementById('rubricDefaultPoints').value) || 20;
    const weightDistribution = document.getElementById('rubricWeightDistribution').value;
    const selectedOutcomes = getSelectedActivityOutcomes();
    
    const parentNode = window.currentActivityNode;
    if (!parentNode.children) {
        parentNode.children = [];
    }
    
    // Mevcut alt bileşenlerin toplam ağırlığını hesapla
    const existingTotalWeight = parentNode.children.reduce((sum, child) => sum + (parseFloat(child.weight) || 0), 0);
    const availableWeight = Math.max(0, 100 - existingTotalWeight);
    
    // Ağırlık hesaplama - mevcut bileşenleri dikkate al
    let weights = [];
    if (weightDistribution === 'equal') {
        const equalWeight = Math.floor(availableWeight / rubricCount);
        weights = Array(rubricCount).fill(equalWeight);
        // Kalan ağırlığı son öğeye ekle
        const remainder = availableWeight - (equalWeight * rubricCount);
        if (remainder > 0 && weights.length > 0) weights[weights.length - 1] += remainder;
    } else if (weightDistribution === 'random') {
        weights = generateRandomWeights(rubricCount, availableWeight);
    } else {
        // Manuel - eşit başla, kullanıcı sonra değiştirebilir
        const equalWeight = Math.floor(availableWeight / rubricCount);
        weights = Array(rubricCount).fill(equalWeight);
        const remainder = availableWeight - (equalWeight * rubricCount);
        if (remainder > 0 && weights.length > 0) weights[weights.length - 1] += remainder;
    }
    
    // Puan hesaplama - ağırlığa göre otomatik dağıtım (varsayılan puan kullanılmaz)
    const totalActivityPoints = 100; // Her etkinlik 100 puan
    let points = weights.map(weight => Math.round((weight / 100) * totalActivityPoints));
    
    // Puanların toplamının tam 100 olmasını sağla
    const currentTotal = points.reduce((a, b) => a + b, 0);
    if (currentTotal !== totalActivityPoints) {
        const diff = totalActivityPoints - currentTotal;
        // Farkı en büyük puana ekle/çıkar
        const maxIndex = points.indexOf(Math.max(...points));
        points[maxIndex] += diff;
        points[maxIndex] = Math.max(1, points[maxIndex]);
    }
    
    // Rubrik açıklamasını belirle
    const rubricDescriptions = {
        'Rubrik': 'Genel değerlendirme rubriği',
        'Proje Planlama': 'Proje planlama ve süreç yönetimi değerlendirmesi',
        'Proje Raporu': 'Proje raporu yazımı ve içerik kalitesi',
        'Proje Sunumu': 'Proje sunumu ve anlatım kalitesi',
        'Kod Yapısı': 'Kod organizasyonu ve mimari yapı',
        'Kod Kalitesi': 'Kod kalitesi, okunabilirlik ve bakım yapılabilirlik',
        'Performans': 'Kodun performans ve kaynak kullanımı',
        'Dokümantasyon': 'Kod dokümantasyonu ve yorum kalitesi',
        'Teorik Bilgi': 'Teorik bilgi ve kavramları anlama',
        'Problem Çözme': 'Problem analizi ve çözüm yaklaşımı',
        'Uygulama': 'Teorik bilginin uygulamaya aktarılması',
        'İçerik': 'Sunum içeriği ve bilgi doğruluğu',
        'Görsel Tasarım': 'Sunum görsel tasarımı ve materyal kalitesi',
        'Sunum Becerisi': 'Anlatım becerisi ve iletişim',
        'Zaman Yönetimi': 'Sunum zamanının etkin kullanımı',
        'Deney Hazırlığı': 'Deney öncesi hazırlık ve planlama',
        'Deney Uygulaması': 'Deney prosedürlerinin uygulanması',
        'Veri Analizi': 'Verilerin analizi ve değerlendirilmesi',
        'Laboratuvar Raporu': 'Laboratuvar raporu yazımı ve kalitesi'
    };
    
    for (let i = 0; i < rubricCount; i++) {
        const childCount = parentNode.children.length;
        const newId = `${parentNode.id}.${childCount + 1}`;
        
        const newNode = {
            id: newId,
            name: `${rubricType} ${childCount + 1}`,
            type: rubricType,
            weight: weights[i],
            points: points[i], // Ağırlığa göre hesaplanan puan
            outcomes: selectedOutcomes.length > 0 ? selectedOutcomes : (parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : []),
            description: rubricDescriptions[rubricType] || `${rubricType} rubriği`,
            expanded: false
        };
        
        parentNode.children.push(newNode);
        
        // Yeni bileşen için default mapping ataması
        assignDefaultMappingToNewComponent(parentNode.id, newNode);
    }
    
    // Etkinliğin toplam puanını kontrol et ve 100'e tamamla
    ensureActivityTotalPoints(parentNode);
    
    parentNode.expanded = true;
    renderTree();
    updateAssessmentView();
    
    // DÜZELTME: Yeni rubrikler eklendikten sonra grup haritalamalarını güncelle
    updateGroupMappingsAfterNodeAdd(parentNode.id);
    
    // Öğrenci grup bilgilerini güncelle
    updateStudentGroupInfoDisplay();
    
    const outcomeText = selectedOutcomes.length > 0 ? ` (${selectedOutcomes.join(', ')} ÖÇleri ile)` : '';
    const totalWeight = weights.reduce((a,b) => a+b, 0);
    const totalPoints = points.reduce((a,b) => a+b, 0);
    showModernToast(`${rubricCount} adet ${rubricType} rubriği eklendi! (${totalWeight}% ağırlık, ${totalPoints} puan)${outcomeText}`, "success");
}

/**
 * Boş bırakma seçeneğini uygula
 */
function applyEmptyOption() {
    // Eğer etkinlik henüz eklenmemişse, önce etkinliği oluştur
    if (window.currentActivityNode === null) {
        const newNode = createNewActivity(window.currentActivityType);
        window.currentActivityNode = newNode;
        
        if (!newNode) {
            showModernToast("Etkinlik oluşturulamadı!", "error");
            return;
        }
    }
    
    showModernToast("Etkinlik boş bırakıldı. Daha sonra manuel olarak soru/rubrik ekleyebilirsiniz.", "info");
}

/**
 * Rastgele ağırlık dağılımı oluştur
 * @param {number} count - Öğe sayısı
 * @param {number} totalWeight - Toplam ağırlık (varsayılan: 100)
 * @returns {Array} - Ağırlık dizisi (toplamı totalWeight)
 */
function generateRandomWeights(count, totalWeight = 100) {
    if (count === 1) return [totalWeight];
    
    // Rastgele sayılar üret
    let weights = [];
    for (let i = 0; i < count - 1; i++) {
        weights.push(Math.random());
    }
    
    // Sırala
    weights.sort((a, b) => a - b);
    
    // Aralıklara çevir
    let intervals = [];
    intervals.push(weights[0]);
    for (let i = 1; i < weights.length; i++) {
        intervals.push(weights[i] - weights[i-1]);
    }
    intervals.push(1 - weights[weights.length - 1]);
    
    // totalWeight'e çevir ve yuvarla
    let result = intervals.map(w => Math.max(1, Math.round(w * totalWeight)));
    
    // Toplamı totalWeight yap
    let total = result.reduce((a, b) => a + b, 0);
    if (total !== totalWeight) {
        let diff = totalWeight - total;
        // Farkı en büyük değere ekle/çıkar
        let maxIndex = result.indexOf(Math.max(...result));
        result[maxIndex] += diff;
        result[maxIndex] = Math.max(1, result[maxIndex]);
    }
    
    return result;
}

/**
 * Etkinliğin toplam puanının 100 olmasını sağla
 * @param {Object} parentNode - Etkinlik düğümü
 */
function ensureActivityTotalPoints(parentNode) {
    if (!parentNode || !parentNode.children || parentNode.children.length === 0) return;
    
    const totalPoints = parentNode.children.reduce((sum, child) => sum + (parseFloat(child.points) || 0), 0);
    const targetPoints = 100;
    
    if (totalPoints !== targetPoints && totalPoints > 0) {
        const diff = targetPoints - totalPoints;
        
        // Farkı en büyük puana sahip öğeye ekle/çıkar
        let maxPointsIndex = 0;
        let maxPoints = parseFloat(parentNode.children[0].points) || 0;
        
        for (let i = 1; i < parentNode.children.length; i++) {
            const currentPoints = parseFloat(parentNode.children[i].points) || 0;
            if (currentPoints > maxPoints) {
                maxPoints = currentPoints;
                maxPointsIndex = i;
            }
        }
        
        // Puanı güncelle
        parentNode.children[maxPointsIndex].points = Math.max(1, maxPoints + diff);
        
        console.log(`🎯 Etkinlik ${parentNode.id} puan toplamı ${totalPoints} -> ${targetPoints} olarak ayarlandı`);
    }
}

/**
 * Etkinlik seçenek modalını kapat
 */
function closeActivityOptionsModal() {
    const modal = document.getElementById('activityOptionsModal');
    if (modal) {
        modal.classList.remove('active');
        modal.style.display = 'none';
        
        // Temizle
        window.currentActivityNode = null;
        window.currentActivityType = null;
        
        // ÖÇ seçimlerini temizle
        clearAllActivityOutcomes();
        
        // Seçili kartları temizle
        modal.querySelectorAll('.activity-option-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Apply butonunu deaktif et
        const applyBtn = document.getElementById('applyActivityOptions');
        if (applyBtn) {
            applyBtn.disabled = true;
        }
    }
}

/**
 * Count selector butonları için event handler
 */
function updateCountValue(target, delta) {
    const input = document.getElementById(target);
    if (!input) return;
    
    const currentValue = parseInt(input.value) || 0;
    const newValue = Math.max(1, Math.min(50, currentValue + delta));
    input.value = newValue;
}

// Global fonksiyonlar
window.showActivityOptionsModal = showActivityOptionsModal;
window.selectActivityOption = selectActivityOption;
window.applyActivityOptions = applyActivityOptions;
window.closeActivityOptionsModal = closeActivityOptionsModal;
window.updateCountValue = updateCountValue;

// =====================================================
// ID YÖNETİMİ SİSTEMİ
// =====================================================

/**
 * Sıralı ID üretimi
 * @param {Object} parentNode - Üst düğüm
 * @returns {string} - Sıralı ID
 */
function generateSequentialId(parentNode) {
    if (!parentNode || !parentNode.children) {
        return parentNode ? `${parentNode.id}.1` : '1';
    }
    
    // Mevcut ID'leri al ve sırayla düzenle
    const childIds = parentNode.children.map(child => {
        const parts = child.id.split('.');
        return parseInt(parts[parts.length - 1]) || 0;
    });
    
    // En büyük ID'yi bul ve 1 ekle
    const maxId = childIds.length > 0 ? Math.max(...childIds) : 0;
    return `${parentNode.id}.${maxId + 1}`;
}

/**
 * Tüm ID'leri yeniden düzenle
 * @param {Object} parentNode - Üst düğüm
 */
function reorderAllIds(parentNode) {
    if (!parentNode || !parentNode.children) return;
    
    const idMigrationMap = {}; // ID değişikliklerini takip et
    
    parentNode.children.forEach((child, index) => {
        const oldId = child.id;
        const newId = `${parentNode.id}.${index + 1}`;
        
        if (oldId !== newId) {
            // ID değişikliğini kaydet
            idMigrationMap[oldId] = newId;
            
            // Grup haritalamalarını güncelle
            updateGroupMappingForId(oldId, newId);
            
            // ID'yi güncelle
            child.id = newId;
            
            // Alt düğümleri de güncelle
            if (child.children && child.children.length > 0) {
                reorderAllIds(child);
            }
        }
    });
    
    // Basit not migrasyonu (GUID olmadan)
    if (Object.keys(idMigrationMap).length > 0) {
        migrateGradesData(idMigrationMap);
    }
}

/**
 * Basit not migrasyonu (GUID olmadan)
 */
function migrateGradesData(idMigrationMap) {
    if (!APP_STATE.gradesData || Object.keys(idMigrationMap).length === 0) return;
    
    console.log('🔄 Basit not migrasyon başlatılıyor...', idMigrationMap);
    
    Object.keys(APP_STATE.gradesData).forEach(studentId => {
        const studentGrades = APP_STATE.gradesData[studentId];
        if (!studentGrades || typeof studentGrades !== 'object') return;
        
        // Her ID değişikliği için
        Object.entries(idMigrationMap).forEach(([oldId, newId]) => {
            if (studentGrades.hasOwnProperty(oldId)) {
                const gradeValue = studentGrades[oldId];
                
                // Yeni ID ile sakla
                studentGrades[newId] = gradeValue;
                
                // Eski ID'yi sil
                delete studentGrades[oldId];
                
                console.log(`✅ Not Migrasyon: ${studentId} - ${oldId} -> ${newId}`);
            }
        });
    });
    
    console.log('✅ Basit not migrasyon tamamlandı!');
}

/**
 * Grup haritalamalarında ID referanslarını güncelle
 * @param {string} oldId - Eski ID
 * @param {string} newId - Yeni ID
 */
function updateGroupMappingForId(oldId, newId) {
    if (!APP_STATE.courseData || !APP_STATE.courseData.grupHaritalari) return;
    
    Object.keys(APP_STATE.courseData.grupHaritalari).forEach(groupName => {
        const activities = APP_STATE.courseData.grupHaritalari[groupName];
        
        Object.keys(activities).forEach(activityId => {
            const questionList = activities[activityId];
            
            // Eski ID'yi yeni ID ile değiştir
            const index = questionList.indexOf(oldId);
            if (index !== -1) {
                questionList[index] = newId;
            }
        });
    });
}

/**
 * Öğeyi yukarı taşı
 * @param {Object} node - Taşınacak düğüm
 */
function moveItemUp(node) {
    const parent = findParentNode(node.id);
    if (!parent || !parent.children) return;
    
    const index = parent.children.findIndex(child => child.id === node.id);
    if (index <= 0) return; // Zaten en üstte
    
    // Öğeleri yer değiştir
    [parent.children[index - 1], parent.children[index]] = 
    [parent.children[index], parent.children[index - 1]];
    
    // ID'leri yeniden düzenle
    reorderAllIds(parent);
    
    // Görünümü güncelle
    renderTree();
    updateAssessmentView();
    
    showModernToast(`"${node.name}" yukarı taşındı.`, "success");
}

/**
 * Öğeyi aşağı taşı
 * @param {Object} node - Taşınacak düğüm
 */
function moveItemDown(node) {
    const parent = findParentNode(node.id);
    if (!parent || !parent.children) return;
    
    const index = parent.children.findIndex(child => child.id === node.id);
    if (index >= parent.children.length - 1) return; // Zaten en altta
    
    // Öğeleri yer değiştir
    [parent.children[index], parent.children[index + 1]] = 
    [parent.children[index + 1], parent.children[index]];
    
    // ID'leri yeniden düzenle
    reorderAllIds(parent);
    
    // Görünümü güncelle
    renderTree();
    updateAssessmentView();
    
    showModernToast(`"${node.name}" aşağı taşındı.`, "success");
}

/**
 * Üst düğümü bulma
 * @param {string} nodeId - Düğüm ID'si
 * @returns {Object|null} - Üst düğüm
 */
function findParentNode(nodeId) {
    const searchInTree = (nodes, targetId) => {
        for (const node of nodes) {
            if (node.children) {
                for (const child of node.children) {
                    if (child.id === targetId) {
                        return node;
                    }
                }
                const found = searchInTree(node.children, targetId);
                if (found) return found;
            }
        }
        return null;
    };
    
    return searchInTree(APP_STATE.assessmentTree, nodeId);
}

// =====================================================
// YARDIMCI FONKSIYONLAR
// =====================================================

/**
 * ID'ye göre düğüm bulma
 * @param {string} id - Aranacak düğüm ID'si
 * @returns {Object|null} - Bulunan düğüm veya null
 */
function findNodeById(id) {
    // Yardımcı iç fonksiyon
    const searchNode = (node) => {
        if (node.id === id) return node;
        
        if (node.children && node.children.length > 0) {
            for (const child of node.children) {
                const found = searchNode(child);
                if (found) return found;
            }
        }
        
        return null;
    };
    
    // Tüm ağaçta ara
    for (const rootNode of APP_STATE.assessmentTree) {
        const found = searchNode(rootNode);
        if (found) return found;
    }
    
    return null;
}

/**
 * Harf notunu hesaplama
 * @param {number} totalGrade - Toplam not
 * @returns {string} - Harf notu
 */
function getLetterGrade(totalGrade) {
    if (totalGrade >= 90) return 'AA';
    if (totalGrade >= 85) return 'BA';
    if (totalGrade >= 80) return 'BB';
    if (totalGrade >= 75) return 'CB';
    if (totalGrade >= 70) return 'CC';
    if (totalGrade >= 60) return 'DC';
    if (totalGrade >= 50) return 'DD';
    if (totalGrade >= 40) return 'FD';
    return 'FF';
}

/**
 * Rastgele öğrenme çıktıları alma
 * @param {number} count - İstenilen çıktı sayısı
 * @returns {Array} - Rastgele öğrenme çıktıları ID'leri
 */
function getRandomOutcomes(count) {
    if (!APP_STATE.learningOutcomes || APP_STATE.learningOutcomes.length === 0) {
        return [];
    }
    
    // Öğrenme çıktılarından rastgele seç
    const outcomes = [];
    const availableOutcomes = [...APP_STATE.learningOutcomes];
    
    for (let i = 0; i < Math.min(count, availableOutcomes.length); i++) {
        const randomIndex = Math.floor(Math.random() * availableOutcomes.length);
        outcomes.push(availableOutcomes[randomIndex].id);
        availableOutcomes.splice(randomIndex, 1);
    }
    
    return outcomes;
}

/**
 * Akıllı öğrenme çıktıları seçme - JSON yüklendiğinde kullanılır
 * @param {number} count - Seçilecek öğrenme çıktısı sayısı
 * @returns {Array} - Seçilen öğrenme çıktıları
 */
function getSmartOutcomes(count) {
    if (!APP_STATE.learningOutcomes || APP_STATE.learningOutcomes.length === 0) {
        return [];
    }
    
    // Öğrenme çıktılarından akıllıca seç
    const outcomes = [];
    const availableOutcomes = [...APP_STATE.learningOutcomes];
    
    for (let i = 0; i < Math.min(count, availableOutcomes.length); i++) {
        const randomIndex = Math.floor(Math.random() * availableOutcomes.length);
        outcomes.push(availableOutcomes[randomIndex].id);
        availableOutcomes.splice(randomIndex, 1);
    }
    
    return outcomes;
}

/**
 * Alt düğümlerin öğrenme çıktılarını toplama
 * @param {Array} children - Alt düğümler
 * @param {Set} outcomeSet - Öğrenme çıktıları set'i
 */
function collectChildOutcomes(children, outcomeSet) {
    children.forEach(child => {
        if (child.outcomes && child.outcomes.length) {
            child.outcomes.forEach(outcome => outcomeSet.add(outcome));
        }
        
        if (child.children && child.children.length > 0) {
            collectChildOutcomes(child.children, outcomeSet);
        }
    });
}

/**
 * Seçili sekmeyi değiştirme
 * @param {string} tabId - Sekme ID'si
 */
// İlk switchTab fonksiyonu silindi - çakışmayı önlemek için (daha kapsamlı versiyon var)

// İlk modal fonksiyonları silindi - çakışmayı önlemek için (daha kapsamlı versiyonlar var)

// =====================================================
// AĞAÇ VE DEĞERLENDİRME FONKSİYONLARI
// =====================================================

/**
 * Düğüm seçme
 * @param {Object} node - Seçilecek düğüm
 */
function selectNode(node) {
    APP_STATE.selectedNode = node;
    renderTree();
}

/**
 * Yarıyıl içi etkinlik ekleme
 */
function addTermActivity() {
    try {
        // Önce modal göster - etkinlik henüz eklenmedi
        showActivityOptionsModal('term', null);
		
    } catch (error) {
        console.error("Yarıyıl içi etkinlik modalı açılırken hata oluştu:", error);
        showModernToast("Modal açılamadı!", "error");
    }
}

/**
 * Yarıyıl sonu etkinlik ekleme
 */
function addFinalActivity() {
    try {
        // Önce modal göster - etkinlik henüz eklenmedi
        showActivityOptionsModal('final', null);
		
    } catch (error) {
        console.error("Yarıyıl sonu etkinlik modalı açılırken hata oluştu:", error);
        showModernToast("Modal açılamadı!", "error");
    }
}

/**
 * Düğüme soru ekleme
 * @param {Object} parentNode - Üst düğüm
 * @param {string} questionType - Soru tipi
 * @param {string} description - Açıklama
 */
// İlk addQuestionToNode fonksiyonu silindi - çakışmayı önlemek için

/**
 * Düğüme test ekleme (toplu çoktan seçmeli sorular)
 * @param {Object} parentNode - Üst düğüm
 */
function addTestToNode(parentNode) {
    if (!parentNode) return;
    
    try {
        if (!parentNode.children) {
            parentNode.children = [];
        }
        
        const childCount = parentNode.children.length;
        const newId = `${parentNode.id}.${childCount + 1}`;
        
        // Öğrenme çıktıları varsa ilk öğrenme çıktısını atayalım
        const outcome = parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : [];
        
        const newNode = {
            id: newId,
            name: "Test Soruları",
            type: "Test",
            weight: 20, // Varsayılan ağırlık
            points: 100, // Varsayılan toplam puan
            outcomes: outcome,
            description: "Çoktan seçmeli test soruları",
            expanded: true,
            children: [],
            testDetails: {
                totalQuestions: 20,
                correctWeight: 5,
                wrongPenalty: 0
            }
        };
        
        parentNode.children.push(newNode);
        parentNode.expanded = true;
        selectNode(newNode);
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
        
        // Test detayları için modal göster
        APP_STATE.testDetailsNode = newNode;
        showTestDetailsModal();
        
        showModernToast("Test soruları eklendi.");
    } catch (error) {
        console.error("Test eklenirken hata oluştu:", error);
        showModernToast("Test eklenemedi!", "error");
    }
}

// İlk test modal fonksiyonları silindi - çakışmayı önlemek için

/**
 * Düğüme rubrik ekleme
 * @param {Object} parentNode - Üst düğüm
 * @param {string} rubricType - Rubrik tipi
 * @param {string} description - Açıklama
 */
// İlk addRubricToNode fonksiyonu silindi - çakışmayı önlemek için

/**
 * Soru ekleme fonksiyonu
 * Bir etkinliğe soru eklemek için kullanılır
 */
function addQuestion() {
    if (!APP_STATE.selectedNode) {
        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
        return;
    }
    
    // Seçili düğüm kök değilse alt düğüm eklenmemeli
    if (APP_STATE.selectedNode.id.includes('.')) {
        showModernToast("Sorular sadece ana etkinliklere eklenebilir.", "warning");
        return;
    }
    
    // Çoklu soru eklemek için modal göster
    // Bu satırı yorum haline getirip doğrudan ekleme de yapabilirsiniz
    showMultipleItemsModal('soru');
    
    /* 
    // Tek soru eklemek için bu kısmı kullanabilirsiniz
    addQuestionToNode(APP_STATE.selectedNode);
    */
}

/**
 * Rubrik ekleme fonksiyonu
 * Bir etkinliğe rubrik eklemek için kullanılır
 */
function addRubric() {
    if (!APP_STATE.selectedNode) {
        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
        return;
    }
    
    // Seçili düğüm kök değilse alt düğüm eklenmemeli
    if (APP_STATE.selectedNode.id.includes('.')) {
        showModernToast("Rubrikler sadece ana etkinliklere eklenebilir.", "warning");
        return;
    }
    
    // Çoklu rubrik eklemek için modal göster
    showMultipleItemsModal('rubrik');
    
    /* 
    // Tek rubrik eklemek için bu kısmı kullanabilirsiniz
    addRubricToNode(APP_STATE.selectedNode);
    */
}

/**
 * Düğüm silme
 */
function removeNode() {
    if (!APP_STATE.selectedNode) {
        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
        return;
    }
    
    showDeleteConfirmModal(
        function() {
            try {
                // Kök düğüm mü kontrol et
                const isRoot = !APP_STATE.selectedNode.id.includes('.');
                
                if (isRoot) {
                    // Kök düğümü sil
                    const index = APP_STATE.assessmentTree.findIndex(node => node.id === APP_STATE.selectedNode.id);
                    if (index !== -1) {
                        APP_STATE.assessmentTree.splice(index, 1);
                    }
                } else {
                    // Alt düğümü sil
                    const parentId = APP_STATE.selectedNode.id.substring(0, APP_STATE.selectedNode.id.lastIndexOf('.'));
                    const findParentAndRemoveChild = (nodes, id) => {
                        for (let i = 0; i < nodes.length; i++) {
                            const node = nodes[i];
                            if (node.id === parentId && node.children) {
                                const childIndex = node.children.findIndex(child => child.id === id);
                                if (childIndex !== -1) {
                                    node.children.splice(childIndex, 1);
                                    return true;
                                }
                            }
                            
                            if (node.children && node.children.length > 0) {
                                if (findParentAndRemoveChild(node.children, id)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    findParentAndRemoveChild(APP_STATE.assessmentTree, APP_STATE.selectedNode.id);
                }
                
                APP_STATE.selectedNode = null;
                renderTree();
                
                // Değerlendirme sekmesini güncelle
                updateAssessmentView();
                
                showModernToast("Etkinlik başarıyla silindi.");
            } catch (error) {
                console.error("Düğüm silinirken hata oluştu:", error);
                showModernToast("Etkinlik silinemedi!", "error");
            }
        },
        `"${APP_STATE.selectedNode.name}" etkinliğini ve tüm alt öğelerini silmek istediğinizden emin misiniz?`
    );
}

/**
 * Tüm düğümleri genişlet
 */
function expandAll() {
    const expandNodes = (nodes) => {
        nodes.forEach(node => {
            node.expanded = true;
            if (node.children && node.children.length > 0) {
                expandNodes(node.children);
            }
        });
    };
    
    expandNodes(APP_STATE.assessmentTree);
    renderTree();
    showModernToast("Tüm etkinlikler genişletildi.");
}

/**
 * Tüm düğümleri daralt
 */
function collapseAll() {
    const collapseNodes = (nodes) => {
        nodes.forEach(node => {
            node.expanded = false;
            if (node.children && node.children.length > 0) {
                collapseNodes(node.children);
            }
        });
    };
    
    collapseNodes(APP_STATE.assessmentTree);
    renderTree();
    showModernToast("Tüm etkinlikler daraltıldı.");
}

/**
 * Öğrenme çıktılarını güncelleme
 * @param {Object} node - Güncellenecek düğüm
 * @param {HTMLInputElement} outcomesInput - Çıktılar input elementi
 */
function updateOutcomes(node, outcomesInput) {
    try {
        const inputValue = outcomesInput.value.trim();
        
        // Alt düğüm ise (soru veya rubrik), sadece bir ÖÇ atanabilsin
        const isSubItem = node.id.includes('.');
        
        if (isSubItem) {
            const outcomes = inputValue.split(',').map(s => s.trim()).filter(s => s);
            
            if (outcomes.length > 1) {
                showModernToast("Soru veya Rubrik sadece bir Öğrenme Çıktısına atanabilir!", "warning");
                // İlk öğrenme çıktısını al
                node.outcomes = outcomes.slice(0, 1);
                outcomesInput.value = Array.isArray(node.outcomes) ? node.outcomes.join(',') : '';
            } else {
                node.outcomes = outcomes;
            }
        } else {
            // Ana etkinlik için birden çok ÖÇ atanabilir
            node.outcomes = inputValue.split(',').map(s => s.trim()).filter(s => s);
        }
        
        // outcomes'ın her zaman array olduğundan emin ol
        if (!Array.isArray(node.outcomes)) {
            node.outcomes = [];
        }
        
        // Alt düğümlerin öğrenme çıktılarını ana düğüme kopyala
        if (!isSubItem && node.children && node.children.length > 0) {
            const childOutcomes = new Set();
            collectChildOutcomes(node.children, childOutcomes);
            
            // Eğer childOutcomes boş değilse, ana düğümün outcomes'ını güncelle
            if (childOutcomes.size > 0) {
                node.outcomes = Array.from(childOutcomes);
                outcomesInput.value = Array.isArray(node.outcomes) ? node.outcomes.join(',') : '';
            }
        }
        
        // ÖÇ değişikliği olduğunda değerlendirme sekmesini güncelle
        setTimeout(() => {
            updateAssessmentView();
        }, 100);
    } catch (error) {
        console.error("Öğrenme çıktıları güncellenirken hata oluştu:", error);
        showModernToast("Öğrenme çıktıları güncellenemedi!", "error");
        
        // Hata durumunda güvenli değer ata
        node.outcomes = [];
        outcomesInput.value = '';
    }
}

/**
 * Kategori ağırlıklarını güncelleme
 */
/**
 * Kategori ağırlıklarını güncelleme
 */
function updateCategoryWeights() {
    try {
        // Yarıyıl içi ve yarıyıl sonu etkinlikleri ayır
        const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
        const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
        
        // Her kategori içinde toplam ağırlıkları hesapla
        const termInternalTotal = termActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        const finalInternalTotal = finalActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        
        // Sabit tanımlı genel değerlendirme ağırlıkları - JSON'dan geliyor, değişmez
        const termContribution = APP_STATE.courseData?.dersDegerlendirme?.genelDegerlendirme?.find(
            item => item.degerlendirme.includes("İçi"))?.katkiYuzdesi || 40;
        const finalContribution = APP_STATE.courseData?.dersDegerlendirme?.genelDegerlendirme?.find(
            item => item.degerlendirme.includes("Sonu"))?.katkiYuzdesi || 60;
        
        // Genel ağırlıkları kaydet
        APP_STATE.termWeight = termContribution;  
        APP_STATE.finalWeight = finalContribution;
        
        // Bu değerler değişmez - sabit kalmalı
        document.getElementById('termGeneralWeight').textContent = termContribution;
        document.getElementById('finalGeneralWeight').textContent = finalContribution;
        
        // İç ağırlık toplamları güncellenir
        document.getElementById('termInternalTotal').textContent = termInternalTotal;
        document.getElementById('finalInternalTotal').textContent = finalInternalTotal;
        
        // İç toplamlar 100% değilse uyarı rengiyle göster
        if (termInternalTotal !== 100) {
            document.getElementById('termInternalTotal').style.color = 'var(--danger-color)';
        } else {
            document.getElementById('termInternalTotal').style.color = '';
        }
        
        if (finalInternalTotal !== 100) {
            document.getElementById('finalInternalTotal').style.color = 'var(--danger-color)';
        } else {
            document.getElementById('finalInternalTotal').style.color = '';
        }
        
        // Progress barları sadece gösterim amaçlı
        termProgress.style.width = `${termInternalTotal}%`;
        finalProgress.style.width = `${finalInternalTotal}%`;
        
        // Detaylı bilgilendirme etiketlerini güncelle
        updateCategoryDetails(termActivities, 'termDetails');
        updateCategoryDetails(finalActivities, 'finalDetails');
        
        // Course Data'yı güncelle
        if (APP_STATE.courseData && APP_STATE.courseData.dersDegerlendirme) {
            // Yarıyıl içi etkinliklerini güncelle
            APP_STATE.courseData.dersDegerlendirme.yariyilIciEtkinlikleri = termActivities.map(node => ({
                "etkinlik": node.type,
                "sayi": 1,
                "katkiYuzdesi": node.weight,
                "id": node.id
            }));
            
            // Yarıyıl sonu etkinliklerini güncelle
            APP_STATE.courseData.dersDegerlendirme.yariyilSonuEtkinlikleri = finalActivities.map(node => ({
                "etkinlik": node.type,
                "sayi": 1,
                "katkiYuzdesi": node.weight,
                "id": node.id
            }));
            
            // Toplamları güncelle
            APP_STATE.courseData.dersDegerlendirme.yariyilIciToplam = termInternalTotal;
            APP_STATE.courseData.dersDegerlendirme.yariyilSonuToplam = finalInternalTotal;
            // Genel değerlendirme değişmez (40-60)
        }
    } catch (error) {
        console.error("Kategori ağırlıkları güncellenirken hata oluştu:", error);
    }
}

/**
 * Kategori detaylarını güncelle (bilgilendirme etiketleri)
 * @param {Array} activities - Etkinlikler listesi
 * @param {string} containerId - Detay container ID'si
 */
function updateCategoryDetails(activities, containerId) {
    try {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // Container'ı temizle
        container.innerHTML = '';
        
        if (!activities || activities.length === 0) {
            // Boş durum etiketi
            const emptyTag = document.createElement('span');
            emptyTag.className = 'detail-tag empty-tag';
            emptyTag.innerHTML = '<span class="tag-icon">📭</span> Henüz etkinlik eklenmedi';
            container.appendChild(emptyTag);
            return;
        }
        
        // Kompakt etiket sistemi - sadece etkinlikler
        activities.forEach((activity) => {
            // Bu etkinliğin soru ve rubrik sayılarını hesapla
            let activityQuestions = 0;
            let activityRubrics = 0;
            
            if (activity.children && activity.children.length > 0) {
                activity.children.forEach(child => {
                    if (child.type === 'Soru' || child.type.includes('Soru') || isQuestionType(child.type) || child.type === 'Test') {
                        activityQuestions++;
                    } else if (child.type === 'Rubrik' || child.type.includes('Rubrik') || isRubricType(child.type)) {
                        activityRubrics++;
                    }
                });
            }
            
            // İkon seçimi
            const getActivityIcon = (type) => {
                if (type.includes('Sınav')) return '📝';
                if (type.includes('Quiz')) return '❓';
                if (type.includes('Proje')) return '🚀';
                if (type.includes('Rapor')) return '📊';
                if (type.includes('Deney')) return '🧪';
                if (type.includes('Laboratuvar')) return '⚗️';
                if (type.includes('Sunum')) return '🎤';
                if (type.includes('Seminer')) return '🎓';
                return '📚';
            };
            
            // Etkinlik adını kısalt
            const activityName = activity.name || activity.type || `Etkinlik ${activity.id}`;
            const shortName = activityName.length > 15 ? activityName.substring(0, 15) + '...' : activityName;
            
            // Tek kompakt etiket oluştur - tüm bilgiler bir arada
            const activityTag = document.createElement('span');
            activityTag.className = 'detail-tag activity-single-tag';
            
            // Grup bilgisini al
            const getGroupInfo = (activityId) => {
                if (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari && APP_STATE.courseData.grupHaritalari[activityId]) {
                    const component = APP_STATE.courseData.grupHaritalari[activityId];
                    if (component.gruplar && Array.isArray(component.gruplar)) {
                        const validGroups = component.gruplar.filter(group => 
                            group && group.length === 1 && /^[A-Z]$/.test(group)
                        );
                        if (validGroups.length > 0) {
                            const groupCount = validGroups.length;
                            return ` [${groupCount} Grup]`;
                        }
                    }
                }
                return ' [1 Grup]'; // Varsayılan grup
            };
            
            // Tüm bilgileri tek satırda topla
            let fullInfo = `${getActivityIcon(activity.type)} ${shortName} %${activity.weight || 0}`;
            
            // Soru ve rubrik bilgilerini ekle
            if (activityQuestions > 0 && activityRubrics > 0) {
                fullInfo += ` (${activityQuestions} Soru, ${activityRubrics} Rubrik)`;
            } else if (activityQuestions > 0) {
                fullInfo += ` (${activityQuestions} Soru)`;
            } else if (activityRubrics > 0) {
                fullInfo += ` (${activityRubrics} Rubrik)`;
            } else {
                fullInfo += ` (Boş)`;
            }
            
            // Grup bilgisini ekle
            fullInfo += getGroupInfo(activity.id);
            
            activityTag.innerHTML = fullInfo;
            activityTag.title = `${activityName}\nAğırlık: %${activity.weight || 0}\n${activityQuestions} Soru, ${activityRubrics} Rubrik\n${getGroupInfo(activity.id).replace(/[\[\]]/g, '')}`;
            
            container.appendChild(activityTag);
        });
        
    } catch (error) {
        console.error("Kategori detayları güncellenirken hata:", error);
    }
}

// =====================================================
// RENDER VE UI GÜNCELLEME FONKSIYONLARI
// =====================================================

/**
 * Düğüm render etme fonksiyonunu güncelleyelim
 * @param {Object} node - Render edilecek düğüm
 * @param {HTMLElement} parentElement - Üst element
 * @param {number} level - Düğüm seviyesi
 */
function renderNode(node, parentElement, level) {
    try {
        const nodeElement = document.createElement('div');
        nodeElement.className = 'tree-node';
        nodeElement.dataset.id = node.id;
        nodeElement.dataset.nodetype = node.type; // Tip bilgisini veri özniteliği olarak sakla
        
        // Düğüm tipine göre stil ekle
        if (node.id.startsWith('A')) {
            nodeElement.classList.add('term-type');
        } else if (node.id.startsWith('F')) {
            nodeElement.classList.add('final-type');
        } else if (node.type === 'Soru' || node.type.includes('Soru') || isQuestionType(node.type)) {
            nodeElement.classList.add('question-type');
        } else if (node.type === 'Rubrik' || node.type.includes('Rubrik') || isRubricType(node.type)) {
            nodeElement.classList.add('rubric-type');
        } else if (node.type === 'Test') {
            nodeElement.classList.add('question-type');
        }
        
        if (APP_STATE.selectedNode && APP_STATE.selectedNode.id === node.id) {
            nodeElement.classList.add('selected');
        }
        
        // Düğüm tipine göre seçenekler oluştur
        let typeOptions = generateTypeOptions(node);
        
        // Soru veya Rubrik için ağırlık alanını readonly yapmak
        const isSubItem = node.id.includes('.');
        const isQuestionOrRubric = node.type === 'Soru' || node.type.includes('Soru') || isQuestionType(node.type) || 
                               node.type === 'Rubrik' || node.type.includes('Rubrik') || isRubricType(node.type) ||
                               node.type === 'Test';
        
        const isWeightReadonly = isSubItem && isQuestionOrRubric;
        
        // Düğüm HTML içeriği oluştur
        nodeElement.innerHTML = `
            <div class="toggle">${node.children && node.children.length > 0 ? (node.expanded ? '▼' : '▶') : '•'}</div>
            <div class="node-checkbox">
                <input type="checkbox" class="node-select-checkbox" data-node-id="${node.id}">
                <div class="node-id-display">${node.id}</div>
            </div>
            <div><textarea placeholder="Etkinlik adı" class="nodeName auto-resize">${node.name || ''}</textarea></div>
            <div>
                <select class="nodeType" data-current-type="${node.type}">
                    ${typeOptions}
                </select>
            </div>
            <div><input type="number" value="${node.weight || 0}" min="0" max="100" class="nodeWeight" ${isWeightReadonly ? 'readonly' : ''}></div>
            <div><input type="number" value="${node.points || 0}" min="0" class="nodePoints"></div>
            <div><textarea placeholder="ÖÇ.1,ÖÇ.2,..." class="nodeOutcomes auto-resize">${Array.isArray(node.outcomes) ? node.outcomes.join(',') : (node.outcomes || '')}</textarea></div>
            <div>
                ${(isQuestionOrRubric && isSubItem) ? `
                    <textarea placeholder="A:1,B:2,C:3" class="nodeGroupMapping auto-resize" data-node-id="${node.id}"></textarea>
                ` : (!isSubItem && (node.id.startsWith('A') || node.id.startsWith('F'))) ? `
                    <textarea class="componentGroupInfo auto-resize" readonly data-component-id="${node.id}" placeholder="Grup bilgisi..."></textarea>
                ` : ''}
            </div>
            <div>
                <textarea placeholder="Açıklama..." class="nodeDescription auto-resize">${node.description || ''}</textarea>
            </div>
            <div class="actions-column">
                <div class="button-group">
                    ${(isQuestionOrRubric && isSubItem) ? `
                        <button class="btn btn-warning btn-small btn-group-mapping ${getGroupMappingStatusClass(node.id)}" data-node-id="${node.id}" title="Grup Haritalama Detayları - Modal Açar">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                            Grup Seç
                        </button>
                        <button class="btn btn-success btn-small btn-apply-group-mapping" data-node-id="${node.id}" title="Soldaki Grup Bilgisini Kaydet">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            Grup Kaydet
                        </button>
                    ` : ''}
                    ${(!isSubItem && (node.id.startsWith('A') || node.id.startsWith('F'))) ? `
                        <button class="btn btn-warning btn-small btn-manage-component-groups" data-component-id="${node.id}" title="Bu bileşenin gruplarını ekle/çıkar">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                                <circle cx="9" cy="7" r="4"/>
                                <path d="m22 21-3-3m0 0-3-3m3 3 3-3m-3 3-3 3"/>
                            </svg>
                            Grup Ekle/Çıkar
                        </button>
                        <button class="btn btn-info btn-small btn-move-up tooltip" data-node-id="${node.id}" data-tooltip="Bu etkinliği yukarı taşı" title="Bu etkinliği yukarı taşı">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="18 15 12 9 6 15"></polyline>
                            </svg>
                            ↑
                        </button>
                        <button class="btn btn-info btn-small btn-move-down tooltip" data-node-id="${node.id}" data-tooltip="Bu etkinliği aşağı taşı" title="Bu etkinliği aşağı taşı">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                            ↓
                        </button>
                    ` : ''}
                    <button class="btn btn-secondary btn-small btn-edit-outcomes" data-node-id="${node.id}" title="Öğrenme Çıktılarını Seç ve Düzenle">
                        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                        ÖÇ Seç
                    </button>
                    <button class="btn btn-danger btn-small btn-delete-node" data-node-id="${node.id}" title="Bu öğeyi sil">
                        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                        Sil
                </button>
                </div>
            </div>
        `;
        
        // Düğüme olay dinleyicileri ekle
        nodeElement.addEventListener('click', (e) => {
            if (!e.target.closest('input') && !e.target.closest('select') && !e.target.closest('textarea') && !e.target.closest('button')) {
                selectNode(node);
            }
        });
        
        const toggle = nodeElement.querySelector('.toggle');
        toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            node.expanded = !node.expanded;
            renderTree();
        });
        
        // Silme butonu için olay dinleyicisi
        const deleteButton = nodeElement.querySelector('.btn-delete-node');
        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteNode(node.id);
        });
        
        // Grup haritalama butonu için olay dinleyicisi
        const groupMappingButton = nodeElement.querySelector('.btn-group-mapping');
        if (groupMappingButton) {
            groupMappingButton.addEventListener('click', (e) => {
                e.stopPropagation();
                showGroupMappingModal(node.id);
            });
        }
        
        // ÖÇ düzenleme butonu için olay dinleyicisi
        const editOutcomesButton = nodeElement.querySelector('.btn-edit-outcomes');
        if (editOutcomesButton) {
            editOutcomesButton.addEventListener('click', (e) => {
                e.stopPropagation();
                showOutcomesEditModal(node.id);
            });
        }
        

        
        // Bileşen gruplarını yönetme butonu için olay dinleyicisi
        const manageComponentGroupsButton = nodeElement.querySelector('.btn-manage-component-groups');
        if (manageComponentGroupsButton) {
            manageComponentGroupsButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const componentId = e.target.closest('button').dataset.componentId;
                showComponentGroupManagementModal(componentId);
            });
        }
        
        // Yukarı taşıma butonu için olay dinleyicisi
        const moveUpButton = nodeElement.querySelector('.btn-move-up');
        if (moveUpButton) {
            moveUpButton.addEventListener('click', (e) => {
                e.stopPropagation();
                moveActivityUp(node.id);
            });
        }
        
        // Aşağı taşıma butonu için olay dinleyicisi
        const moveDownButton = nodeElement.querySelector('.btn-move-down');
        if (moveDownButton) {
            moveDownButton.addEventListener('click', (e) => {
                e.stopPropagation();
                moveActivityDown(node.id);
            });
        }
        
        // Input değerlerini güncelleme
        const nameInput = nodeElement.querySelector('.nodeName');
        nameInput.addEventListener('change', () => {
            node.name = nameInput.value;
            // Değerlendirme sekmesini güncelle
            updateAssessmentView();
        });
        
        const typeSelect = nodeElement.querySelector('.nodeType');
        typeSelect.addEventListener('change', () => {
            const oldType = node.type;
            const newType = typeSelect.value;
            
            // Tip değişimini kaydet
            node.type = newType;
            
            // Değerlendirme sekmesini güncelle
            updateAssessmentView();
            
            // Soru ve Rubrik ana tipleri arasındaki geçişleri özel ele al
            const isMainTypeChange = (
                (isQuestionMainType(oldType) && (newType === 'Rubrik' || isRubricType(newType))) ||
                ((oldType === 'Rubrik' || isRubricType(oldType)) && isQuestionMainType(newType))
            );
            
            // Eğer ana tür değişimi varsa tüm ağacı yeniden render et
            if (isMainTypeChange) {
                renderTree();
            } else {
                // Alt türler arası geçişlerde sadece ilgili sınıfları güncelle
                updateNodeClassesAfterTypeChange(nodeElement, oldType, newType);
            }
        });
        
        const weightInput = nodeElement.querySelector('.nodeWeight');
        weightInput.addEventListener('change', () => {
            if (!isWeightReadonly) {
                node.weight = parseInt(weightInput.value) || 0;
                updateCategoryWeights();
                // Değerlendirme sekmesini güncelle
                updateAssessmentView();
            }
        });
        
        const pointsInput = nodeElement.querySelector('.nodePoints');
        pointsInput.addEventListener('change', () => {
            // Ana bileşen ise (level 0) ve alt öğeleri varsa, manuel değişikliği engelle
            if (level === 0 && node.children && node.children.length > 0) {
                // Eski değeri geri yükle
                pointsInput.value = node.points;
                showModernToast("Ana bileşenin puanı alt öğelerin toplamına göre otomatik hesaplanır!", "warning");
                return;
            }
            
            node.points = parseInt(pointsInput.value) || 0;
            
            // Eğer bu bir soru/rubrik alt öğesi ise, ağırlığı otomatik hesapla
            if (isSubItem && isQuestionOrRubric) {
                updateSubItemWeight(node);
            }
            
            // Değerlendirme sekmesini güncelle
            updateAssessmentView();
        });
        
        const outcomesInput = nodeElement.querySelector('.nodeOutcomes');
        outcomesInput.addEventListener('change', () => {
            updateOutcomes(node, outcomesInput);
            // Değerlendirme sekmesini güncelle
            updateAssessmentView();
        });
        
        const descriptionInput = nodeElement.querySelector('.nodeDescription');
        descriptionInput.addEventListener('change', () => {
            node.description = descriptionInput.value;
            // Değerlendirme sekmesini güncelle
            updateAssessmentView();
        });
        
        // Ana ekran hızlı grup girişi event listener'ları
        const groupMappingInput = nodeElement.querySelector('.nodeGroupMapping');
        if (groupMappingInput) {
            // Input'u mevcut haritalama ile doldur
            const mappingText = getCurrentMappingText(node.id);
            groupMappingInput.value = mappingText;
            
            // Auto-resize for group mapping input
            setupAutoResize(groupMappingInput);
            
            // Enter tuşu ile de uygulayabilsin
            groupMappingInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    applyInlineGroupMapping(node.id);
                }
            });
        }
        
        const applyGroupMappingBtn = nodeElement.querySelector('.btn-apply-group-mapping');
        if (applyGroupMappingBtn) {
            applyGroupMappingBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                applyInlineGroupMapping(node.id);
            });
        }
        
        // Setup auto-resize for all auto-resize inputs
        const autoResizeInputs = nodeElement.querySelectorAll('.auto-resize');
        autoResizeInputs.forEach(input => {
            setupAutoResize(input);
        });
        
        // GUID sistemi kaldırıldı - temizlendi
        
        // Bileşen grup bilgisini güncelle (sadece ana bileşenler için)
        const componentGroupInfo = nodeElement.querySelector('.componentGroupInfo');
        if (componentGroupInfo) {
            updateComponentGroupInfo(node.id);
        }
        
        // Düğümü parent'a ekle
        parentElement.appendChild(nodeElement);
        
        // Alt düğümleri render et
        if (node.children && node.children.length > 0 && node.expanded) {
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'node-children';
            parentElement.appendChild(childrenContainer);
            
            node.children.forEach(child => {
                renderNode(child, childrenContainer, level + 1);
            });
        }
    } catch (error) {
        console.error("Düğüm render edilirken hata oluştu:", error);
        showModernToast("Değerlendirme bileşenleri görüntülenirken hata oluştu!", "error");
    }
}

/**
 * Alt öğelerin (soru/rubrik) ağırlığını otomatik hesaplama
 * @param {Object} node - Ağırlığı hesaplanacak düğüm
 */
function updateSubItemWeight(node) {
    try {
        // Üst düğümü bul
        const parentId = node.id.substring(0, node.id.lastIndexOf('.'));
        const parentNode = findNodeById(parentId);
        
        if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
            return;
        }
        
        // Toplam puan hesapla
        const totalPoints = parentNode.children.reduce((sum, child) => sum + (parseInt(child.points) || 0), 0);
        
        // Her çocuk için ağırlık hesapla
        if (totalPoints > 0) {
            parentNode.children.forEach(child => {
                const childPoints = parseInt(child.points) || 0;
                child.weight = Math.round((childPoints / totalPoints) * 100);
                
                // DOM'da ağırlık alanını güncelle
                const weightInput = document.querySelector(`.tree-node[data-id="${child.id}"] .nodeWeight`);
                if (weightInput) {
                    weightInput.value = child.weight;
                }
            });
        }
        
        // Ana bileşenin toplam puanını güncelle
        updateComponentTotalPoints(parentNode);
        
        // Kategori ağırlıklarını güncelle
        updateCategoryWeights();
    } catch (error) {
        console.error("Alt öğe ağırlığı hesaplanırken hata oluştu:", error);
    }
}

// GUID sistemi kaldırıldı

/**
 * Panoya kopyalama fonksiyonu
 * @param {string} text - Kopyalanacak metin
 */
function copyToClipboard(text) {
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
            console.log(`📋 Panoya kopyalandı: ${text}`);
            if (typeof showModernToast === 'function') {
                showModernToast(`📋 Kopyalandı: ${text}`, 'success');
            }
        }).catch(err => {
            console.error('❌ Kopyalama hatası:', err);
            if (typeof showModernToast === 'function') {
                showModernToast('❌ Kopyalanamadı!', 'error');
            }
        });
    } else {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            console.log(`📋 Panoya kopyalandı (fallback): ${text}`);
            if (typeof showModernToast === 'function') {
                showModernToast(`📋 Kopyalandı: ${text}`, 'success');
            }
        } catch (err) {
            console.error('❌ Kopyalama hatası (fallback):', err);
            if (typeof showModernToast === 'function') {
                showModernToast('❌ Kopyalanamadı!', 'error');
            }
        }
        document.body.removeChild(textArea);
    }
}

/**
 * Ana bileşenin toplam puanını hesaplama ve görüntüleme
 * @param {Object} node - Ana bileşen düğümü
 */
function updateComponentTotalPoints(node) {
    try {
        if (!node.children || node.children.length === 0) {
            return;
        }
        
        // Toplam puanı hesapla (tüm alt öğelerin puanlarının toplamı)
        const totalPoints = node.children.reduce((sum, child) => {
            return sum + calculateNodeTotalPoints(child);
        }, 0);
        
        // Ana bileşenin kendi puanını güncelle
        node.points = totalPoints;
        
        // DOM'da puan input'unu güncelle
        const nodeElement = document.querySelector(`.tree-node[data-id="${node.id}"]`);
        if (nodeElement) {
            const pointsInput = nodeElement.querySelector('.nodePoints');
            if (pointsInput) {
                pointsInput.value = totalPoints;
                
                // Input'u renklendirme
                const isStandard = totalPoints === 100;
                pointsInput.classList.remove('standard-points', 'high-points', 'low-points');
                
                                 if (isStandard) {
                     pointsInput.classList.add('standard-points');
                     pointsInput.title = 'Standart 100 puan (Alt öğelerin toplamı)';
                 } else if (totalPoints > 100) {
                     pointsInput.classList.add('high-points');
                     pointsInput.title = `Standart üzeri: ${totalPoints} puan (Alt öğelerin toplamı)`;
                 } else {
                     pointsInput.classList.add('low-points');
                     pointsInput.title = `Standart altı: ${totalPoints} puan (Alt öğelerin toplamı)`;
                 }
                 
                 // Ana bileşen input'una readonly özelliği ekle
                 pointsInput.readOnly = true;
                 pointsInput.style.cursor = 'not-allowed';
            }
            
            // GUID sistemi kaldırıldı
            
            // Eski toplam puan gösterimini kaldır (artık input'ta gösteriliyor)
            const totalPointsDisplay = nodeElement.querySelector('.total-points-display');
            if (totalPointsDisplay) {
                totalPointsDisplay.remove();
            }
        }
        
        console.log(`Bileşen ${node.id} toplam puanı güncellendi: ${totalPoints}`);
        
    } catch (error) {
        console.error("Bileşen toplam puanı hesaplanırken hata:", error);
    }
}

/**
 * Bir düğümün toplam puanını hesaplama (kendisi + alt düğümler)
 * @param {Object} node - Düğüm
 * @returns {number} - Toplam puan
 */
function calculateNodeTotalPoints(node) {
    let totalPoints = parseInt(node.points) || 0;
    
    if (node.children && node.children.length > 0) {
        totalPoints += node.children.reduce((sum, child) => {
            return sum + calculateNodeTotalPoints(child);
        }, 0);
    }
    
    return totalPoints;
}

/**
 * Düğüme soru ekleme
 * @param {Object} parentNode - Üst düğüm
 * @param {string} questionType - Soru tipi
 * @param {string} description - Açıklama
 */
function addQuestionToNode(parentNode, questionType = 'Soru', description = '') {
    if (!parentNode) return;
    
    try {
        if (!parentNode.children) {
            parentNode.children = [];
        }
        
        const childCount = parentNode.children.length;
        const newId = `${parentNode.id}.${childCount + 1}`;
        
        // Öğrenme çıktıları varsa ilk öğrenme çıktısını atayalım
        const outcome = parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : [];
        
        // Varsayılan puanı 3 olarak ayarla (önceki 20 yerine)
        const defaultPoints = 3;
        
        const newNode = {
            id: newId,
            name: `${questionType}`,
            type: questionType,
            weight: 0, // Ağırlık otomatik hesaplanacak
            points: defaultPoints, // Varsayılan puan 3
            outcomes: outcome,
            description: description || 'Değerlendirme sorusu',
            expanded: true,
            children: []
        };
        
        parentNode.children.push(newNode);
        parentNode.expanded = true;
        
        // Ağırlığı hesapla
        updateSubItemWeight(newNode);
        
        selectNode(newNode);
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
        
        // Yeni eklenen bileşen için otomatik mapping ataması
        assignDefaultMappingToNewComponent(parentNode.id, newNode);
        
        showModernToast(`"${questionType}" sorusu eklendi.`);
        
        // YENİ KOD: Ağırlıkları yeniden değerlendir
        checkAndOfferRedistribution(parentNode);
        
    } catch (error) {
        console.error("Soru eklenirken hata oluştu:", error);
        showModernToast("Soru eklenemedi!", "error");
    }
}

/**
 * Düğüme rubrik ekleme
 * @param {Object} parentNode - Üst düğüm
 * @param {string} rubricType - Rubrik tipi
 * @param {string} description - Açıklama
 */
function addRubricToNode(parentNode, rubricType = 'Rubrik', description = '') {
    if (!parentNode) return;
    
    try {
        if (!parentNode.children) {
            parentNode.children = [];
        }
        
        const childCount = parentNode.children.length;
        const newId = `${parentNode.id}.${childCount + 1}`;
        
        // Öğrenme çıktıları varsa ilk öğrenme çıktısını atayalım
        const outcome = parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : [];
        
        // Varsayılan puanı 3 olarak ayarla (önceki 20 yerine)
        const defaultPoints = 3;
        
        const newNode = {
            id: newId,
            name: `${rubricType}`,
            type: 'Rubrik',
            weight: 0, // Ağırlık otomatik hesaplanacak
            points: defaultPoints, // Varsayılan puan 3
            outcomes: outcome,
            description: description || 'Değerlendirme kriteri',
            expanded: true,
            children: []
        };
        
        parentNode.children.push(newNode);
        parentNode.expanded = true;
        
        // Ağırlığı hesapla
        updateSubItemWeight(newNode);
        
        selectNode(newNode);
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
        
        // Yeni eklenen bileşen için otomatik mapping ataması
        assignDefaultMappingToNewComponent(parentNode.id, newNode);
        
        showModernToast(`"${rubricType}" rubriği eklendi.`);
        
        // YENİ KOD: Ağırlıkları yeniden değerlendir
        checkAndOfferRedistribution(parentNode);
        
    } catch (error) {
        console.error("Rubrik eklenirken hata oluştu:", error);
        showModernToast("Rubrik eklenemedi!", "error");
    }
}

/**
 * Çoklu öğe ekleme
 */
// İlk addMultipleItems fonksiyonu kaldırıldı - gelişmiş versiyon korundu

/**
 * Soru tipine ait bir tür olup olmadığını kontrol eder
 * @param {string} type - Kontrol edilecek tip
 * @returns {boolean} - Soru tipine ait ise true
 */
function isQuestionType(type) {
    // Direkt 'Soru' ana tipi ise
    if (type === 'Soru') return true;
    
    // Soru içeriyorsa (örn. "Açık Uçlu Soru")
    if (type.includes('Soru')) return true;
    
    // Soru türleri listesinde var mı kontrol et
    const questionTypes = Array.from(document.querySelectorAll('.question-type-item'))
        .map(item => item.getAttribute('data-type'));
    
    return questionTypes.includes(type);
}

/**
 * Rubrik tipine ait bir tür olup olmadığını kontrol eder
 * @param {string} type - Kontrol edilecek tip
 * @returns {boolean} - Rubrik tipine ait ise true
 */
function isRubricType(type) {
    // Direkt 'Rubrik' ana tipi ise
    if (type === 'Rubrik') return true;
    
    // Rubrik türleri listesinde var mı kontrol et
    const rubricTypes = Array.from(document.querySelectorAll('.rubric-item'))
        .map(item => item.getAttribute('data-type'));
    
    return rubricTypes.includes(type);
}

/**
 * Ana Soru tiplerinden biri olup olmadığını kontrol eder
 * @param {string} type - Kontrol edilecek tip
 * @returns {boolean} - Ana soru tiplerinden biri ise true
 */
function isQuestionMainType(type) {
    return type === 'Soru' || type.includes('Soru') || isQuestionType(type);
}

/**
 * Tipe göre dropdown seçeneklerini oluşturur
 * @param {Object} node - Dropdown seçenekleri oluşturulacak düğüm
 * @returns {string} - Dropdown option HTML içeriği
 */
function generateTypeOptions(node) {
    let typeOptions = '';
    
    // Kök düğümler için (Ana etkinlikler)
    if (!node.id.includes('.')) {
        // Yarıyıl içi etkinlikler
        if (node.id.startsWith('A')) {
            typeOptions = ACTIVITY_TYPES.term.map(type => 
                `<option value="${type}" ${node.type === type ? 'selected' : ''}>${type}</option>`
            ).join('');
        } 
        // Yarıyıl sonu etkinlikler
        else if (node.id.startsWith('F')) {
            typeOptions = ACTIVITY_TYPES.final.map(type => 
                `<option value="${type}" ${node.type === type ? 'selected' : ''}>${type}</option>`
            ).join('');
        }
    } 
    // Alt düğümler için (Sorular, rubrikler vb.)
    else {
        // Test tipi için sadece Test seçeneği
        if (node.type === 'Test') {
            typeOptions = `<option value="Test" selected>Test Soruları (Toplu)</option>`;
        }
        // Soru tipi ve türevleri için
        else if (node.type === 'Soru' || node.type.includes('Soru') || isQuestionType(node.type)) {
            // Önce ana 'Soru' seçeneği
            typeOptions = `<option value="Soru" ${node.type === 'Soru' ? 'selected' : ''}>Soru</option>`;
            
            // Sonra diğer soru türleri
            const questionTypes = Array.from(document.querySelectorAll('.question-type-item'))
                .map(item => item.getAttribute('data-type'))
                .filter(type => type !== 'Test'); // Test türünü hariç tut
                
            questionTypes.forEach(type => {
                typeOptions += `<option value="${type}" ${node.type === type ? 'selected' : ''}>${type}</option>`;
            });
        } 
        // Rubrik tipi ve türevleri için
        else {
            // Önce ana 'Rubrik' seçeneği
            typeOptions = `<option value="Rubrik" ${node.type === 'Rubrik' ? 'selected' : ''}>Rubrik</option>`;
            
            // Sonra diğer rubrik türleri
            const rubricTypes = Array.from(document.querySelectorAll('.rubric-item'))
                .map(item => item.getAttribute('data-type'));
                
            rubricTypes.forEach(type => {
                typeOptions += `<option value="${type}" ${node.type === type ? 'selected' : ''}>${type}</option>`;
            });
        }
    }
    
    return typeOptions;
}

/**
 * Tip değişikliğinden sonra node sınıflarını günceller
 * @param {HTMLElement} nodeElement - Düğüm elementi
 * @param {string} oldType - Eski tip
 * @param {string} newType - Yeni tip
 */
function updateNodeClassesAfterTypeChange(nodeElement, oldType, newType) {
    // Eski tip sınıflarını kaldır
    if (isQuestionType(oldType)) {
        nodeElement.classList.remove('question-type');
    } else if (isRubricType(oldType)) {
        nodeElement.classList.remove('rubric-type');
    }
    
    // Yeni tip sınıflarını ekle
    if (isQuestionType(newType)) {
        nodeElement.classList.add('question-type');
    } else if (isRubricType(newType)) {
        nodeElement.classList.add('rubric-type');
    }
    
    // Tip bilgisini veri özniteliğinde güncelle
    nodeElement.dataset.nodetype = newType;
}
/**
 * Ağacı render etme
 */
/**
 * Ağacı render etme
 */
function renderTree() {
    try {
        treeContainer.innerHTML = '';
        
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'tree-empty-message';
            emptyMessage.textContent = 'Henüz değerlendirme bileşeni eklenmedi. Ders JSON yükleyin veya yeni bileşenler ekleyin.';
            treeContainer.appendChild(emptyMessage);
            return;
        }

        // Yarıyıl içi bölümü oluştur
        const termSection = document.createElement('div');
        termSection.className = 'tree-section term-section';
        
        // Yarıyıl içi başlık
        const termHeader = document.createElement('div');
        termHeader.className = 'tree-section-header';
        termHeader.innerHTML = `
            <h3>Yarıyıl İçi Değerlendirme Bileşenleri</h3>
            <div class="tree-section-controls">
                <div class="select-all-checkbox">
                    <input type="checkbox" id="selectAllTerm">
                    <label for="selectAllTerm">Hepsini Seç</label>
                </div>
                <div class="bulk-action-buttons">
                    <div class="tooltip">
                        <button class="btn-bulk btn-copy" id="bulkCopyTerm" disabled>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Kopyala
                        </button>
                        <span class="tooltiptext">Seçili bileşenlerin kopyasını oluşturup yarıyıl içi bölümünün sonuna ekler. Aynı yapıda yeni bileşenler oluşturur.</span>
                    </div>
                    <div class="tooltip">
                        <button class="btn-bulk btn-delete" id="bulkDeleteTerm" disabled>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                            Sil
                        </button>
                        <span class="tooltiptext">Seçili bileşenleri kalıcı olarak siler. Bu işlem geri alınamaz! Dikkatli kullanın.</span>
                    </div>
                </div>
            </div>
        `;
        termSection.appendChild(termHeader);
        
        // Yarıyıl içi düğümleri
        const termNodes = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
        
        if (termNodes.length === 0) {
            const emptyTerm = document.createElement('div');
            emptyTerm.className = 'tree-section-empty';
            emptyTerm.textContent = 'Henüz yarıyıl içi değerlendirme bileşeni eklenmedi.';
            termSection.appendChild(emptyTerm);
        } else {
            termNodes.forEach(node => {
                renderNode(node, termSection, 0);
                // Ana bileşen için toplam puan hesaplamasını tetikle
                if (node.children && node.children.length > 0) {
                    setTimeout(() => updateComponentTotalPoints(node), 100);
                }
            });
        }
        
        // Yarıyıl içi bölümü için ekleme butonu
        const termAddButton = document.createElement('div');
        termAddButton.className = 'add-node-button';
        termAddButton.innerHTML = `
            <button class="btn btn-add-node" data-section="term">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Yarıyıl İçi Etkinlik Ekle
            </button>
        `;
        termSection.appendChild(termAddButton);
        
        // Yarıyıl sonu bölümü oluştur
        const finalSection = document.createElement('div');
        finalSection.className = 'tree-section final-section';
        
        // Yarıyıl sonu başlık
        const finalHeader = document.createElement('div');
        finalHeader.className = 'tree-section-header';
        finalHeader.innerHTML = `
            <h3>Yarıyıl Sonu Değerlendirme Bileşenleri</h3>
            <div class="tree-section-controls">
                <div class="select-all-checkbox">
                    <input type="checkbox" id="selectAllFinal">
                    <label for="selectAllFinal">Hepsini Seç</label>
                </div>
                <div class="bulk-action-buttons">
                    <div class="tooltip">
                        <button class="btn-bulk btn-copy" id="bulkCopyFinal" disabled>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Kopyala
                        </button>
                        <span class="tooltiptext">Seçili bileşenlerin kopyasını oluşturup yarıyıl sonu bölümünün sonuna ekler. Aynı yapıda yeni bileşenler oluşturur.</span>
                    </div>
                    <div class="tooltip">
                        <button class="btn-bulk btn-delete" id="bulkDeleteFinal" disabled>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                            Sil
                        </button>
                        <span class="tooltiptext">Seçili bileşenleri kalıcı olarak siler. Bu işlem geri alınamaz! Dikkatli kullanın.</span>
                    </div>
                </div>
            </div>
        `;
        finalSection.appendChild(finalHeader);
        
        // Yarıyıl sonu düğümleri
        const finalNodes = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
        
        if (finalNodes.length === 0) {
            const emptyFinal = document.createElement('div');
            emptyFinal.className = 'tree-section-empty';
            emptyFinal.textContent = 'Henüz yarıyıl sonu değerlendirme bileşeni eklenmedi.';
            finalSection.appendChild(emptyFinal);
        } else {
            finalNodes.forEach(node => {
                renderNode(node, finalSection, 0);
                // Ana bileşen için toplam puan hesaplamasını tetikle
                if (node.children && node.children.length > 0) {
                    setTimeout(() => updateComponentTotalPoints(node), 100);
                }
            });
        }
        
        // Yarıyıl sonu bölümü için ekleme butonu
        const finalAddButton = document.createElement('div');
        finalAddButton.className = 'add-node-button';
        finalAddButton.innerHTML = `
            <button class="btn btn-add-node" data-section="final">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Yarıyıl Sonu Etkinlik Ekle
            </button>
        `;
        finalSection.appendChild(finalAddButton);
        
        // İlk önce yarıyıl içi, sonra yarıyıl sonu bölümlerini ekle
        treeContainer.appendChild(termSection);
        treeContainer.appendChild(finalSection);
        
        // Ekleme butonları için olay dinleyicileri
        document.querySelectorAll('.btn-add-node').forEach(button => {
            button.addEventListener('click', function() {
                const section = this.getAttribute('data-section');
                if (section === 'term') {
                    addTermActivity();
                } else if (section === 'final') {
                    addFinalActivity();
                }
            });
        });

        // Toplu işlem olay dinleyicileri
        setupBulkActionListeners();
        
        // Ağırlıkları güncelle
        updateCategoryWeights();
        
        // Grup haritalama UI'larını güncelle - v5 format için zorlamalı güncelleme
        setTimeout(() => {
            console.log("🔄 Grup UI güncellemesi başlıyor...");
            console.log("📊 Mevcut grup haritalama verileri:", APP_STATE.courseData?.grupHaritalari);
            updateGroupMappingColors();
            updateAllInlineGroupInputs();
            console.log("✅ Grup UI güncellemesi tamamlandı");
        }, 100);
        
        // Ek güncelleme - bazen ilk seferde yakalanmıyor
        setTimeout(() => {
            console.log("🔄 İkinci grup UI güncellemesi...");
            updateAllInlineGroupInputs();
            
            // Her bileşen için grup bilgilerini kontrol et
            Object.keys(APP_STATE.courseData?.grupHaritalari || {}).forEach(componentId => {
                console.log(`🔍 ${componentId} için grup bilgisi kontrolü...`);
                updateComponentGroupInfo(componentId);
            });
        }, 500);
        
        // Sürükle-bırak özelliğini etkinleştir
        setTimeout(() => {
            enableDragAndDrop();
        }, 200);
        
            console.log('🎯 renderTree tamamlandı');
    } catch (error) {
        console.error("Ağaç render edilirken hata oluştu:", error);
        showModernToast("Değerlendirme ağacı yüklenirken hata oluştu!", "error");
    }
}

/**
 * Toplu işlem olay dinleyicilerini kurma
 */
function setupBulkActionListeners() {
    // Yarıyıl içi kontrolleri
    const selectAllTerm = document.getElementById('selectAllTerm');
    const bulkCopyTerm = document.getElementById('bulkCopyTerm');
    const bulkDeleteTerm = document.getElementById('bulkDeleteTerm');
    
    // Yarıyıl sonu kontrolleri
    const selectAllFinal = document.getElementById('selectAllFinal');
    const bulkCopyFinal = document.getElementById('bulkCopyFinal');
    const bulkDeleteFinal = document.getElementById('bulkDeleteFinal');
    
    // Hepsini seç/seçimi kaldır - Yarıyıl İçi
    if (selectAllTerm) {
        selectAllTerm.addEventListener('change', (e) => {
            const termNodes = document.querySelectorAll('.term-section .node-select-checkbox');
            termNodes.forEach(checkbox => {
                checkbox.checked = e.target.checked;
            });
            updateBulkActionButtons('term');
        });
    }
    
    // Hepsini seç/seçimi kaldır - Yarıyıl Sonu
    if (selectAllFinal) {
        selectAllFinal.addEventListener('change', (e) => {
            const finalNodes = document.querySelectorAll('.final-section .node-select-checkbox');
            finalNodes.forEach(checkbox => {
                checkbox.checked = e.target.checked;
            });
            updateBulkActionButtons('final');
        });
    }
    
    // Bireysel checkbox değişiklikleri
    document.querySelectorAll('.node-select-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            e.stopPropagation();
            const section = e.target.closest('.term-section') ? 'term' : 'final';
            updateBulkActionButtons(section);
            updateSelectAllCheckbox(section);
        });
    });
    
    // Kopyalama butonları
    if (bulkCopyTerm) {
        bulkCopyTerm.addEventListener('click', () => {
            const selectedIds = getSelectedNodeIds('term');
            if (selectedIds.length > 0) {
                bulkCopyNodes(selectedIds, 'term');
            }
        });
    }
    
    if (bulkCopyFinal) {
        bulkCopyFinal.addEventListener('click', () => {
            const selectedIds = getSelectedNodeIds('final');
            if (selectedIds.length > 0) {
                bulkCopyNodes(selectedIds, 'final');
            }
        });
    }
    
    // Silme butonları
    if (bulkDeleteTerm) {
        bulkDeleteTerm.addEventListener('click', () => {
            const selectedIds = getSelectedNodeIds('term');
            if (selectedIds.length > 0) {
                bulkDeleteNodes(selectedIds, 'term');
            }
        });
    }
    
    if (bulkDeleteFinal) {
        bulkDeleteFinal.addEventListener('click', () => {
            const selectedIds = getSelectedNodeIds('final');
            if (selectedIds.length > 0) {
                bulkDeleteNodes(selectedIds, 'final');
            }
        });
    }
}

/**
 * Seçili düğüm ID'lerini al
 */
function getSelectedNodeIds(section) {
    const sectionClass = section === 'term' ? '.term-section' : '.final-section';
    const selectedCheckboxes = document.querySelectorAll(`${sectionClass} .node-select-checkbox:checked`);
    return Array.from(selectedCheckboxes).map(cb => cb.dataset.nodeId);
}

/**
 * Toplu işlem butonlarının durumunu güncelle
 */
function updateBulkActionButtons(section) {
    const selectedIds = getSelectedNodeIds(section);
    const copyBtn = document.getElementById(`bulkCopy${section.charAt(0).toUpperCase() + section.slice(1)}`);
    const deleteBtn = document.getElementById(`bulkDelete${section.charAt(0).toUpperCase() + section.slice(1)}`);
    
    if (copyBtn) copyBtn.disabled = selectedIds.length === 0;
    if (deleteBtn) deleteBtn.disabled = selectedIds.length === 0;
}

/**
 * Hepsini seç checkbox'ının durumunu güncelle
 */
function updateSelectAllCheckbox(section) {
    const sectionClass = section === 'term' ? '.term-section' : '.final-section';
    const allCheckboxes = document.querySelectorAll(`${sectionClass} .node-select-checkbox`);
    const checkedCheckboxes = document.querySelectorAll(`${sectionClass} .node-select-checkbox:checked`);
    const selectAllCheckbox = document.getElementById(`selectAll${section.charAt(0).toUpperCase() + section.slice(1)}`);
    
    if (selectAllCheckbox && allCheckboxes.length > 0) {
        selectAllCheckbox.checked = checkedCheckboxes.length === allCheckboxes.length;
        selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < allCheckboxes.length;
    }
}

/**
 * Seçili düğümleri kopyala
 */
function bulkCopyNodes(nodeIds, section) {
    // Seçili bileşenleri ana etkinlik ve alt bileşen olarak ayır
    const mainActivities = [];
    const subComponents = [];
    
    nodeIds.forEach(nodeId => {
        const node = findNodeById(nodeId);
        if (node) {
            const isMainActivity = !nodeId.includes('.');
            const componentInfo = {
                id: nodeId,
                name: node.name || node.type || 'İsimsiz',
                type: node.type || 'Bilinmeyen',
                node: node
            };
            
            if (isMainActivity) {
                mainActivities.push(componentInfo);
            } else {
                subComponents.push(componentInfo);
            }
        }
    });
    
    // Mesajı oluştur
    let message = `${nodeIds.length} adet seçili bileşenin kopyasını oluşturmak istediğinizden emin misiniz?\n\n`;
    
    if (mainActivities.length > 0) {
        message += `📋 Ana Etkinlikler (${mainActivities.length} adet):\n`;
        mainActivities.slice(0, 5).forEach((comp, index) => {
            message += `${index + 1}. ${comp.id} - ${comp.name}\n`;
        });
        if (mainActivities.length > 5) {
            message += `... ve ${mainActivities.length - 5} tane daha\n`;
        }
        message += `→ Etkinliklerin sonuna eklenecek\n\n`;
    }
    
    if (subComponents.length > 0) {
        message += `🔧 Alt Bileşenler (${subComponents.length} adet):\n`;
        subComponents.slice(0, 5).forEach((comp, index) => {
            const parentId = comp.id.substring(0, comp.id.lastIndexOf('.'));
            message += `${index + 1}. ${comp.id} - ${comp.name} (${parentId} içine)\n`;
        });
        if (subComponents.length > 5) {
            message += `... ve ${subComponents.length - 5} tane daha\n`;
        }
        message += `→ Kendi ana etkinliklerinin sonuna eklenecek\n\n`;
    }
    
    showModernConfirm(
        'Seçili Bileşenleri Kopyala',
        message,
        {
            confirmText: 'Evet, Kopyala',
            cancelText: 'İptal',
            headerClass: 'info-action',
            iconClass: 'info'
        }
    ).then(confirmed => {
        if (confirmed) {
            try {
                let copiedCount = 0;
                
                // Ana etkinlikleri kopyala (etkinliklerin sonuna)
                mainActivities.forEach(comp => {
                    const copiedNode = deepCopyNode(comp.node, section);
                    APP_STATE.assessmentTree.push(copiedNode);
                    
                    // Orijinal etkinliğin grup haritalamalarını kopyala
                    copyGroupMappingsForActivity(comp.node.id, copiedNode.id);
                    
                    copiedCount++;
                });
                
                // Alt bileşenleri kopyala (kendi parent'larının sonuna)
                subComponents.forEach(comp => {
                    const parentId = comp.id.substring(0, comp.id.lastIndexOf('.'));
                    const parentNode = findNodeById(parentId);
                    
                    if (parentNode) {
                        const copiedSubComponent = deepCopySubComponent(comp.node, parentNode);
                        if (!parentNode.children) {
                            parentNode.children = [];
                        }
                        parentNode.children.push(copiedSubComponent);
                        
                        // Parent'ın grup haritalamalarına yeni alt bileşeni ekle
                        addSubComponentToGroupMappings(parentNode.id, copiedSubComponent.id);
                        
                        copiedCount++;
                    }
                });
                
                // Tüm ID'leri yeniden düzenle
                const oldToNewIdMap = reorganizeAllIds();
                
                // Grup haritalamalarını yeni ID'lerle güncelle
                updateGroupMappingsAfterIdChange(oldToNewIdMap);
                
                renderTree();
                updateCategoryWeights();
                updateAssessmentView();
                
                // Öğrenci grup bilgilerini güncelle
                updateStudentGroupInfoDisplay();
                
                showModernToast(`${copiedCount} adet bileşen başarıyla kopyalandı!`, "success");
                
                // Seçimleri temizle
                clearSelections(section);
                
            } catch (error) {
                console.error("Toplu kopyalama hatası:", error);
                showModernToast("Kopyalama işlemi sırasında hata oluştu!", "error");
            }
        }
    });
}

/**
 * Seçili düğümleri sil
 */
function bulkDeleteNodes(nodeIds, section) {
    // Seçili bileşenlerin bilgilerini topla
    const selectedComponents = nodeIds.map(nodeId => {
        const node = findNodeById(nodeId);
        return node ? {
            id: nodeId,
            name: node.name || node.type || 'İsimsiz',
            type: node.type || 'Bilinmeyen'
        } : null;
    }).filter(Boolean);
    
    // Mesajı oluştur
    let message = `${selectedComponents.length} adet seçili bileşeni kalıcı olarak silmek istediğinizden emin misiniz?\n\n`;
    
    // Eğer 10'dan az bileşen varsa hepsini listele
    if (selectedComponents.length <= 10) {
        message += "Silinecek bileşenler:\n";
        selectedComponents.forEach((comp, index) => {
            message += `${index + 1}. ${comp.id} - ${comp.name} (${comp.type})\n`;
        });
    } else {
        // 10'dan fazla varsa ilk 8'ini göster, sonra "..." ekle
        message += "Silinecek bileşenler (ilk 8 tanesi):\n";
        selectedComponents.slice(0, 8).forEach((comp, index) => {
            message += `${index + 1}. ${comp.id} - ${comp.name} (${comp.type})\n`;
        });
        message += `... ve ${selectedComponents.length - 8} tane daha\n`;
    }
    
    message += "\n⚠️ Bu işlem geri alınamaz!";
    
    showModernConfirm(
        'Seçili Bileşenleri Sil',
        message,
        {
            confirmText: 'Evet, Sil',
            cancelText: 'İptal',
            headerClass: 'danger-action',
            iconClass: 'danger'
        }
    ).then(confirmed => {
        if (confirmed) {
            try {
                let deletedCount = 0;
                
                // Silme işlemini ters sırada yap (alt düğümlerden başlayarak)
                nodeIds.reverse().forEach(nodeId => {
                    if (deleteNodeSilently(nodeId)) {
                        deletedCount++;
                    }
                });
                
                // Tüm ID'leri yeniden düzenle
                reorganizeAllIds();
                
                renderTree();
                updateCategoryWeights();
                updateAssessmentView();
                
                // Öğrenci grup bilgilerini güncelle
                updateStudentGroupInfoDisplay();
                
                showModernToast(`${deletedCount} adet bileşen başarıyla silindi!`, "success");
                
                // Seçimleri temizle
                clearSelections(section);
                
            } catch (error) {
                console.error("Toplu silme hatası:", error);
                showModernToast("Silme işlemi sırasında hata oluştu!", "error");
            }
        }
    });
}

/**
 * Düğüm kopyalama (derin kopya) - Ana etkinlikler için
 */
function deepCopyNode(node, targetSection) {
    const prefix = targetSection === 'term' ? 'A' : 'F';
    const existingNodes = APP_STATE.assessmentTree.filter(n => n.id.startsWith(prefix));
    const newIndex = existingNodes.length + 1;
    const newId = `${prefix}${newIndex}`;
    
    const copiedNode = {
        id: newId,
        name: `${node.name} (Kopya)`,
        type: node.type,
        weight: node.weight || 0,
        points: node.points || 0,
        outcomes: Array.isArray(node.outcomes) ? [...node.outcomes] : node.outcomes,
        description: node.description || '',
        expanded: node.expanded || false,
        children: []
    };
    
    // Alt düğümleri de kopyala
    if (node.children && node.children.length > 0) {
        node.children.forEach((child, index) => {
            const childCopy = {
                id: `${newId}.${index + 1}`,
                name: child.name,
                type: child.type,
                weight: child.weight || 0,
                points: child.points || 0,
                outcomes: Array.isArray(child.outcomes) ? [...child.outcomes] : child.outcomes,
                description: child.description || '',
                expanded: child.expanded || false,
                children: []
            };
            copiedNode.children.push(childCopy);
        });
    }
    
    return copiedNode;
}

/**
 * Alt bileşen kopyalama - Parent etkinliğin içine
 */
function deepCopySubComponent(subComponent, parentNode) {
    // Parent'ın mevcut alt bileşen sayısını al
    const existingChildrenCount = parentNode.children ? parentNode.children.length : 0;
    const newIndex = existingChildrenCount + 1;
    const newId = `${parentNode.id}.${newIndex}`;
    
    const copiedSubComponent = {
        id: newId,
        name: `${subComponent.name} (Kopya)`,
        type: subComponent.type,
        weight: subComponent.weight || 0,
        points: subComponent.points || 0,
        outcomes: Array.isArray(subComponent.outcomes) ? [...subComponent.outcomes] : subComponent.outcomes,
        description: subComponent.description || '',
        expanded: subComponent.expanded || false,
        children: []
    };
    
    // Eğer alt bileşenin de çocukları varsa onları da kopyala (deep copy)
    if (subComponent.children && subComponent.children.length > 0) {
        subComponent.children.forEach((child, index) => {
            const childCopy = {
                id: `${newId}.${index + 1}`,
                name: child.name,
                type: child.type,
                weight: child.weight || 0,
                points: child.points || 0,
                outcomes: Array.isArray(child.outcomes) ? [...child.outcomes] : child.outcomes,
                description: child.description || '',
                expanded: child.expanded || false,
                children: []
            };
            copiedSubComponent.children.push(childCopy);
        });
    }
    
    return copiedSubComponent;
}

/**
 * Etkinlik grup haritalamalarını kopyala
 * @param {string} sourceActivityId - Kaynak etkinlik ID'si
 * @param {string} targetActivityId - Hedef etkinlik ID'si
 */
function copyGroupMappingsForActivity(sourceActivityId, targetActivityId) {
    if (!APP_STATE.courseData?.grupHaritalari) {
        APP_STATE.courseData.grupHaritalari = {};
    }
    
    const sourceMapping = APP_STATE.courseData.grupHaritalari[sourceActivityId];
    
    if (sourceMapping) {
        // Kaynak haritalamayı derin kopya ile kopyala
        const targetMapping = JSON.parse(JSON.stringify(sourceMapping));
        
        // Hedef etkinlik için haritalamayı kaydet
        APP_STATE.courseData.grupHaritalari[targetActivityId] = targetMapping;
        
        console.log(`✅ Grup haritalama kopyalandı: ${sourceActivityId} → ${targetActivityId}`);
    } else {
        // Kaynak haritalama yoksa varsayılan oluştur
        APP_STATE.courseData.grupHaritalari[targetActivityId] = {
            gruplar: ["A"],
            haritalar: {
                "A": {}
            }
        };
        
        console.log(`✅ Varsayılan grup haritalama oluşturuldu: ${targetActivityId}`);
    }
}

/**
 * Alt bileşeni parent'ın grup haritalamalarına ekle
 * @param {string} parentId - Parent etkinlik ID'si
 * @param {string} subComponentId - Alt bileşen ID'si
 */
function addSubComponentToGroupMappings(parentId, subComponentId) {
    if (!APP_STATE.courseData?.grupHaritalari?.[parentId]) {
        // Parent için grup haritalama yoksa oluştur
        APP_STATE.courseData.grupHaritalari[parentId] = {
            gruplar: ["A"],
            haritalar: {
                "A": {}
            }
        };
    }
    
    const parentMapping = APP_STATE.courseData.grupHaritalari[parentId];
    
    // Her grup için yeni alt bileşeni ekle
    parentMapping.gruplar.forEach(groupName => {
        if (!parentMapping.haritalar[groupName]) {
            parentMapping.haritalar[groupName] = {};
        }
        
        // Bu grupta kaç alt bileşen var, ona göre sıra numarası ver
        const existingMappings = parentMapping.haritalar[groupName];
        const nextPosition = Object.keys(existingMappings).length + 1;
        
        // Yeni alt bileşeni haritalamaya ekle
        parentMapping.haritalar[groupName][subComponentId] = nextPosition.toString();
        
                 console.log(`✅ Alt bileşen grup haritalamaya eklendi: ${subComponentId} → ${parentId} (Grup: ${groupName}, Sıra: ${nextPosition})`);
     });
}

/**
 * ID değişikliği sonrası grup haritalamalarını güncelle
 * @param {Object} oldToNewIdMap - Eski ID'den yeni ID'ye mapping
 */
function updateGroupMappingsAfterIdChange(oldToNewIdMap) {
    if (!APP_STATE.courseData?.grupHaritalari || !oldToNewIdMap) {
        return;
    }
    
    const updatedMappings = {};
    
    // Her etkinlik için grup haritalamalarını güncelle
    Object.keys(APP_STATE.courseData.grupHaritalari).forEach(activityId => {
        const newActivityId = oldToNewIdMap[activityId] || activityId;
        const activityMapping = APP_STATE.courseData.grupHaritalari[activityId];
        
        if (activityMapping && activityMapping.haritalar) {
            const updatedActivityMapping = {
                gruplar: [...activityMapping.gruplar],
                haritalar: {}
            };
            
            // Her grup için haritalamayı güncelle
            Object.keys(activityMapping.haritalar).forEach(groupName => {
                const groupMapping = activityMapping.haritalar[groupName];
                const updatedGroupMapping = {};
                
                // Her alt bileşen için ID'yi güncelle
                Object.keys(groupMapping).forEach(oldSubId => {
                    const newSubId = oldToNewIdMap[oldSubId] || oldSubId;
                    const position = groupMapping[oldSubId];
                    updatedGroupMapping[newSubId] = position;
                    
                    if (oldSubId !== newSubId) {
                        console.log(`🔄 Grup haritalama ID güncellendi: ${oldSubId} → ${newSubId} (Grup: ${groupName})`);
                    }
                });
                
                updatedActivityMapping.haritalar[groupName] = updatedGroupMapping;
            });
            
            updatedMappings[newActivityId] = updatedActivityMapping;
            
            if (activityId !== newActivityId) {
                console.log(`🔄 Etkinlik grup haritalama ID güncellendi: ${activityId} → ${newActivityId}`);
            }
        }
    });
    
    // Güncellenmiş haritalamayı kaydet
    APP_STATE.courseData.grupHaritalari = updatedMappings;
    
    console.log('✅ Tüm grup haritalamalar ID değişikliği sonrası güncellendi');
}

/**
 * Seçimleri temizle
 */
function clearSelections(section) {
    const sectionClass = section === 'term' ? '.term-section' : '.final-section';
    const checkboxes = document.querySelectorAll(`${sectionClass} .node-select-checkbox`);
    checkboxes.forEach(cb => cb.checked = false);
    
    const selectAllCheckbox = document.getElementById(`selectAll${section.charAt(0).toUpperCase() + section.slice(1)}`);
    if (selectAllCheckbox) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    }
    
    updateBulkActionButtons(section);
}

/**
 * Düğüm silme - sessiz silme (onay modalı olmadan)
 * @param {string} nodeId - Silinecek düğüm ID'si
 * @returns {boolean} - Silme başarılı mı
 */
function deleteNodeSilently(nodeId) {
    if (!nodeId) return false;
    
    try {
        // Düğümü bul
        const node = findNodeById(nodeId);
        if (!node) return false;
        
        // Seçili düğüm siliniyorsa seçimi kaldır
        if (APP_STATE.selectedNode && APP_STATE.selectedNode.id === nodeId) {
            APP_STATE.selectedNode = null;
        }
        
        // Kök düğüm mü kontrol et
        const isRoot = !nodeId.includes('.');
        
        if (isRoot) {
            // Kök düğümü sil
            const index = APP_STATE.assessmentTree.findIndex(node => node.id === nodeId);
            if (index !== -1) {
                APP_STATE.assessmentTree.splice(index, 1);
                return true;
            }
        } else {
            // Alt düğümü sil
            const parentId = nodeId.substring(0, nodeId.lastIndexOf('.'));
            const findParentAndRemoveChild = (nodes, id) => {
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    if (node.id === parentId && node.children) {
                        const childIndex = node.children.findIndex(child => child.id === id);
                        if (childIndex !== -1) {
                            node.children.splice(childIndex, 1);
                            return true;
                        }
                    }
                    
                    if (node.children && node.children.length > 0) {
                        if (findParentAndRemoveChild(node.children, id)) {
                            return true;
                        }
                    }
                }
                return false;
            };
            
            const deleted = findParentAndRemoveChild(APP_STATE.assessmentTree, nodeId);
            
            // Eğer alt düğüm silindiyse, üst düğümün ID'lerini yeniden sırala
            if (deleted) {
                const parentNode = findNodeById(parentId);
                if (parentNode) {
                    reorderChildNodeIds(parentNode);
                }
                
                // Değerlendirme sekmesini güncelle - CRITICAL SYNC  
                updateAssessmentView();
                
                // DÜZELTME: Silinen soru için grup haritalamalarını temizle
                // ÖNEMLİ: ID yeniden sıralama sonrası grup temizliği yap
                cleanupGroupMappingsForDeletedNode(nodeId);
            }
            
            return deleted;
        }
        
        return false;
        
    } catch (error) {
        console.error(`Düğüm ${nodeId} silinirken hata:`, error);
        return false;
    }
}

/**
 * Düğüm silme - ID'ye göre silme yapan versiyon
 * @param {string} nodeId - Silinecek düğüm ID'si
 */
function deleteNode(nodeId) {
    if (!nodeId) return;
    
    // Silme onayı iste
    const node = findNodeById(nodeId);
    if (!node) return;
    
    // Modern silme onay modalını göster
    showDeleteConfirmModal(
        // Onay verildiğinde çalışacak fonksiyon
        function() {
            try {
                // Seçili düğüm siliniyorsa seçimi kaldır
                if (APP_STATE.selectedNode && APP_STATE.selectedNode.id === nodeId) {
                    APP_STATE.selectedNode = null;
                }
                
                // Kök düğüm mü kontrol et
                const isRoot = !nodeId.includes('.');
                
                if (isRoot) {
                    // Kök düğümü sil
                    const index = APP_STATE.assessmentTree.findIndex(node => node.id === nodeId);
                    if (index !== -1) {
                        APP_STATE.assessmentTree.splice(index, 1);
                    }
                } else {
                    // Alt düğümü sil
                    const parentId = nodeId.substring(0, nodeId.lastIndexOf('.'));
                    const findParentAndRemoveChild = (nodes, id) => {
                        for (let i = 0; i < nodes.length; i++) {
                            const node = nodes[i];
                            if (node.id === parentId && node.children) {
                                const childIndex = node.children.findIndex(child => child.id === id);
                                if (childIndex !== -1) {
                                    node.children.splice(childIndex, 1);
                                    return true;
                                }
                            }
                            
                            if (node.children && node.children.length > 0) {
                                if (findParentAndRemoveChild(node.children, id)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    findParentAndRemoveChild(APP_STATE.assessmentTree, nodeId);
                }
                
                // DÜZELTME: Önce grup haritalamalarını temizle (ID değişmeden önce)
                cleanupGroupMappingsForDeletedNode(nodeId);
                
                // YENİ KOD: Eğer bir alt düğüm silindiyse, üst düğümün ağırlıklarını kontrol et
                if (!isRoot) {
                    const parentId = nodeId.substring(0, nodeId.lastIndexOf('.'));
                    const parentNode = findNodeById(parentId);
                    if (parentNode) {
                        // ID'leri yeniden sırala
                        reorderChildNodeIds(parentNode);
                        checkAndOfferRedistribution(parentNode);
                    }
                }
                
                // Ağacı yeniden render et
                renderTree();
                
                // Değerlendirme sekmesini güncelle
                console.log('🔄 Soru silindi, değerlendirme sekmesi güncelleniyor...');
                updateAssessmentView();
                console.log('✅ Değerlendirme sekmesi güncelleme tamamlandı');
                
                // Öğrenci grup bilgilerini güncelle
                updateStudentGroupInfoDisplay();
                
                showModernToast("Etkinlik başarıyla silindi.");
            } catch (error) {
                console.error("Düğüm silinirken hata oluştu:", error);
                showModernToast("Etkinlik silinemedi!", "error");
            }
        },
        // Silme onay mesajı
        `"${node.name}" etkinliğini ve tüm alt öğelerini silmek istediğinizden emin misiniz?`
    );
}

/**
 * Alt düğümlerin ID'lerini yeniden sıralar
 * Örnek: A1.3 silinirse A1.4 -> A1.3, A1.5 -> A1.4 olur
 * @param {Object} parentNode - Ana düğüm
 */
function reorderChildNodeIds(parentNode) {
    if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
        return;
    }
    
    console.log(`🔄 ID yeniden sıralama başlıyor: ${parentNode.id}`);
    
    // Eski ID -> Yeni ID mapping'i oluştur
    const idMapping = {};
    
    // Alt düğümleri yeniden numaralandır
    parentNode.children.forEach((child, index) => {
        const oldId = child.id;
        const newId = `${parentNode.id}.${index + 1}`;
        
        if (oldId !== newId) {
            console.log(`📝 ID değişikliği: ${oldId} -> ${newId}`);
            
            // ID mapping'e ekle
            idMapping[oldId] = newId;
            
            // Node'un ID'sini güncelle
            child.id = newId;
            
            // Eğer bu node'un da çocukları varsa, onları da güncelle
            if (child.children && child.children.length > 0) {
                updateChildrenIds(child.children, oldId, newId);
            }
        }
    });
    
    // Eğer ID değişiklikleri varsa, puan verilerini de güncelle
    if (Object.keys(idMapping).length > 0) {
        updateGradeDataWithNewIds(idMapping);
        
        // DÜZELTME: Grup haritalamalarındaki ID'leri de güncelle
        updateGroupMappingsWithNewIds(parentNode.id, idMapping);
        
        console.log(`✅ ${Object.keys(idMapping).length} ID güncellendi ve puan verileri taşındı`);
    }
}

/**
 * Alt düğümlerin ID'lerini recursive olarak günceller
 * @param {Array} children - Alt düğümler
 * @param {string} oldParentId - Eski parent ID
 * @param {string} newParentId - Yeni parent ID
 */
function updateChildrenIds(children, oldParentId, newParentId) {
    children.forEach(child => {
        const oldId = child.id;
        const newId = oldId.replace(oldParentId, newParentId);
        child.id = newId;
        
        if (child.children && child.children.length > 0) {
            updateChildrenIds(child.children, oldId, newId);
        }
    });
}

/**
 * Puan verilerini yeni ID'ler ile günceller
 * @param {Object} idMapping - Eski ID -> Yeni ID mapping'i
 */
function updateGradeDataWithNewIds(idMapping) {
    if (!APP_STATE.gradesData) return;
    
    console.log('📊 Puan verileri ID mapping ile güncelleniyor...');
    
    // Her öğrenci için puan verilerini güncelle
    Object.keys(APP_STATE.gradesData).forEach(studentId => {
        const studentGrades = APP_STATE.gradesData[studentId];
        
        // ID mapping'deki her değişiklik için
        Object.keys(idMapping).forEach(oldId => {
            const newId = idMapping[oldId];
            
            // Doğrudan ID eşleşmesi
            if (studentGrades[oldId] !== undefined) {
                studentGrades[newId] = studentGrades[oldId];
                delete studentGrades[oldId];
                console.log(`  📝 ${studentId}: ${oldId} -> ${newId} puanı taşındı`);
            }
            
            // Parent ID bazlı eşleşme (A1.1 -> A1[1] formatı)
            const oldParentId = oldId.substring(0, oldId.lastIndexOf('.'));
            const newParentId = newId.substring(0, newId.lastIndexOf('.'));
            
            if (studentGrades[oldParentId] && typeof studentGrades[oldParentId] === 'object') {
                // Tam ID ile eşleşme
                if (studentGrades[oldParentId][oldId] !== undefined) {
                    if (!studentGrades[newParentId]) studentGrades[newParentId] = {};
                    studentGrades[newParentId][newId] = studentGrades[oldParentId][oldId];
                    delete studentGrades[oldParentId][oldId];
                    console.log(`  📝 ${studentId}: ${oldParentId}[${oldId}] -> ${newParentId}[${newId}] puanı taşındı`);
                }
                
                // Kısa ID ile eşleşme (A1.1 -> 1)
                const oldShortId = oldId.split('.').pop();
                const newShortId = newId.split('.').pop();
                
                if (studentGrades[oldParentId][oldShortId] !== undefined && oldShortId !== newShortId) {
                    if (!studentGrades[newParentId]) studentGrades[newParentId] = {};
                    studentGrades[newParentId][newShortId] = studentGrades[oldParentId][oldShortId];
                    delete studentGrades[oldParentId][oldShortId];
                    console.log(`  📝 ${studentId}: ${oldParentId}[${oldShortId}] -> ${newParentId}[${newShortId}] puanı taşındı`);
                }
            }
        });
    });
}

// GUID sistemi kaldırıldı - findNodeByGuid fonksiyonu temizlendi

/**
 * Öğrenme çıktılarını listele
 */
function renderOutcomes() {
    try {
        console.log('renderOutcomes çağrıldı, APP_STATE.learningOutcomes:', APP_STATE.learningOutcomes);
        outcomesList.innerHTML = '';
        
        if (!APP_STATE.learningOutcomes || APP_STATE.learningOutcomes.length === 0) {
            console.log('ÖÇ verisi boş veya yok');
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'outcomes-empty-message';
            emptyMessage.textContent = 'Henüz öğrenme çıktısı tanımlanmadı. Ders JSON yükleyin.';
            outcomesList.appendChild(emptyMessage);
            return;
        }
        
        APP_STATE.learningOutcomes.forEach(outcome => {
            const item = document.createElement('div');
            item.className = 'outcome-item';
            item.textContent = `${outcome.id}: ${outcome.aciklama}`;
            item.title = outcome.aciklama;
            item.dataset.id = outcome.id;
            
            // Çıktıya tıklayarak değerlendirme ağacında seçili düğüme ekleme
            item.addEventListener('click', () => {
                if (APP_STATE.selectedNode) {
                    const outcomesInput = document.querySelector(`.tree-node[data-id="${APP_STATE.selectedNode.id}"] .nodeOutcomes`);
                    if (outcomesInput) {
                        const currentValue = outcomesInput.value.trim();
                        
                        // Alt düğüm ise (soru veya rubrik), sadece bir ÖÇ atanabilsin
                        const isSubItem = APP_STATE.selectedNode.id.includes('.');
                        
                        if (isSubItem) {
                            outcomesInput.value = outcome.id;
                        } else {
                            // Değer boşsa veya virgülle bitiyorsa
                            if (!currentValue) {
                                outcomesInput.value = outcome.id;
                            } else if (currentValue.endsWith(',')) {
                                outcomesInput.value = currentValue + ' ' + outcome.id;
                            } else {
                                outcomesInput.value = currentValue + ', ' + outcome.id;
                            }
                        }
                        
                        // Değeri değişmiş gibi tetikle
                        outcomesInput.dispatchEvent(new Event('change'));
                        
                        showModernToast(`"${outcome.id}" öğrenme çıktısı eklendi.`);
                    }
                } else {
                    showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
                }
            });
            
            outcomesList.appendChild(item);
        });
        
        // İçerik değiştikten sonra collapsible yüksekliklerini güncelle
        setTimeout(() => {
            initializeCollapsibleSections();
        }, 100);
    } catch (error) {
        console.error("Öğrenme çıktıları render edilirken hata oluştu:", error);
        showModernToast("Öğrenme çıktıları yüklenirken hata oluştu!", "error");
    }
}

/**
 * Program çıktılarını render etme
 */
function renderProgramOutcomes() {
    try {
        programOutcomesList.innerHTML = '';
        
        if (!APP_STATE.programOutcomes || APP_STATE.programOutcomes.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'outcomes-empty-message';
            emptyMessage.textContent = 'Henüz program çıktısı tanımlanmadı. Ders JSON yükleyin.';
            programOutcomesList.appendChild(emptyMessage);
            return;
        }
        
        APP_STATE.programOutcomes.forEach(programOutcome => {
            const item = document.createElement('div');
            item.className = 'outcome-item program-outcome-item';
            
            // Program çıktısı içeriğini oluştur
            const header = document.createElement('div');
            header.className = 'program-outcome-header';
            header.innerHTML = `
                <span class="program-outcome-id">${programOutcome.id}</span>
                <span class="program-outcome-category">${programOutcome.kategori}</span>
            `;
            
            const description = document.createElement('div');
            description.className = 'program-outcome-description';
            description.textContent = programOutcome.aciklama;
            
            item.appendChild(header);
            item.appendChild(description);
            item.title = `${programOutcome.id} - ${programOutcome.kategori}: ${programOutcome.aciklama}`;
            item.dataset.id = programOutcome.id;
            
            programOutcomesList.appendChild(item);
        });
        
        // İçerik değiştikten sonra collapsible yüksekliklerini güncelle
        setTimeout(() => {
            initializeCollapsibleSections();
        }, 100);
    } catch (error) {
        console.error("Program çıktıları render edilirken hata oluştu:", error);
        showModernToast("Program çıktıları yüklenirken hata oluştu!", "error");
    }
}

/**
 * Ders detaylarını render etme
 */
function renderCourseDetails() {
    try {
        console.log('renderCourseDetails çağrıldı');
        console.log('APP_STATE.courseData:', APP_STATE.courseData);
        console.log('courseDetailsContainer:', courseDetailsContainer);
        
        if (!APP_STATE.courseData) {
            console.log('courseData yok - boş mesaj gösteriliyor');
            courseDetailsContainer.innerHTML = '<div class="details-empty-message">Ders detayları için JSON yükleyin.</div>';
            return;
        }

        const { dersBilgisi, dersGenel, dersIcerik, haftalikDersIcerikleri } = APP_STATE.courseData;
        
        console.log('Veri parse ediliyor:');
        console.log('dersBilgisi:', dersBilgisi);
        console.log('dersGenel:', dersGenel);
        console.log('dersIcerik:', dersIcerik);
        console.log('haftalikDersIcerikleri:', haftalikDersIcerikleri);
        
        let html = '';
        
        // Ders Bilgisi (Yeni)
        if (dersBilgisi) {
            html += `
                <div class="details-section">
                    <h4 class="details-section-title">
                        <span class="section-icon">📚</span>
                        Ders Bilgisi
                    </h4>
                    <div class="details-grid">
                        <div class="detail-item">
                            <span class="detail-label">Ders Kodu:</span>
                            <span class="detail-value">${dersBilgisi.dersKodu || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Ders Adı:</span>
                            <span class="detail-value">${dersBilgisi.dersAdi || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Akademik Yıl:</span>
                            <span class="detail-value">${dersBilgisi.akademikYil || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Dönem:</span>
                            <span class="detail-value">${dersBilgisi.donem || '-'}</span>
                        </div>
                        <div class="detail-item full-width">
                            <span class="detail-label">Öğretim Üyesi:</span>
                            <span class="detail-value">${dersBilgisi.ogretimUyesi || '-'}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Genel Bilgiler
        if (dersGenel) {
            html += `
                <div class="details-section">
                    <h4 class="details-section-title">
                        <span class="section-icon">📚</span>
                        Genel Bilgiler
                    </h4>
                    <div class="details-grid">
                        <div class="detail-item">
                            <span class="detail-label">Ders Kodu:</span>
                            <span class="detail-value">${dersGenel.dersKodu || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Ders Adı:</span>
                            <span class="detail-value">${dersGenel.dersAdi || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Ders Türü:</span>
                            <span class="detail-value">${dersGenel.dersTuru || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Seviye:</span>
                            <span class="detail-value">${dersGenel.dersinSeviyesi || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Yarıyıl:</span>
                            <span class="detail-value">${dersGenel.dersinVerildigiYariyil || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Akademik Yıl:</span>
                            <span class="detail-value">${dersGenel.akademikYil || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Kredi:</span>
                            <span class="detail-value">${dersGenel.dersKredisi || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">AKTS:</span>
                            <span class="detail-value">${dersGenel.dersAKTSKredisi || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Kuramsal Saat:</span>
                            <span class="detail-value">${dersGenel.haftalikDersSaatiKuramsal || 0}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Uygulama Saat:</span>
                            <span class="detail-value">${dersGenel.haftalikUygulamaSaati || 0}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Laboratuvar Saat:</span>
                            <span class="detail-value">${dersGenel.haftalikLaboratuarSaati || 0}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Eğitim Dili:</span>
                            <span class="detail-value">${dersGenel.egitimDili || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Üniversite:</span>
                            <span class="detail-value">${dersGenel.universite || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Fakülte:</span>
                            <span class="detail-value">${dersGenel.fakulte || '-'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Bölüm:</span>
                            <span class="detail-value">${dersGenel.bolum || '-'}</span>
                        </div>
                        <div class="detail-item full-width">
                            <span class="detail-label">Müfredat Yılı:</span>
                            <span class="detail-value">${dersGenel.mufredatOlusturulmaYili || '-'}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Ders İçeriği
        if (dersIcerik) {
            html += `
                <div class="details-section">
                    <h4 class="details-section-title">
                        <span class="section-icon">📖</span>
                        Ders İçeriği ve Detayları
                    </h4>
                    <div class="content-details">
                        <div class="content-item">
                            <h5>📋 Dersin Amacı</h5>
                            <p>${dersIcerik.dersinAmaci || '-'}</p>
                        </div>
                        <div class="content-item">
                            <h5>📚 Dersin İçeriği</h5>
                            <p>${dersIcerik.dersinIcerigi || '-'}</p>
                        </div>
                        <div class="content-item">
                            <h5>⚠️ Ön Koşul Dersler</h5>
                            <p>${dersIcerik.dersinOnKosuluOlanDersler || '-'}</p>
                        </div>
                        <div class="content-item">
                            <h5>💡 Önerilen Hususlar</h5>
                            <p>${dersIcerik.dersinIcinOnerilenHususlar || '-'}</p>
                        </div>
                        <div class="content-item">
                            <h5>📚 Kaynaklar ve Materyaller</h5>
                            <pre class="sources-text">${dersIcerik.dersinKitabiMalzemesiOnerilenKaynaklar || '-'}</pre>
                        </div>
                        <div class="instructor-info">
                            <h5>👨‍🏫 Öğretim Üyesi Bilgileri</h5>
                            <div class="instructor-details">
                                <p><strong>Ad:</strong> ${dersIcerik.dersiVerenOgretimUyesiOgretimGorevlisi || '-'}</p>
                                <p><strong>E-mail:</strong> ${dersIcerik.email || '-'}</p>
                                <p><strong>Avesis:</strong> <a href="${dersIcerik.avesisProfile || '#'}" target="_blank">${dersIcerik.avesisProfile || '-'}</a></p>
                                <p><strong>Hazırlama Tarihi:</strong> ${dersIcerik.hazirlanmaTarihi || '-'}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Haftalık Ders İçerikleri
        if (haftalikDersIcerikleri && haftalikDersIcerikleri.length > 0) {
            html += `
                <div class="details-section">
                    <h4 class="details-section-title">
                        <span class="section-icon">📅</span>
                        Haftalık Ders İçerikleri (${haftalikDersIcerikleri.length} Hafta)
                    </h4>
                    <div class="weekly-content">
                        ${haftalikDersIcerikleri.map(hafta => `
                            <div class="week-item ${hafta.hafta === 8 || hafta.hafta === 16 ? 'exam-week' : ''}">
                                <div class="week-header">
                                    <span class="week-number">Hafta ${hafta.hafta}</span>
                                    <span class="week-outcomes">${hafta.iliskiliOgrenmeÇiktisi || '-'}</span>
                                </div>
                                <div class="week-content">
                                    <p class="week-description">${hafta.icerik || '-'}</p>
                                    <div class="week-details">
                                        <div class="week-detail">
                                            <strong>🏛️ Ortam:</strong> ${hafta.ogretimOrtami || '-'}
                                        </div>
                                        <div class="week-detail">
                                            <strong>📚 Ön Hazırlık:</strong> ${hafta.onHazirlik || '-'}
                                        </div>
                                        <div class="week-detail">
                                            <strong>🎯 Yöntem:</strong> ${hafta.ogretimYontemleri || '-'}
                                        </div>
                                        ${hafta.odevVeCalisma && hafta.odevVeCalisma !== '-' ? `
                                            <div class="week-detail">
                                                <strong>📝 Ödev/Çalışma:</strong> ${hafta.odevVeCalisma}
                                            </div>
                                        ` : ''}
                                        ${hafta.degerlendirmeYontemleri && hafta.degerlendirmeYontemleri !== '-' ? `
                                            <div class="week-detail evaluation">
                                                <strong>📊 Değerlendirme:</strong> ${hafta.degerlendirmeYontemleri}
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        console.log('HTML içeriği oluşturuldu, uzunluk:', html.length);
        console.log('HTML ilk 300 karakter:', html.substring(0, 300));
        
        courseDetailsContainer.innerHTML = html;
        
        console.log('HTML container\'a eklendi, şu anki içerik:', courseDetailsContainer.innerHTML.substring(0, 100));
        
        // İçerik değiştikten sonra collapsible yüksekliklerini güncelle
        setTimeout(() => {
            initializeCollapsibleSections();
        }, 100);
        
    } catch (error) {
        console.error("Ders detayları render edilirken hata oluştu:", error);
        showModernToast("Ders detayları yüklenirken hata oluştu!", "error");
    }
}

/**
 * ÖÇ-PÇ İlişki Matrisini render etme - Yeni basit versiyon
 */
function renderOutcomeMatrix() {
    try {
        if (!APP_STATE.outcomeMatrix || !APP_STATE.learningOutcomes || !APP_STATE.programOutcomes) {
            matrixContainer.innerHTML = '<div class="matrix-empty-message">ÖÇ-PÇ ilişki matrisi için ders JSON yükleyin.</div>';
            return;
        }

        // Legend oluştur
        const legend = document.createElement('div');
        legend.className = 'matrix-legend';
        legend.innerHTML = `
            <h4>İlişki Seviyesi</h4>
            <div class="legend-items">
                <span class="legend-item"><span class="legend-color level-0"></span>0 - İlişki Yok</span>
                <span class="legend-item"><span class="legend-color level-1"></span>1 - Çok Zayıf</span>
                <span class="legend-item"><span class="legend-color level-2"></span>2 - Zayıf</span>
                <span class="legend-item"><span class="legend-color level-3"></span>3 - Orta</span>
                <span class="legend-item"><span class="legend-color level-4"></span>4 - Güçlü</span>
                <span class="legend-item"><span class="legend-color level-5"></span>5 - Çok Güçlü</span>
            </div>
        `;

        // Matrix tablosu oluştur
        const table = document.createElement('table');
        table.className = 'matrix-table';
        
        // Header row
        let headerHTML = '<thead><tr><th class="matrix-corner">ÖÇ / PÇ</th>';
        APP_STATE.programOutcomes.forEach(pc => {
            headerHTML += `<th class="matrix-header" title="${pc.aciklama}">${pc.id}</th>`;
        });
        headerHTML += '</tr></thead>';
        
        // Body rows
        let bodyHTML = '<tbody>';
        APP_STATE.outcomeMatrix.iliskiTablosu.forEach(relation => {
            const learningOutcome = APP_STATE.learningOutcomes.find(lo => lo.id === relation.ogrenmeÇiktisiID);
            bodyHTML += `<tr>`;
            bodyHTML += `<th class="matrix-row-header" title="${learningOutcome ? learningOutcome.aciklama : ''}">${relation.ogrenmeÇiktisiID}</th>`;
            
            APP_STATE.programOutcomes.forEach(pc => {
                const value = relation.programÇiktilariIliskileri[pc.id] || 0;
                bodyHTML += `<td class="matrix-cell level-${value}" data-level="${value}">${value}</td>`;
            });
            
            bodyHTML += `</tr>`;
        });
        bodyHTML += '</tbody>';
        
        table.innerHTML = headerHTML + bodyHTML;
        
        // Container'ı temizle ve yeni içerikleri ekle
        matrixContainer.innerHTML = '';
        matrixContainer.appendChild(legend);
        matrixContainer.appendChild(table);
        
        // İçerik değiştikten sonra collapsible yüksekliklerini güncelle
        setTimeout(() => {
            initializeCollapsibleSections();
        }, 100);
        
    } catch (error) {
        console.error("ÖÇ-PÇ matrisi render edilirken hata oluştu:", error);
        showModernToast("ÖÇ-PÇ matrisi yüklenirken hata oluştu!", "error");
    }
}

/**
 * Ders bilgilerini görüntüleme
 */
function updateCourseInfo() {
    try {
        if (!APP_STATE.courseData) return;
        
        // Ders kodu ve adı
        const dersKodu = APP_STATE.courseData.dersGenel?.dersKodu || '-';
        const dersAdi = APP_STATE.courseData.dersGenel?.dersAdi || '-';
        courseTitle.textContent = `${dersKodu} - ${dersAdi}`;
        
        // Akademik yıl ve dönem
        const akademikYil = APP_STATE.courseData.dersGenel?.akademikYil || '-';
        const donem = APP_STATE.courseData.dersGenel?.dersinVerildigiYariyil || '-';
        const ogretimUyesi = APP_STATE.courseData.dersIcerik?.dersiVerenOgretimUyesiOgretimGorevlisi || '-';
        
        courseDetails.textContent = `Akademik Yıl: ${akademikYil} | Yarıyıl: ${donem} | Öğr. Üyesi: ${ogretimUyesi}`;
        
        // Tarih bilgisi ekle
        courseTerm.textContent = `${akademikYil} (${donem}. Yarıyıl)`;
        
        // Ders bilgileri ekranını vurgulamak için stil ekle
        document.getElementById('courseInfo').style.borderLeft = '5px solid var(--primary-color)';
        document.getElementById('courseInfo').style.backgroundColor = 'var(--secondary-light)';
    } catch (error) {
        console.error("Ders bilgileri güncellenirken hata oluştu:", error);
    }
}

// =====================================================
// NOT GİRİŞİ VE HESAPLAMA FONKSİYONLARI
// =====================================================

/**
 * Değerlendirme görünümünü güncelleme
 */
function updateAssessmentView() {
    console.log('🎯 updateAssessmentView çağrıldı - mevcut ağaç:', APP_STATE.assessmentTree);
    
    try {
        // Konteyner kontrolü
        if (!assessmentContainer) {
            console.error('❌ assessmentContainer bulunamadı');
            return;
        }
        
        // Veri kontrolü
        if (!APP_STATE.assessmentTree?.length || !APP_STATE.studentData?.length) {
            assessmentContainer.innerHTML = `
                <p class="empty-message">Değerlendirme girişi yapabilmek için hem ders tanımlama hem de öğrenci listesi sekmelerinden gerekli bilgileri yüklemeniz gerekmektedir.</p>
            `;
            updateAssessmentFilterInfo();
            return;
        }
        
        // Orijinal öğrenci verilerini koru
        const originalStudentData = APP_STATE.studentData;
        
        try {
        // Filtrelenmiş öğrenci listesini al
        const filteredStudents = getFilteredStudentsForAssessment();
        
        // Geçici olarak APP_STATE.studentData'yı değiştir
        APP_STATE.studentData = filteredStudents;
        
        // Değerlendirme konteynerini temizle
        assessmentContainer.innerHTML = '';
        
            // Etkinlikleri kategorilere ayır
        const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            
            // Yarıyıl içi etkinlikleri render et
            if (termActivities.length > 0) {
                renderActivitySection(
                    'Yarıyıl İçi Etkinlikler', 
                    APP_STATE.termWeight || 40, 
                    termActivities, 
                    'term'
                );
            }
            
            // Yarıyıl sonu etkinlikleri render et
        if (finalActivities.length > 0) {
                renderActivitySection(
                    'Yarıyıl Sonu Etkinlikler', 
                    APP_STATE.finalWeight || 60, 
                    finalActivities, 
                    'final'
                );
            }
            
            // Notları hesaplama butonu ekle
            addCalculateGradesButton();
        
        // Filtre bilgisini güncelle
        updateAssessmentFilterInfo();
        
        // ÖÇ tooltip sistemini başlat
        setTimeout(() => {
                if (typeof initializeOutcomeTooltips === 'function') {
            initializeOutcomeTooltips();
                }
        }, 100);
        
        } finally {
            // Her durumda orijinal öğrenci listesini geri yükle
            APP_STATE.studentData = originalStudentData;
        }
        
        // Ek güncellemeler - ders tanımlama değişikliklerini yansıt (grup seçicileri hariç)
        setTimeout(() => {
            console.log('🔄 Ders tanımlama değişiklikleri yansıtılıyor (grup seçicileri korunuyor)...');
            // Grup seçicilerini güncelleme - HTML oluşturma sırasında zaten doğru yapıldı
            // updateGroupSelectors(); // Bu satırı kaldırıyoruz
            
            // Diğer bileşenleri güncelle
            if (typeof updateOutcomesTextarea === 'function') {
                updateOutcomesTextarea();
            }
            
            if (typeof updateCategoryWeights === 'function') {
                updateCategoryWeights();
            }
            
            if (typeof updateAllMappingDisplays === 'function') {
                updateAllMappingDisplays();
            }
            
            if (typeof updateAllInlineGroupInputs === 'function') {
                updateAllInlineGroupInputs();
            }
            
            console.log('✅ Ders tanımlama değişiklikleri yansıtıldı (grup seçicileri korundu)');
        }, 100);
        
        // DÜZELTME: Tablo oluşturulduktan sonra grup bazlı maksimum puan gösterimini düzelt
        setTimeout(() => {
            console.log('🔄 Grup bazlı maksimum puan güncelleme başlatılıyor...');
            
            // Tüm component'ler için güncelleme yap
            const allComponents = document.querySelectorAll('[data-component-id]');
            const componentIds = new Set();
            
            allComponents.forEach(element => {
                const componentId = element.getAttribute('data-component-id');
                if (componentId) componentIds.add(componentId);
            });
            
            componentIds.forEach(componentId => {
                APP_STATE.studentData.forEach(student => {
                    const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                    // Her öğrenci için grup bazlı soru bilgilerini güncelle
                    updateQuestionInfoForComponent(student.studentId, studentCurrentGroup, componentId);
                });
            });
            
            console.log('✅ Grup bazlı maksimum puan güncelleme tamamlandı');
        }, 150);
        
        console.log('✅ updateAssessmentView tamamlandı');
        
    } catch (error) {
        console.error("❌ Değerlendirme görünümü güncellenirken hata oluştu:", error);
        showModernToast("Değerlendirme görünümü güncellenemedi!", "error");
    }
}

/**
 * Etkinlik bölümü render etme
 * @param {string} title - Bölüm başlığı
 * @param {number} weight - Ağırlık yüzdesi
 * @param {Array} activities - Etkinlikler listesi
 * @param {string} type - Etkinlik tipi ('term' veya 'final')
 */
function renderActivitySection(title, weight, activities, type) {
    const header = document.createElement('h3');
    header.textContent = `${title} (${weight}%)`;
    header.className = 'section-title';
    assessmentContainer.appendChild(header);
    
    activities.forEach(activity => {
        try {
            createAssessmentActivitySection(activity, assessmentContainer, type);
        } catch (error) {
            console.error(`❌ ${activity.id} etkinliği render edilemedi:`, error);
        }
    });
}

/**
 * Notları hesaplama butonu ekle
 */
function addCalculateGradesButton() {
        const calculateButton = document.createElement('button');
        calculateButton.className = 'btn btn-primary';
        calculateButton.style.marginTop = '20px';
        calculateButton.innerHTML = `
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M5 3a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5zm14 4h-6m-2 4h-2m-4 4h12"></path>
            </svg>
            Notları Hesapla
        `;
        calculateButton.addEventListener('click', calculateGrades);
        assessmentContainer.appendChild(calculateButton);
}

/**
 * Değerlendirme girişi için filtrelenmiş öğrenci listesini al
 */
function getFilteredStudentsForAssessment() {
    try {
    const filterSelect = document.getElementById('assessmentStudentFilter');
        
        // Filtre yoksa veya değer seçilmemişse tüm öğrenciler
    if (!filterSelect || !filterSelect.value) {
            return APP_STATE.studentData || [];
    }
    
    const selectedStudentId = filterSelect.value;
        
        // Güvenlik kontrolü
        if (!APP_STATE.studentData || !Array.isArray(APP_STATE.studentData)) {
            console.warn('⚠️ Öğrenci verisi bulunamadı veya geçersiz');
            return [];
        }
        
        // Filtrelenmiş öğrenciyi bul
        const filteredStudents = APP_STATE.studentData.filter(student => 
            student && student.studentId === selectedStudentId
        );
        
        if (filteredStudents.length === 0) {
            console.warn(`⚠️ ${selectedStudentId} ID'li öğrenci bulunamadı`);
        }
        
        return filteredStudents;
        
    } catch (error) {
        console.error('❌ Öğrenci filtresi hatası:', error);
        return APP_STATE.studentData || [];
    }
}

/**
 * Değerlendirme filtresi bilgisini güncelle
 */
function updateAssessmentFilterInfo() {
    try {
    const filterInfo = document.getElementById('assessmentFilterInfo');
    const filterSelect = document.getElementById('assessmentStudentFilter');
    
        if (!filterInfo) {
            console.warn('⚠️ assessmentFilterInfo elementi bulunamadı');
            return;
        }
    
        const totalStudents = APP_STATE.studentData?.length || 0;
    const filteredStudents = getFilteredStudentsForAssessment();
    const filteredCount = filteredStudents.length;
    
    if (!filterSelect || !filterSelect.value) {
        // Filtre yok - tüm öğrenciler gösteriliyor
        filterInfo.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                <circle cx="8.5" cy="7" r="4"></circle>
                <line x1="20" y1="8" x2="20" y2="14"></line>
                <line x1="23" y1="11" x2="17" y2="11"></line>
            </svg>
            Toplam ${totalStudents} öğrenci gösteriliyor
        `;
        filterInfo.className = 'filter-info';
    } else {
        // Filtre aktif - seçili öğrenci gösteriliyor
        const selectedStudent = filteredStudents[0];
            
            if (selectedStudent) {
        filterInfo.innerHTML = `
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
                    ${selectedStudent.studentId} - ${selectedStudent.name} ${selectedStudent.surname}
        `;
        filterInfo.className = 'filter-info filtered';
            } else {
                filterInfo.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"/>
                    </svg>
                    Öğrenci bulunamadı (${filterSelect.value})
                `;
                filterInfo.className = 'filter-info error';
            }
        }
        
        console.log(`📊 Filtre bilgisi güncellendi: ${filteredCount}/${totalStudents} öğrenci`);
        
    } catch (error) {
        console.error('❌ Filtre bilgisi güncelleme hatası:', error);
    }
}

/**
 * Değerlendirme öğrenci filtresini başlat
 */
function initializeAssessmentStudentFilter() {
    const filterSelect = document.getElementById('assessmentStudentFilter');
    if (!filterSelect) return;
    
    // Öğrenci listesini doldur
    updateAssessmentStudentFilterOptions();
    
    // Change event listener ekle
    filterSelect.addEventListener('change', function() {
        updateAssessmentView();
    });
}

/**
 * Değerlendirme öğrenci filtresi seçeneklerini güncelle
 */
function updateAssessmentStudentFilterOptions() {
    try {
    const filterSelect = document.getElementById('assessmentStudentFilter');
        if (!filterSelect) {
            console.warn('⚠️ assessmentStudentFilter elementi bulunamadı');
            return;
        }
    
    const currentValue = filterSelect.value;
    
    // Seçenekleri temizle
    filterSelect.innerHTML = '<option value="">Tüm Öğrenciler</option>';
        
        // Öğrenci verisi kontrolü
        if (!APP_STATE.studentData || !Array.isArray(APP_STATE.studentData)) {
            console.warn('⚠️ Öğrenci verisi bulunamadı, filtre seçenekleri boş bırakılıyor');
            updateAssessmentFilterInfo();
            return;
        }
    
    // Öğrenci seçeneklerini ekle
        let addedCount = 0;
    APP_STATE.studentData.forEach(student => {
            try {
                if (!student || !student.studentId) {
                    console.warn('⚠️ Geçersiz öğrenci verisi atlandı:', student);
                    return;
                }
                
        const option = document.createElement('option');
        option.value = student.studentId;
                option.textContent = `${student.studentId} - ${student.name || 'Ad Yok'} ${student.surname || 'Soyad Yok'}`;
        
        if (student.studentId === currentValue) {
            option.selected = true;
        }
        
        filterSelect.appendChild(option);
                addedCount++;
                
            } catch (error) {
                console.error('❌ Öğrenci seçeneği eklenirken hata:', error, student);
            }
    });
        
        console.log(`📝 ${addedCount} öğrenci filtre seçeneği eklendi`);
    
    // Filtre bilgisini güncelle
    updateAssessmentFilterInfo();
        
    } catch (error) {
        console.error('❌ Öğrenci filtre seçenekleri güncelleme hatası:', error);
    }
}

/**
 * Tek öğrenci için anlık not hesaplama (Değerlendirme tablosunda kullanım için)
 * @param {string} studentId - Öğrenci ID'si
 * @returns {Object} - Hesaplanan notlar
 */
function calculateStudentGrades(studentId) {
    try {
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            return {
                termGrade: 0.00,
                finalGrade: 0.00, 
                totalGrade: 0.00,
                letterGrade: "FF"
            };
        }
        
        // Yarıyıl içi etkinlikler
        const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
        let termGrade = 0;
        
        // İç ağırlık toplamı
        const termInternalTotal = termActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        
        if (termInternalTotal > 0) {
            termActivities.forEach(activity => {
                // İç ağırlık normalleştirmesi
                const activityWeight = activity.weight / termInternalTotal; 
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler
                    const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                    
                    if (childrenTotalWeight > 0) {
                        activity.children.forEach(subItem => {
                            // Alt öğe ağırlık normalleştirmesi
                            const subItemWeight = subItem.weight / childrenTotalWeight; 
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                            const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                            activityGrade += scaledGrade * subItemWeight;
                        });
                    }
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                }
                
                termGrade += activityGrade * activityWeight;
            });
        }
        
        // Yarıyıl sonu etkinlikler
        const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
        let finalGrade = 0;
        
        // İç ağırlık toplamı
        const finalInternalTotal = finalActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        
        if (finalInternalTotal > 0) {
            finalActivities.forEach(activity => {
                // İç ağırlık normalleştirmesi
                const activityWeight = activity.weight / finalInternalTotal;
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler
                    const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                    
                    if (childrenTotalWeight > 0) {
                        activity.children.forEach(subItem => {
                            // Alt öğe ağırlık normalleştirmesi
                            const subItemWeight = subItem.weight / childrenTotalWeight;
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                            const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                            activityGrade += scaledGrade * subItemWeight;
                        });
                    }
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                }
                
                finalGrade += activityGrade * activityWeight;
            });
        }
        
        // Toplam ve harf notu
        const totalGrade = (termGrade * APP_STATE.termWeight / 100) + (finalGrade * APP_STATE.finalWeight / 100);
        const letterGrade = getLetterGrade(totalGrade);
        
        return {
            termGrade: parseFloat(termGrade.toFixed(2)),
            finalGrade: parseFloat(finalGrade.toFixed(2)),
            totalGrade: parseFloat(totalGrade.toFixed(2)),
            letterGrade: letterGrade
        };
        
    } catch (error) {
        console.error("Öğrenci notları hesaplanırken hata:", error);
        return {
            termGrade: 0.00,
            finalGrade: 0.00,
            totalGrade: 0.00, 
            letterGrade: "FF"
        };
    }
}

/**
 * Harf notuna göre CSS sınıfı getirme
 * @param {string} letterGrade - Harf notu
 * @returns {string} - CSS sınıfı
 */
function getLetterGradeClass(letterGrade) {
    if (['AA', 'BA', 'BB'].includes(letterGrade)) {
        return 'grade-excellent';
    } else if (['CB', 'CC'].includes(letterGrade)) {
        return 'grade-good';
    } else if (['DC', 'DD'].includes(letterGrade)) {
        return 'grade-pass';
    } else {
        return 'grade-fail';
    }
}

/**
 * Değerlendirme tablosundaki not özeti hücrelerini güncelle
 * @param {string} studentId - Öğrenci ID'si  
 */
function updateAssessmentGradeSummary(studentId) {
    try {
        // Yeni notları hesapla
        const studentGrades = calculateStudentGrades(studentId);
        
        // Bu öğrencinin tüm satırlarını bul
        const studentRows = document.querySelectorAll(`tr[data-student-id="${studentId}"]`);
        
        studentRows.forEach(row => {
            // Not özeti hücrelerini bul ve güncelle
            const termGradeCell = row.querySelector('.grade-summary-cell.term-grade');
            const finalGradeCell = row.querySelector('.grade-summary-cell.final-grade');
            const totalGradeCell = row.querySelector('.grade-summary-cell.total-grade');
            const letterGradeCell = row.querySelector('.grade-summary-cell.letter-grade');
            
            if (termGradeCell) {
                termGradeCell.textContent = studentGrades.termGrade.toFixed(2);
            }
            
            if (finalGradeCell) {
                finalGradeCell.textContent = studentGrades.finalGrade.toFixed(2);
            }
            
            if (totalGradeCell) {
                totalGradeCell.textContent = studentGrades.totalGrade.toFixed(2);
            }
            
            if (letterGradeCell) {
                // Eski CSS sınıflarını kaldır
                letterGradeCell.classList.remove('grade-excellent', 'grade-good', 'grade-pass', 'grade-fail');
                // Yeni CSS sınıfını ekle
                letterGradeCell.classList.add(getLetterGradeClass(studentGrades.letterGrade));
                letterGradeCell.textContent = studentGrades.letterGrade;
            }
        });
        
    } catch (error) {
        console.error("Assessment not özeti güncellenirken hata:", error);
    }
}

/**
 * Değerlendirme etkinliği bölümü oluşturma
 * @param {Object} activity - Etkinlik
 * @param {HTMLElement} container - Konteyner elementi
 * @param {string} type - Etkinlik tipi (term/final)
 */
function createAssessmentActivitySection(activity, container, type) {
    console.log(`📊 createAssessmentActivitySection çağrıldı: ${activity.id} (${activity.name})`);
    try {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'assessment-subsection';
        sectionDiv.dataset.activityId = activity.id;
        
        const header = document.createElement('h4');
        header.innerHTML = `${getComponentDisplayName(activity.id)} <span class="badge badge-primary">${activity.weight}%</span>`;
        sectionDiv.appendChild(header);
        
        // Aktivitenin alt öğeleri var mı kontrol et
        if (activity.children && activity.children.length > 0) {
            // Test var mı kontrol et
            const hasTest = activity.children.some(child => child.type === 'Test');
            
            if (hasTest) {
                // Test soruları için özel giriş
            activity.children.forEach(subItem => {
                if (subItem.type === 'Test') {
                    createTestInputSection(subItem, sectionDiv);
                }
            });
        } else {
                // Normal sorular için kağıt sırası bazında tek giriş
                createComponentPaperOrderInputSection(activity, sectionDiv);
            }
        } else {
            // Alt öğe yoksa basit bir puan girişi göster (Laboratuvar gibi)
            const simpleInputDiv = document.createElement('div');
            simpleInputDiv.className = 'assessment-table-container';
            
            // Basit bileşenler için grup bilgisi kutusu gösterilmez
            const componentId = getParentComponentId(activity.id) || activity.id;
            const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
            const groups = component?.gruplar || ['A'];
            
            // Tablo başlıklarını her zaman grup sütunu ile göster
            // Yarıyıl içi ve sonu oranlarını dinamik olarak al
            const termWeight = getTermWeight();
            const finalWeight = getFinalWeight();
            const tableHeaders = `<th>No</th><th>Öğrenci No</th><th>Adı</th><th>Soyadı</th><th>E-posta</th><th>Grup</th><th>Etkinlik Max. Puan<br/><small>(Soru/Rubrik)</small></th><th>Toplam Puan<br/><small>(Değerlendirme Oranı: ${getAssessmentWeight(activity.id)}%)</small></th><th>Alınan Puan<br/><small>(Etkinlik Puanı)</small></th><th>Yarıyıl İçi<br/><small>(${termWeight}%)</small></th><th>Yarıyıl Sonu<br/><small>(${finalWeight}%)</small></th><th>Ortalama</th><th>Harf Notu</th>`;
            
            const tableHTML = `
                <table class="assessment-table">
                    <thead>
                        <tr>
                            ${tableHeaders}
                        </tr>
                    </thead>
                    <tbody>
                        ${APP_STATE.studentData.map((student, index) => {
                            // Sadece bu bileşenin gruplarını göster
                            const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                            console.log(`🔍 ${componentId} için öğrenci ${student.studentId}: gruplar=${groups.join(',')}, mevcut=${studentCurrentGroup}`);
                            const groupOptions = groups.map(groupId => 
                                `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
                            ).join('');
                            console.log(`  📝 HTML groupOptions: "${groupOptions}"`);
                            
                            // Bu basit aktivite için maksimum puan her zaman activity.points'tir
                            const maxPoints = activity.points;
                            
                            // Grup sütununu her zaman göster
                            const groupColumn = `<td>
                                        <select class="group-selector compact" data-student-id="${student.studentId}" data-component-id="${componentId}" onchange="updateStudentGroupForComponent(this)">
                                            ${groupOptions}
                                        </select>
                                    </td>`;
                            console.log(`  🏗️ HTML grup sütunu oluşturuldu: ${student.studentId} - ${componentId}`);
                            
                            // Öğrenci notlarını hesapla
                            const studentGrades = calculateStudentGrades(student.studentId);
                            
                            return `
                            <tr data-student-id="${student.studentId}" data-component-id="${componentId}">
                                <td>${index + 1}</td>
                                <td>${student.studentId}</td>
                                <td>${student.name}</td>
                                <td>${student.surname}</td>
                                <td class="email-cell">
                                    <span class="email-text" title="${student.email || 'E-posta bulunamadı'}">${student.email || '-'}</span>
                                    ${student.email ? `<button class="email-button" title="E-posta gönder" onclick="openEmailModal({studentId: '${student.studentId}', name: '${student.name}', surname: '${student.surname}', email: '${student.email}'})">E-posta</button>` : ''}
                                </td>
                                ${groupColumn}
                                <td class="question-points-cell" data-student-id="${student.studentId}" data-activity-id="${activity.id}">
                                    ${maxPoints}
                                </td>
                                <td class="total-points-cell" data-student-id="${student.studentId}" data-activity-id="${activity.id}">
                                    ${getStudentTotalEarnedPointsForComponent(student.studentId, activity.id)}
                                </td>
                                <td>
                                    <input type="number" min="0" max="${maxPoints}" 
                                        data-student-id="${student.studentId}" 
                                        data-activity-id="${activity.id}" 
                                        value="${getStudentGrade(student.studentId, activity.id) || ''}"
                                        onchange="updateStudentGrade(this)"
                                        placeholder="0-${maxPoints}"
                                        title="Bu aktivitenin maksimum puanı: ${maxPoints}"
                                    >
                                </td>
                                <td class="grade-summary-cell term-grade">${studentGrades.termGrade}</td>
                                <td class="grade-summary-cell final-grade">${studentGrades.finalGrade}</td>
                                <td class="grade-summary-cell total-grade">${studentGrades.totalGrade}</td>
                                <td class="grade-summary-cell letter-grade ${getLetterGradeClass(studentGrades.letterGrade)}">${studentGrades.letterGrade}</td>
                            </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
            
            simpleInputDiv.innerHTML = tableHTML;
            sectionDiv.appendChild(simpleInputDiv);
        }
        
        container.appendChild(sectionDiv);
    } catch (error) {
        console.error("Değerlendirme etkinliği bölümü oluşturulurken hata oluştu:", error);
    }
}

/**
 * Test soruları için özel giriş bölümü oluşturma
 * @param {Object} testItem - Test öğesi
 * @param {HTMLElement} container - Konteyner elementi
 */
function createTestInputSection(testItem, container) {
    try {
        const testDiv = document.createElement('div');
        testDiv.className = 'assessment-subsection';
        
        // Test detaylarını göster
        const testDetailsDiv = document.createElement('div');
        testDetailsDiv.className = 'test-details';
        testDetailsDiv.innerHTML = `
            <h5>${testItem.name}</h5>
            <div class="test-info">
                <p>Toplam ${testItem.testDetails.totalQuestions} soru, her doğru: ${testItem.testDetails.correctWeight} puan, her yanlış: ${testItem.testDetails.wrongPenalty} puan</p>
            </div>
        `;
        testDiv.appendChild(testDetailsDiv);
        
        // Modern grup bilgileri gösterimi
        const parentComponentId = getParentComponentId(testItem.id);
        const modernGroupInfo = createModernGroupInfoDisplay(parentComponentId, testItem.id);
        if (modernGroupInfo) {
            testDiv.appendChild(modernGroupInfo);
        }
        
        // Giriş modları oluştur
        const inputModesDiv = document.createElement('div');
        inputModesDiv.className = 'input-modes';
        
        const detailedModeButton = document.createElement('div');
        detailedModeButton.className = 'input-mode active';
        detailedModeButton.textContent = 'Detaylı Giriş';
        detailedModeButton.dataset.mode = 'detailed';
        detailedModeButton.dataset.testId = testItem.id;
        
        const simpleModeButton = document.createElement('div');
        simpleModeButton.className = 'input-mode';
        simpleModeButton.textContent = 'Basit Giriş';
        simpleModeButton.dataset.mode = 'simple';
        simpleModeButton.dataset.testId = testItem.id;
        
        // Mod butonları için olay dinleyicileri
        detailedModeButton.addEventListener('click', function() {
            switchTestInputMode(this.dataset.testId, 'detailed');
        });
        
        simpleModeButton.addEventListener('click', function() {
            switchTestInputMode(this.dataset.testId, 'simple');
        });
        
        inputModesDiv.appendChild(detailedModeButton);
        inputModesDiv.appendChild(simpleModeButton);
        testDiv.appendChild(inputModesDiv);
        
        // Detaylı giriş formu - Doğru/Yanlış sayısı
        const detailedFormDiv = document.createElement('div');
        detailedFormDiv.className = 'test-input-form detailed-mode';
        detailedFormDiv.dataset.testId = testItem.id;
        
        // Tablo oluştur
        const detailedTable = document.createElement('table');
        detailedTable.className = 'assessment-table';
        
        // Bu test öğesinin bağlı olduğu bileşenin gruplarını al
        const componentId = getParentComponentId(testItem.id);
        const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
        const groups = component?.gruplar || ['A'];
        
        const detailedTableHTML = `
            <thead>
                <tr>
                    <th>No</th>
                    <th>Öğrenci No</th>
                    <th>Adı</th>
                    <th>Soyadı</th>
                    <th>E-posta</th>
                    <th>Grup</th>
                    <th>Doğru Sayısı</th>
                    <th>Yanlış Sayısı</th>
                    <th>Boş Sayısı</th>
                    <th>Toplam Puan<br/><small>(Değerlendirme Oranı: ${getAssessmentWeight(testItem.id)}%)</small></th>
                    <th>Yarıyıl İçi<br/><small>(${getTermWeight()}%)</small></th>
                    <th>Yarıyıl Sonu<br/><small>(${getFinalWeight()}%)</small></th>
                    <th>Ortalama</th>
                    <th>Harf Notu</th>
                </tr>
            </thead>
            <tbody>
                ${APP_STATE.studentData.map((student, index) => {
                    // Test sonuçlarını al
                    const testScore = getStudentTestScore(student.studentId, testItem.id);
                    const correct = testScore?.correct || 0;
                    const wrong = testScore?.wrong || 0;
                    const empty = testItem.testDetails.totalQuestions - correct - wrong;
                    const totalScore = correct * testItem.testDetails.correctWeight - wrong * Math.abs(testItem.testDetails.wrongPenalty);
                    
                    const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                    const groupOptions = groups.map(groupId => 
                        `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
                    ).join('');
                    
                    // Öğrenci notlarını hesapla
                    const studentGrades = calculateStudentGrades(student.studentId);
                    
                    return `
                        <tr>
                            <td>${index + 1}</td>
                            <td>${student.studentId}</td>
                            <td>${student.name}</td>
                            <td>${student.surname}</td>
                            <td class="email-cell">
                                <span class="email-text" title="${student.email || 'E-posta bulunamadı'}">${student.email || '-'}</span>
                                ${student.email ? `<button class="email-button" title="E-posta gönder" onclick="openEmailModal({studentId: '${student.studentId}', name: '${student.name}', surname: '${student.surname}', email: '${student.email}'})">E-posta</button>` : ''}
                            </td>
                            <td>
                                <select class="group-selector compact" data-student-id="${student.studentId}" data-component-id="${componentId}" onchange="updateStudentGroupForComponent(this)">
                                    ${groupOptions}
                                </select>
                            </td>
                            <td>
                                <input type="number" min="0" max="${testItem.testDetails.totalQuestions}" 
                                    data-student-id="${student.studentId}" 
                                    data-test-id="${testItem.id}" 
                                    data-field="correct"
                                    value="${correct}"
                                    onchange="updateTestScore(this)"
                                >
                            </td>
                            <td>
                                <input type="number" min="0" max="${testItem.testDetails.totalQuestions}" 
                                    data-student-id="${student.studentId}" 
                                    data-test-id="${testItem.id}" 
                                    data-field="wrong"
                                    value="${wrong}"
                                    onchange="updateTestScore(this)"
                                >
                            </td>
                            <td>${empty}</td>
                            <td class="total-score">${totalScore.toFixed(2)}</td>
                            <td class="grade-summary-cell term-grade">${studentGrades.termGrade}</td>
                            <td class="grade-summary-cell final-grade">${studentGrades.finalGrade}</td>
                            <td class="grade-summary-cell total-grade">${studentGrades.totalGrade}</td>
                            <td class="grade-summary-cell letter-grade ${getLetterGradeClass(studentGrades.letterGrade)}">${studentGrades.letterGrade}</td>
                        </tr>
                    `;
                }).join('')}
            </tbody>
        `;
        
        detailedTable.innerHTML = detailedTableHTML;
        detailedFormDiv.appendChild(detailedTable);
        testDiv.appendChild(detailedFormDiv);
        
        // Basit giriş formu - Sadece toplam puan
        const simpleFormDiv = document.createElement('div');
        simpleFormDiv.className = 'test-input-form simple-mode';
        simpleFormDiv.dataset.testId = testItem.id;
        simpleFormDiv.style.display = 'none'; // Başlangıçta gizli
        
        // Tablo oluştur
        const simpleTable = document.createElement('table');
        simpleTable.className = 'assessment-table';
        
        const simpleTableHTML = `
            <thead>
                <tr>
                    <th>No</th>
                    <th>Öğrenci No</th>
                    <th>Adı</th>
                    <th>Soyadı</th>
                    <th>E-posta</th>
                    <th>Grup</th>
                    <th>Toplam Puan (${testItem.points})</th>
                    <th>Yarıyıl İçi</th>
                    <th>Yarıyıl Sonu</th>
                    <th>Ortalama</th>
                    <th>Harf Notu</th>
                </tr>
            </thead>
            <tbody>
                ${APP_STATE.studentData.map((student, index) => {
                    // Test sonuçlarını al
                    const testScore = getStudentTestScore(student.studentId, testItem.id);
                    const correct = testScore?.correct || 0;
                    const wrong = testScore?.wrong || 0;
                    const totalScore = correct * testItem.testDetails.correctWeight - wrong * Math.abs(testItem.testDetails.wrongPenalty);
                    
                    const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                    console.log(`🔍 Test detaylı giriş - ${componentId} için öğrenci ${student.studentId}: gruplar=${groups.join(',')}, mevcut=${studentCurrentGroup}`);
                    const groupOptions = groups.map(groupId => 
                        `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
                    ).join('');
                    
                    // Öğrenci notlarını hesapla
                    const studentGrades = calculateStudentGrades(student.studentId);
                    
                    return `
                        <tr>
                            <td>${index + 1}</td>
                            <td>${student.studentId}</td>
                            <td>${student.name}</td>
                            <td>${student.surname}</td>
                            <td class="email-cell">
                                <span class="email-text" title="${student.email || 'E-posta bulunamadı'}">${student.email || '-'}</span>
                                ${student.email ? `<button class="email-button" title="E-posta gönder" onclick="openEmailModal({studentId: '${student.studentId}', name: '${student.name}', surname: '${student.surname}', email: '${student.email}'})">E-posta</button>` : ''}
                            </td>
                            <td>
                                <select class="group-selector compact" data-student-id="${student.studentId}" data-component-id="${componentId}" onchange="updateStudentGroupForComponent(this)">
                                    ${groupOptions}
                                </select>
                            </td>
                            <td>
                                <input type="number" min="0" max="${testItem.points}" 
                                    data-student-id="${student.studentId}" 
                                    data-activity-id="${testItem.id}" 
                                    value="${totalScore.toFixed(2)}"
                                    onchange="updateStudentGrade(this)"
                                >
                            </td>
                            <td class="grade-summary-cell term-grade">${studentGrades.termGrade}</td>
                            <td class="grade-summary-cell final-grade">${studentGrades.finalGrade}</td>
                            <td class="grade-summary-cell total-grade">${studentGrades.totalGrade}</td>
                            <td class="grade-summary-cell letter-grade ${getLetterGradeClass(studentGrades.letterGrade)}">${studentGrades.letterGrade}</td>
                        </tr>
                    `;
                }).join('')}
            </tbody>
        `;
        
        simpleTable.innerHTML = simpleTableHTML;
        simpleFormDiv.appendChild(simpleTable);
        testDiv.appendChild(simpleFormDiv);
        
        container.appendChild(testDiv);
    } catch (error) {
        console.error("Test giriş bölümü oluşturulürken hata oluştu:", error);
    }
}

/**
 * Modern grup bilgileri gösterim elementi oluşturma
 * @param {string} componentId - Bileşen ID'si
 * @param {string} questionId - Soru ID'si
 * @returns {HTMLElement|null} - Grup bilgileri elementi
 */
function createModernGroupInfoDisplay(componentId, questionId) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari?.[componentId]) {
            return null;
        }

        const componentData = APP_STATE.courseData.grupHaritalari[componentId];
        const groups = componentData.gruplar || [];
        
        // Grup yoksa gösterme, ama tek grup varsa göster
        if (groups.length === 0) {
            return null;
        }

        const groupInfoDiv = document.createElement('div');
        groupInfoDiv.className = 'compact-group-info';
        
        // Grup bilgilerini kompakt formatta hazırla
        const groupMappings = [];
        groups.forEach(groupId => {
            let paperOrder = '-';
            let originalOrder = '-';
            let questionPoints = '-';
            
            // Bu grubun bu soru için haritalama bilgisi var mı?
            const groupMappings_data = componentData.haritalar?.[groupId]?.[questionId];
            
            if (groupMappings_data) {
                // Haritalama varsa, kağıttaki sırayı göster
                paperOrder = groupMappings_data;
                
                // Orijinal sırayı bul (soru ID'sinden)
                const questionNode = findNodeById(questionId);
                if (questionNode) {
                    questionPoints = questionNode.points || '-';
                    const parent = findNodeById(getParentComponentId(questionId));
                    if (parent && parent.children) {
                        const index = parent.children.findIndex(child => child.id === questionId);
                        originalOrder = index >= 0 ? (index + 1) : '-';
                    }
                }
            } else {
                // Haritalama yoksa, standart sırayı göster
                const questionNode = findNodeById(questionId);
                if (questionNode) {
                    questionPoints = questionNode.points || '-';
                    const parent = findNodeById(getParentComponentId(questionId));
                    if (parent && parent.children) {
                        const index = parent.children.findIndex(child => child.id === questionId);
                        originalOrder = index >= 0 ? (index + 1) : '-';
                        paperOrder = originalOrder; // Haritalama yoksa aynı
                    }
                }
            }
            
            groupMappings.push({
                group: groupId,
                paperOrder: paperOrder,
                originalOrder: originalOrder,
                points: questionPoints
            });
        });
        
        // Kompakt tablo formatında göster
        groupInfoDiv.innerHTML = `
            <div class="compact-header">
                <span class="compact-icon">📊</span>
                <span class="compact-title">Grup Bilgileri</span>
            </div>
            <div class="compact-table">
                <div class="compact-row compact-header-row">
                    <span>Grup</span>
                    <span>Orijinal</span>
                    <span>Kağıt</span>
                    <span>Puan</span>
                </div>
                ${groupMappings.map(mapping => `
                    <div class="compact-row">
                        <span class="group-badge-compact">${mapping.group}</span>
                        <span class="original-info">${mapping.originalOrder}</span>
                        <span class="paper-info">${mapping.paperOrder}</span>
                        <span class="points-info">${mapping.points}</span>
                    </div>
                `).join('')}
            </div>
        `;
        
        return groupInfoDiv;
    } catch (error) {
        console.error("Modern grup bilgileri oluşturulurken hata:", error);
        return null;
    }
}

/**
 * Alt öğe giriş bölümü oluşturma (Soru/Rubrik)
 * @param {Object} subItem - Alt öğe
 * @param {HTMLElement} container - Konteyner elementi
 */
function createSubItemInputSection(subItem, container) {
    try {
        const subDiv = document.createElement('div');
        subDiv.className = 'assessment-subsection';
        
        const parentComponentId = getParentComponentId(subItem.id);
        
        // Başlık
        const header = document.createElement('h5');
        header.innerHTML = `${subItem.name}`;
        subDiv.appendChild(header);
        
        // Bileşendeki tüm soruları al
        const parentNode = findNodeById(parentComponentId);
        const allQuestions = parentNode?.children || [];
        const maxQuestions = allQuestions.length;
        
        // Grup seçeneklerini güvenli şekilde oluştur
        const groups = (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari && APP_STATE.courseData.grupHaritalari[parentComponentId]) 
            ? APP_STATE.courseData.grupHaritalari[parentComponentId].gruplar || ['A']
            : ['A'];
        
        // Grup sistemi her zaman kullanılır (tek grup olsa bile)
        const useGroupSystem = true;
        
        // Kağıt sırası bazında bölümler oluştur
        for (let paperOrder = 1; paperOrder <= maxQuestions; paperOrder++) {
            const paperSection = document.createElement('div');
            paperSection.className = 'paper-order-section';
            
            const paperHeader = document.createElement('h6');
            paperHeader.innerHTML = `Kağıt Sırası ${paperOrder}`;
            paperHeader.className = 'paper-order-header';
            paperSection.appendChild(paperHeader);
            
        const table = document.createElement('table');
            table.className = 'assessment-table paper-order-table';
            
            const tableHTML = `
            <thead>
                <tr>
                    <th>No</th>
                    <th>Öğrenci No</th>
                    <th>Adı</th>
                    <th>Soyadı</th>
                    <th>E-posta</th>
                    ${useGroupSystem ? '<th>Grup</th>' : ''}
                    ${useGroupSystem ? '<th>Cevap Anahtarı Sırası</th>' : ''}
                    ${useGroupSystem ? '<th>Etkinlik Adı<br/><small>(Soru/Rubrik)</small></th>' : ''}
                    ${useGroupSystem ? '<th>Açıklama</th>' : ''}
                    <th>Etkinlik Max. Puan<br/><small>(Soru/Rubrik)</small></th>
                        <th>Toplam Puan</th>
                        ${useGroupSystem ? '<th>ÖÇ</th>' : ''}
                        <th>Alınan Puan<br/><small>(Etkinlik Puanı)</small></th>
                        <th>Yarıyıl İçi<br/><small>(${getTermWeight()}%)</small></th>
                        <th>Yarıyıl Sonu<br/><small>(${getFinalWeight()}%)</small></th>
                        <th>Ortalama</th>
                        <th>Harf Notu</th>
                </tr>
            </thead>
            <tbody>
                    ${APP_STATE.studentData.map((student, index) => {
                        const studentCurrentGroup = getStudentGroupForComponent(student.studentId, parentComponentId);
                        const groupOptions = groups.map(groupId => 
                            `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
                        ).join('');
                        
                        // Bu kağıt sırasındaki sorunun gerçek ID'sini bul
                        const actualQuestionId = getQuestionIdByPaperOrder(student.studentId, paperOrder, parentComponentId);
                        const actualQuestion = findNodeById(actualQuestionId);
                        
                        // Cevap anahtarındaki sırayı bul
                        const answerKeyOrder = getAnswerKeyOrder(student.studentId, paperOrder, parentComponentId);
                        
                        // Etkinlik bilgilerini al - Gerçek etkinlik adını göster
                        const activityName = actualQuestion?.name || `Etkinlik ${answerKeyOrder || paperOrder}`;
                        const questionDescription = actualQuestion?.description || actualQuestion?.name || '-';
                        const questionPointsForGroup = getQuestionPointsForStudentGroup(student.studentId, actualQuestionId, parentComponentId);
                        const maxPoints = questionPointsForGroup || actualQuestion?.points || 0;
                        const studentOutcomes = getQuestionOutcomesForStudent(student.studentId, actualQuestionId, parentComponentId);
                        
                        return `
                            <tr data-student-id="${student.studentId}" data-paper-order="${paperOrder}" data-component-id="${parentComponentId}">
                        <td>${index + 1}</td>
                        <td>${student.studentId}</td>
                        <td>${student.name}</td>
                        <td>${student.surname}</td>
                        <td class="email-cell">
                            <span class="email-text" title="${student.email || 'E-posta bulunamadı'}">${student.email || '-'}</span>
                            ${student.email ? `<button class="email-button" title="E-posta gönder" onclick="openEmailModal({studentId: '${student.studentId}', name: '${student.name}', surname: '${student.surname}', email: '${student.email}'})">E-posta</button>` : ''}
                        </td>
                        ${useGroupSystem ? `
                        <td>
                            <select class="group-selector compact" data-student-id="${student.studentId}" data-component-id="${parentComponentId}" onchange="updateStudentGroupForComponent(this)">
                                ${groupOptions}
                            </select>
                        </td>` : ''}
                        ${useGroupSystem ? `
                        <td class="answer-key-order-cell">
                            <span class="answer-key-badge" data-answer-key="${answerKeyOrder}" data-question-id="${actualQuestionId}">
                                ${answerKeyOrder}
                            </span>
                        </td>` : ''}
                        ${useGroupSystem ? `
                        <td class="question-name-cell">
                            <span class="question-name-badge">${activityName}</span>
                        </td>` : ''}
                        ${useGroupSystem ? `
                        <td class="question-description-cell">
                            <span class="question-desc-badge" title="${questionDescription}">${questionDescription}</span>
                        </td>` : ''}
                        <td class="question-points-cell" data-student-id="${student.studentId}" data-activity-id="${actualQuestionId}">
                            ${maxPoints}
                        </td>
                        <td class="total-points-cell" data-student-id="${student.studentId}" data-component-id="${parentComponentId}">
                            ${getStudentTotalEarnedPointsForComponent(student.studentId, parentComponentId)}
                        </td>
                        ${useGroupSystem ? `
                        <td class="outcomes-cell">
                            <span class="outcomes-badge">${Array.isArray(studentOutcomes) ? studentOutcomes.join(', ') : (studentOutcomes || '-')}</span>
                        </td>` : ''}
                        <td>
                            <input type="number" min="0" max="${maxPoints}" 
                                data-student-id="${student.studentId}" 
                                data-activity-id="${actualQuestionId}"
                                data-paper-order="${paperOrder}"
                                value="${getStudentGrade(student.studentId, actualQuestionId) || ''}"
                                onchange="updateStudentGrade(this)"
                                placeholder="0-${maxPoints}"
                                title="${useGroupSystem ? `Kağıt sırası: ${paperOrder}, Cevap anahtarı: ${answerKeyOrder}, Maksimum puan: ${maxPoints}` : `Maksimum puan: ${maxPoints}`}"
                            >
                        </td>
                        <td class="grade-summary-cell term-grade">${calculateStudentGrades(student.studentId).termGrade}</td>
                        <td class="grade-summary-cell final-grade">${calculateStudentGrades(student.studentId).finalGrade}</td>
                        <td class="grade-summary-cell total-grade">${calculateStudentGrades(student.studentId).totalGrade}</td>
                        <td class="grade-summary-cell letter-grade ${getLetterGradeClass(calculateStudentGrades(student.studentId).letterGrade)}">${calculateStudentGrades(student.studentId).letterGrade}</td>
                    </tr>
                        `;
                    }).join('')}
            </tbody>
        `;
            
            table.innerHTML = tableHTML;
            paperSection.appendChild(table);
            subDiv.appendChild(paperSection);
        }
        
        container.appendChild(subDiv);
        
        // İLK YÜKLEME SONRASI GRUP BAZLI GÜNCELLEMELERİ YAP
        // Her öğrenci için grup bazlı bilgileri güncelle (combobox değişimi simülasyonu)
        if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
            setTimeout(() => {
                console.log('🔄 İlk yükleme sonrası grup bazlı güncellemeler başlatılıyor...');
                APP_STATE.studentData.forEach(student => {
                    const studentGroup = getStudentGroupForComponent(student.studentId, parentComponentId);
                    if (studentGroup) {
                        // Grup değişikliği fonksiyonunu simüle et - sadece soru bilgilerini güncelle
                        updateQuestionInfoForComponent(student.studentId, studentGroup, parentComponentId);
                    }
                });
                console.log('✅ İlk yükleme grup bazlı güncellemeleri tamamlandı');
            }, 100); // Kısa gecikme ile DOM'un hazır olmasını bekle
        }
        
        // GUID sistemi kaldırıldı
    } catch (error) {
        console.error("Alt öğe giriş bölümü oluşturulurken hata oluştu:", error);
    }
}

/**
 * Test giriş modunu değiştirme
 * @param {string} testId - Test ID'si
 * @param {string} mode - Mod (detailed/simple)
 */
function switchTestInputMode(testId, mode) {
    try {
        // Mod butonlarını güncelle
        document.querySelectorAll(`.input-mode[data-test-id="${testId}"]`).forEach(btn => {
            if (btn.dataset.mode === mode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        // Giriş formlarını göster/gizle
        const detailedForm = document.querySelector(`.test-input-form.detailed-mode[data-test-id="${testId}"]`);
        const simpleForm = document.querySelector(`.test-input-form.simple-mode[data-test-id="${testId}"]`);
        
        if (mode === 'detailed') {
            detailedForm.style.display = 'block';
            simpleForm.style.display = 'none';
        } else {
            detailedForm.style.display = 'none';
            simpleForm.style.display = 'block';
        }
    } catch (error) {
        console.error("Test giriş modu değiştirilirken hata oluştu:", error);
    }
}

/**
 * Öğrenci notunu getirme - v5 formatını tam destekler
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} activityId - Etkinlik ID'si
 * @returns {number|null} - Not değeri
 */
function getStudentGrade(studentId, activityId) {
    if (!APP_STATE.gradesData || !APP_STATE.gradesData[studentId]) return null;
    
    const studentGrades = APP_STATE.gradesData[studentId];
    const activity = findNodeById(activityId);
    
    // v5 FORMAT ÖNCELİĞİ: Pozisyon bazlı notları kontrol et
    const parts = activityId.split('.');
    if (parts.length > 1) {
        const parentId = parts[0]; // A1.1 -> A1
        
        if (studentGrades[parentId] && typeof studentGrades[parentId] === 'object') {
            // v5 Format: Pozisyon bazlı erişim (1, 2, 3, 4, 5...)
            for (const position of Object.keys(studentGrades[parentId])) {
                const gradeInfo = studentGrades[parentId][position];
                if (gradeInfo && typeof gradeInfo === 'object' && 
                    gradeInfo.soruId === activityId && gradeInfo.puan !== undefined) {
                    return gradeInfo.puan;
                }
            }
        }
    }
    
    // DURUM 1: Doğrudan erişim (geriye uyumluluk)
    if (studentGrades[activityId] !== undefined) {
        const grade = studentGrades[activityId];
        
        // Sayısal değer
        if (typeof grade === 'number') {
            return grade;
        }
        
        // Test notu (object formatında)
        if (typeof grade === 'object' && grade !== null) {
            // Test tipi
            if (grade.tip === 'test' && activity && activity.type === 'Test') {
                const correct = grade.dogru || 0;
                const wrong = grade.yanlis || 0;
                return correct * (activity.testDetails?.correctWeight || 5) - 
                       wrong * Math.abs(activity.testDetails?.wrongPenalty || 0);
            }
        }
    }
    
    // DURUM 2: İç içe yapı kontrolü (eski format uyumluluğu)
    if (parts.length > 1) {
        const parentId = parts[0]; // A1.1 -> A1
        const shortId = parts[parts.length - 1]; // A1.1 -> 1
        
        if (studentGrades[parentId] && typeof studentGrades[parentId] === 'object') {
            // Tam ID ile erişim
            if (studentGrades[parentId][activityId] !== undefined) {
                // Test notu
                if (typeof studentGrades[parentId][activityId] === 'object' && 
                    studentGrades[parentId][activityId] !== null && 
                    studentGrades[parentId][activityId].tip === 'test') {
                    
                    const testScore = studentGrades[parentId][activityId];
                    const correct = testScore.dogru || 0;
                    const wrong = testScore.yanlis || 0;
                    
                    if (activity && activity.type === 'Test') {
                        return correct * (activity.testDetails?.correctWeight || 5) - 
                               wrong * Math.abs(activity.testDetails?.wrongPenalty || 0);
                    }
                }
                // Normal not
                else if (typeof studentGrades[parentId][activityId] === 'number') {
                    return studentGrades[parentId][activityId];
                }
            }
            
            // Kısa ID ile erişim (A1.1 -> sadece 1)
            if (studentGrades[parentId][shortId] !== undefined) {
                // Test notu
                if (typeof studentGrades[parentId][shortId] === 'object' && 
                    studentGrades[parentId][shortId] !== null && 
                    studentGrades[parentId][shortId].tip === 'test') {
                    
                    const testScore = studentGrades[parentId][shortId];
                    const correct = testScore.dogru || 0;
                    const wrong = testScore.yanlis || 0;
                    
                    if (activity && activity.type === 'Test') {
                        return correct * (activity.testDetails?.correctWeight || 5) - 
                               wrong * Math.abs(activity.testDetails?.wrongPenalty || 0);
                    }
                }
                // Normal not
                else if (typeof studentGrades[parentId][shortId] === 'number') {
                    return studentGrades[parentId][shortId];
                }
            }
        }
    }
    
    return null;
}

/**
 * Aktivite ID'sinden soru numarasını çıkarma
 * @param {string} activityId - Aktivite ID'si (örn: A1.1, A1.2)
 * @returns {string|null} - Soru numarası (örn: "1", "2")
 */
function getQuestionNumberFromActivity(activityId) {
    // A1.1 -> "1", A1.2 -> "2", F1.1 -> "1" 
    const parts = activityId.split('.');
    if (parts.length >= 2) {
        return parts[parts.length - 1]; // Son kısmı al
    }
    return null;
}

/**
 * Aktivite ID'sinden ana bileşen ID'sini çıkarma (örn: A1.1 → A1)
 * @param {string} activityId - Aktivite ID'si
 * @returns {string|null} - Ana bileşen ID'si
 */
// İlk getParentComponentId fonksiyonu kaldırıldı - gelişmiş versiyon korundu

/**
 * Bileşen için grup bilgilerini formatlanmış string olarak getir
 * @param {string} componentId - Ana bileşen ID'si (A1, F1, vb)
 * @param {string} questionId - Soru ID'si
 * @returns {string} - Formatlanmış grup bilgileri
 */
function getComponentGroupInfo(componentId, questionId) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari?.[componentId]) {
            return `Grup Bilgisi: A (Varsayılan grup - hiç grup tanımlanmamış)`;
        }
        
        const componentGroups = APP_STATE.courseData.grupHaritalari[componentId];
        const groups = componentGroups.gruplar || ['A'];
        const mappings = componentGroups.haritalar || {};
        
        let infoText = `Gruplar: ${groups.join(', ')}\n`;
        
        // Her grup için bu sorunun haritalama bilgisini göster
        groups.forEach(groupName => {
            if (mappings[groupName]) {
                // DÜZELTME: Veri yapısı {position: questionId} formatında
                const position = Object.keys(mappings[groupName]).find(pos => mappings[groupName][pos] === questionId);
                if (position) {
                    infoText += `Grup ${groupName}: Soru ${position} | `;
                } else {
                    infoText += `Grup ${groupName}: Haritalanmamış | `;
                }
            } else {
                infoText += `Grup ${groupName}: Haritalanmamış | `;
            }
        });
        
        // Son | karakterini kaldır
        if (infoText.endsWith(' | ')) {
            infoText = infoText.slice(0, -3);
        }
        
        return infoText;
    } catch (error) {
        console.error("Grup bilgileri oluşturulurken hata:", error);
        return "Grup bilgisi yüklenirken hata oluştu";
    }
}

/**
 * Öğrencinin grubuna göre belirli bir sorunun puanını getir
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} activityId - Aktivite ID'si
 * @param {string} componentId - Bileşen ID'si
 * @returns {number} - Sorunun puanı
 */
function getQuestionPointsForStudentGroup(studentId, activityId, componentId) {
    try {
        const studentGroup = getStudentGroupForComponent(studentId, componentId);
        
        console.log(`🔍 getQuestionPointsForStudentGroup DEBUG:`);
        console.log(`  - studentId: ${studentId}`);
        console.log(`  - activityId: ${activityId}`);
        console.log(`  - componentId: ${componentId}`);
        console.log(`  - studentGroup: ${studentGroup}`);
        
        // Grup haritalama verilerini al
        const componentGroupData = APP_STATE.courseData?.grupHaritalari?.[componentId];
        if (!componentGroupData || !componentGroupData.haritalar || !componentGroupData.haritalar[studentGroup]) {
            // Grup haritalama yoksa, sorunun orijinal puanını döndür
            const activity = findNodeById(activityId);
            console.log(`  - Grup haritalama yok, orijinal puan: ${activity ? activity.points : 0}`);
            return activity ? activity.points : 0;
        }
        
        // Bu öğrencinin grubundaki bu sorunun kağıt üzerindeki sırasını bul
        // Grup haritalama formatı kontrol et: {position: questionId} VEYA {questionId: position}
        const groupMappings = componentGroupData.haritalar[studentGroup];
        let paperQuestionOrder = null;
        
        console.log(`  - groupMappings:`, groupMappings);
        
        // Format 1: {position: questionId} - Doğru position değerini bul
        if (Object.values(groupMappings).includes(activityId)) {
            const position = Object.keys(groupMappings).find(pos => groupMappings[pos] === activityId);
            paperQuestionOrder = parseInt(position);
            console.log(`  - Format 1 kullanıldı, position: ${position}, paperQuestionOrder: ${paperQuestionOrder}`);
        }
        // Format 2: {questionId: position} - Eski format
        else if (groupMappings[activityId]) {
            paperQuestionOrder = parseInt(groupMappings[activityId]);
            console.log(`  - Format 2 kullanıldı, paperQuestionOrder: ${paperQuestionOrder}`);
        }
        
        if (!paperQuestionOrder) {
            // Haritalama yoksa, sorunun orijinal puanını döndür
            const activity = findNodeById(activityId);
            console.log(`  - PaperQuestionOrder bulunamadı, orijinal puan: ${activity ? activity.points : 0}`);
            return activity ? activity.points : 0;
        }
        
        // Aynı bileşendeki tüm soruları al ve sırala
        const component = findNodeById(componentId);
        if (!component || !component.children) {
            const activity = findNodeById(activityId);
            return activity ? activity.points : 0;
        }
        
        // Soruları orijinal sıralarına göre sırala
        const questions = component.children
            .filter(child => isQuestionType(child.type) || isRubricType(child.type))
            .sort((a, b) => {
                const aNum = parseInt(a.id.split('.').pop());
                const bNum = parseInt(b.id.split('.').pop());
                return aNum - bNum;
            });
        
        // Kağıt sırasındaki sorunun puanını al
        if (paperQuestionOrder >= 1 && paperQuestionOrder <= questions.length) {
            const targetQuestion = questions[paperQuestionOrder - 1]; // Array 0-indexed
            return targetQuestion.points;
        }
        
        // Hata durumunda orijinal sorunun puanını döndür
        const activity = findNodeById(activityId);
        return activity ? activity.points : 0;
        
    } catch (error) {
        console.error("Grup bazlı etkinlik max puanı hesaplanırken hata:", error);
        const activity = findNodeById(activityId);
        return activity ? activity.points : 0;
    }
}

/**
 * Grup bazlı not hesaplama
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} activityId - Aktivite ID'si
 * @param {number} rawScore - Ham puan
 * @returns {number} - Hesaplanan not
 */
function calculateGradeBasedOnGroup(studentId, activityId, rawScore) {
    const studentGroup = getStudentGroup(studentId);
    
    // Önce bu aktivitenin hangi değerlendirme bileşenine ait olduğunu bul
    const parentComponentId = getParentComponentId(activityId);
    if (!parentComponentId) {
        return rawScore;
    }
    
    // Bu değerlendirme bileşeninin grup haritasını al
    const componentGroupData = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!componentGroupData || !componentGroupData.haritalar || !componentGroupData.haritalar[studentGroup]) {
        return rawScore;
    }
    
    // DÜZELTME: Veri yapısı {position: questionId} formatında
    const groupMappings = componentGroupData.haritalar[studentGroup];
    const position = Object.keys(groupMappings).find(pos => groupMappings[pos] === activityId);
    
    // Eğer bu aktivite için grup haritası yoksa, ham puanı döndür
    if (!position) {
        return rawScore;
    }
    
    console.log(`Grup bazlı hesaplama: Öğrenci ${studentId} (Grup: ${studentGroup}), Aktivite ${activityId} → Soru ${position}`);
    
    // Ham puanlardan doğru sıradaki puanı al
    const hamPuanlar = APP_STATE.gradesData[studentId]?.hamPuanlar;
    if (hamPuanlar && hamPuanlar[position]) {
        return hamPuanlar[position];
    }
    
    return rawScore;
}

/**
 * Grup değiştiğinde öğrencinin tüm notlarını yeniden hesapla
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} newGroupId - Yeni grup ID'si
 */
function recalculateGradesForGroupChange(studentId, newGroupId) {
    if (!APP_STATE.gradesData[studentId] || !APP_STATE.gradesData[studentId].hamPuanlar) {
        console.log(`Öğrenci ${studentId} için ham puan verisi bulunamadı`);
        return;
    }
    
    const hamPuanlar = APP_STATE.gradesData[studentId].hamPuanlar;
    console.log(`Grup değişimi: Öğrenci ${studentId} → Grup ${newGroupId}. Ham puanlar:`, hamPuanlar);
    
    // Tüm aktiviteler için notları yeniden hesapla
    const allActivities = getAllQuestionActivities();
    
    allActivities.forEach(activityId => {
        const questionNumber = getQuestionNumberFromActivity(activityId);
        if (questionNumber && hamPuanlar[questionNumber]) {
            const rawScore = hamPuanlar[questionNumber];
            const calculatedGrade = calculateGradeBasedOnGroup(studentId, activityId, rawScore);
            
            // Hesaplanan notu güncelle
            APP_STATE.gradesData[studentId][activityId] = calculatedGrade;
            
            console.log(`Yeniden hesaplama: ${activityId} → Ham: ${rawScore}, Hesaplanan: ${calculatedGrade}`);
            
            // UI'daki input alanlarını güncelle
            const inputs = document.querySelectorAll(`input[data-student-id="${studentId}"][data-activity-id="${activityId}"]`);
            inputs.forEach(input => {
                input.value = calculatedGrade;
            });
        }
    });
    
    console.log(`Öğrenci ${studentId} için grup bazlı notlar yeniden hesaplandı`);
}

/**
 * Tüm soru aktivitelerini getir
 * @returns {Array<string>} - Aktivite ID'leri
 */
function getAllQuestionActivities() {
    const activities = [];
    
    function collectActivities(nodes) {
        nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                collectActivities(node.children);
            } else if (isQuestionType(node.type)) {
                activities.push(node.id);
            }
        });
    }
    
    collectActivities(APP_STATE.assessmentTree);
    return activities;
}

/**
 * Tüm öğrenciler için grup bazlı hesaplama yap (JSON import sonrası)
 */
function recalculateAllGradesBasedOnGroups() {
    if (!APP_STATE.studentData || !APP_STATE.gradesData) {
        console.log('Öğrenci verileri veya not verileri bulunamadı');
        return;
    }
    
    console.log('Tüm öğrenciler için grup bazlı hesaplama başlatılıyor...');
    
    APP_STATE.studentData.forEach(student => {
        const studentId = student.studentId;
        const studentGrades = APP_STATE.gradesData[studentId];
        
        if (!studentGrades) {
            console.log(`Öğrenci ${studentId} için not verisi bulunamadı`);
            return;
        }
        
        // Eğer ham puanlar varsa, grup bazlı hesaplama yap
        if (studentGrades.hamPuanlar) {
            console.log(`Öğrenci ${studentId} için ham puanlar bulundu:`, studentGrades.hamPuanlar);
            recalculateGradesForGroupChange(studentId, student.grup);
        } else {
            // Ham puanlar yoksa, mevcut notlardan ham puanları çıkarmaya çalış
            console.log(`Öğrenci ${studentId} için ham puanlar bulunamadı, mevcut notlardan çıkarılmaya çalışılıyor`);
            extractRawScoresFromExistingGrades(studentId);
        }
    });
    
    console.log('Grup bazlı hesaplama tamamlandı');
}

/**
 * Mevcut notlardan ham puanları çıkarma (geriye dönük uyumluluk)
 * @param {string} studentId - Öğrenci ID'si
 */
function extractRawScoresFromExistingGrades(studentId) {
    const studentGrades = APP_STATE.gradesData[studentId];
    if (!studentGrades) return;
    
    // Ham puanlar objesi oluştur
    if (!studentGrades.hamPuanlar) {
        studentGrades.hamPuanlar = {};
    }
    
    // Tüm aktiviteler için ham puanları çıkar
    const allActivities = getAllQuestionActivities();
    
    allActivities.forEach(activityId => {
        const grade = studentGrades[activityId];
        const questionNumber = getQuestionNumberFromActivity(activityId);
        
        if (grade !== undefined && questionNumber && !studentGrades.hamPuanlar[questionNumber]) {
            // Mevcut notu ham puan olarak kabul et
            if (typeof grade === 'number') {
                studentGrades.hamPuanlar[questionNumber] = grade;
                console.log(`Ham puan çıkarıldı: Öğrenci ${studentId}, Soru ${questionNumber} = ${grade}`);
            }
        }
    });
    
    // Ham puanlar çıkarıldıktan sonra grup bazlı hesaplama yap
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    if (student) {
        recalculateGradesForGroupChange(studentId, student.grup);
    }
}

/**
 * Öğrenci test notunu getirme
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} testId - Test ID'si
 * @returns {Object|null} - Test notları
 */
function getStudentTestScore(studentId, testId) {
    if (!APP_STATE.gradesData[studentId] || !APP_STATE.gradesData[studentId][testId]) return null;
    
    const testGrade = APP_STATE.gradesData[studentId][testId];
    if (testGrade.type === 'test' || testGrade.tip === 'test') {
        return {
            type: 'test',
            correct: testGrade.correct || testGrade.dogru || 0,
            wrong: testGrade.wrong || testGrade.yanlis || 0
        };
    }
    
    // Test değilse null dön
    return null;
}

/**
 * Öğrenci notunu güncelleme - Ham puan saklama sistemi
 * @param {HTMLInputElement} input - Not input elementi
 */
function updateStudentGrade(input) {
    try {
        const studentId = input.dataset.studentId;
        const activityId = input.dataset.activityId;
        
        // Aktiviteyi bul ve maksimum puanını kontrol et
        const activity = findNodeById(activityId);
        if (!activity) {
            console.error(`Aktivite bulunamadı: ${activityId}`);
            return;
        }
        
        // Maksimum puan kontrolü
        const maxPoints = activity.points || 100;
        let value = parseFloat(input.value) || 0;
        
        // Maksimum puanı aşan değerleri sınırla
        if (value > maxPoints) {
            value = maxPoints;
            input.value = maxPoints;
            showModernToast(`Dikkat: Puan ${maxPoints} değerinden büyük olamaz!`, "warning");
        }
        
        // Öğrenci verisi oluştur
        if (!APP_STATE.gradesData[studentId]) {
            APP_STATE.gradesData[studentId] = {};
        }
        
        // v5 FORMAT: Pozisyon bazlı not saklama
        const parts = activityId.split('.');
        if (parts.length > 1) {
            const parentId = parts[0]; // A1.1 -> A1
            const componentId = getParentComponentId(activityId);
            
            // Öğrencinin bu bileşendeki grubunu al
            const studentGroup = getStudentGroupForComponent(studentId, componentId);
            
            // v5 format yapısını oluştur
            if (!APP_STATE.gradesData[studentId][parentId]) {
                APP_STATE.gradesData[studentId][parentId] = {};
            }
            
            // Kağıt pozisyonunu bul
            const activity_parent = findNodeById(parentId);
            if (activity_parent && activity_parent.children) {
                const questionIndex = activity_parent.children.findIndex(child => child.id === activityId);
                if (questionIndex !== -1) {
                    const position = (questionIndex + 1).toString();
                    
                    // v5 format: pozisyon bazlı kayıt
                    APP_STATE.gradesData[studentId][parentId][position] = {
                        puan: value,
                        soruId: activityId
                    };
                    
                    console.log(`v5 format not kaydedildi: Öğrenci ${studentId}, Pozisyon ${position}, Soru ${activityId} = ${value} puan`);
                }
            }
        }
        
        // Geriye uyumluluk için doğrudan erişim de sağla
        APP_STATE.gradesData[studentId][activityId] = value;
        
        // Test mi kontrol et
        if (activity && activity.type === 'Test') {
            // Test skorları için özel işlem
            const correctWeight = activity.testDetails?.correctWeight || 5;
            const wrongPenalty = Math.abs(activity.testDetails?.wrongPenalty || 0);
            
            // Basit yaklaşım: tüm puanı doğru sorudan gelecek şekilde ayarla
            const correctEstimate = Math.round(value / correctWeight);
            
            APP_STATE.gradesData[studentId][activityId] = {
                tip: 'test',
                dogru: correctEstimate,
                yanlis: 0
            };
            
            // Detaylı formdaki değerleri güncelle (varsa)
            const correctInput = document.querySelector(`input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="correct"]`);
            const wrongInput = document.querySelector(`input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="wrong"]`);
            
            if (correctInput) correctInput.value = correctEstimate;
            if (wrongInput) wrongInput.value = 0;
            
            // Öğrenci bazlı görünümdeki inputları da güncelle
            const studentViewCorrectInput = document.querySelector(`#studentGradesContainer input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="correct"]`);
            const studentViewWrongInput = document.querySelector(`#studentGradesContainer input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="wrong"]`);
            const studentViewTotalElement = document.querySelector(`#studentGradesContainer .student-test-item[data-subitem-id="${activityId}"] .total-test-score`);
            
            if (studentViewCorrectInput) studentViewCorrectInput.value = correctEstimate;
            if (studentViewWrongInput) studentViewWrongInput.value = 0;
            if (studentViewTotalElement) studentViewTotalElement.textContent = value.toFixed(2);
            
        } else {
            // Normal not için
            APP_STATE.gradesData[studentId][activityId] = value;
            
            // Alt düğüm yapısını oluştur (A1.1 -> A1 altında storlama)
            const parts = activityId.split('.');
            if (parts.length > 1) {
                const parentId = parts[0]; // A1
                const shortId = parts[parts.length - 1]; // 1
                
                // Eğer üst aktivite yoksa oluştur
                if (!APP_STATE.gradesData[studentId][parentId]) {
                    APP_STATE.gradesData[studentId][parentId] = {
                        toplam: 0
                    };
                }
                
                // Not değerini ekle - hem tam ID, hem kısa ID olarak
                APP_STATE.gradesData[studentId][parentId][activityId] = value;
                APP_STATE.gradesData[studentId][parentId][shortId] = value;
                
                // Toplama hesapla
                updateParentActivityTotal(studentId, parentId);
            }
            
            // Öğrenci bazlı görünümdeki inputu güncelle
            const studentViewInput = document.querySelector(`#studentGradesContainer input[data-student-id="${studentId}"][data-activity-id="${activityId}"]`);
            if (studentViewInput && studentViewInput !== input) {
                studentViewInput.value = value;
            }
        }
        
        // Notları hesapla
        updateStudentCalculatedGrade(studentId);
        
        // Assessment tablosundaki not özeti hücrelerini güncelle
        updateAssessmentGradeSummary(studentId);
        
        // Öğrenci özet bilgilerini güncelle
        updateStudentSummary(studentId);
        
        // Toplam puan hücrelerini güncelle
        updateTotalPointsForStudent(studentId, activityId);
        
    } catch (error) {
        console.error("Öğrenci notu güncellenirken hata oluştu:", error);
        showModernToast("Not güncellenirken hata oluştu!", "error");
    }
}

/**
 * Tüm öğrencilerin final notlarını hesapla ve kaydet
 */
function calculateFinalGrades() {
    try {
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            return;
        }
        
        // Her öğrenci için notları hesapla
        APP_STATE.studentData.forEach(student => {
            const studentId = student.studentId;
            
            if (!APP_STATE.gradesData[studentId]) {
                APP_STATE.gradesData[studentId] = {};
            }
            
            // Yarıyıl içi etkinlikler
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            let termGrade = 0;
            
            // İç ağırlık toplamı
            const termInternalTotal = termActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
            
            if (termInternalTotal > 0) {
                termActivities.forEach(activity => {
                    // İç ağırlık normalleştirmesi
                    const activityWeight = activity.weight / termInternalTotal; 
                    let activityGrade = 0;
                    
                    if (activity.children && activity.children.length > 0) {
                        // Alt etkinlikler
                        const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                        
                        if (childrenTotalWeight > 0) {
                            activity.children.forEach(subItem => {
                                // Alt öğe ağırlık normalleştirmesi
                                const subItemWeight = subItem.weight / childrenTotalWeight; 
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                                const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                                activityGrade += scaledGrade * subItemWeight;
                            });
                        }
                    } else {
                        // Basit etkinlik
                        const grade = getStudentGrade(studentId, activity.id) || 0;
                        activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                    }
                    
                    termGrade += activityGrade * activityWeight;
                });
            }
            
            // Yarıyıl sonu etkinlikler
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            let finalGrade = 0;
            
            // İç ağırlık toplamı
            const finalInternalTotal = finalActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
            
            if (finalInternalTotal > 0) {
                finalActivities.forEach(activity => {
                    // İç ağırlık normalleştirmesi
                    const activityWeight = activity.weight / finalInternalTotal;
                    let activityGrade = 0;
                    
                    if (activity.children && activity.children.length > 0) {
                        // Alt etkinlikler
                        const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                        
                        if (childrenTotalWeight > 0) {
                            activity.children.forEach(subItem => {
                                // Alt öğe ağırlık normalleştirmesi
                                const subItemWeight = subItem.weight / childrenTotalWeight;
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                                const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                                activityGrade += scaledGrade * subItemWeight;
                            });
                        }
                    } else {
                        // Basit etkinlik
                        const grade = getStudentGrade(studentId, activity.id) || 0;
                        activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                    }
                    
                    finalGrade += activityGrade * activityWeight;
                });
            }
            
            // Toplam ve harf notu
            const totalGrade = (termGrade * APP_STATE.termWeight / 100) + (finalGrade * APP_STATE.finalWeight / 100);
            const letterGrade = getLetterGrade(totalGrade);
            
            // Notları kaydet
            APP_STATE.gradesData[studentId].yariyilIciNotu = parseFloat(termGrade.toFixed(2));
            APP_STATE.gradesData[studentId].yariyilSonuNotu = parseFloat(finalGrade.toFixed(2));
            APP_STATE.gradesData[studentId].basariNotu = parseFloat(totalGrade.toFixed(2));
            APP_STATE.gradesData[studentId].harfNotu = letterGrade;
        });
        
    } catch (error) {
        console.error("Final notları hesaplanırken hata oluştu:", error);
    }
}

/**
 * Tek bir öğrencinin hesaplanmış notlarını güncelleme
 * @param {string} studentId - Öğrenci ID'si
 */
function updateStudentCalculatedGrade(studentId) {
    try {
        if (!APP_STATE.gradesData[studentId]) {
            return;
        }
        
        // Yarıyıl içi etkinlikler
        const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
        let termGrade = 0;
        
        // İç ağırlık toplamı
        const termInternalTotal = termActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        
        if (termInternalTotal > 0) {
            termActivities.forEach(activity => {
                // İç ağırlık normalleştirmesi
                const activityWeight = activity.weight / termInternalTotal; 
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler
                    const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                    
                    if (childrenTotalWeight > 0) {
                        activity.children.forEach(subItem => {
                            // Alt öğe ağırlık normalleştirmesi
                            const subItemWeight = subItem.weight / childrenTotalWeight; 
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                            const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                            activityGrade += scaledGrade * subItemWeight;
                        });
                    }
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                }
                
                termGrade += activityGrade * activityWeight;
            });
        }
        
        // Yarıyıl sonu etkinlikler
        const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
        let finalGrade = 0;
        
        // İç ağırlık toplamı
        const finalInternalTotal = finalActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
        
        if (finalInternalTotal > 0) {
            finalActivities.forEach(activity => {
                // İç ağırlık normalleştirmesi
                const activityWeight = activity.weight / finalInternalTotal;
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler
                    const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                    
                    if (childrenTotalWeight > 0) {
                        activity.children.forEach(subItem => {
                            // Alt öğe ağırlık normalleştirmesi
                            const subItemWeight = subItem.weight / childrenTotalWeight;
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                            const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                            activityGrade += scaledGrade * subItemWeight;
                        });
                    }
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                }
                
                finalGrade += activityGrade * activityWeight;
            });
        }
        
        // Toplam ve harf notu
        const totalGrade = (termGrade * APP_STATE.termWeight / 100) + (finalGrade * APP_STATE.finalWeight / 100);
        const letterGrade = getLetterGrade(totalGrade);
        
        // Hesaplanmış not bilgilerini ekle
        APP_STATE.gradesData[studentId].yariyilIciNotu = parseFloat(termGrade.toFixed(2));
        APP_STATE.gradesData[studentId].yariyilSonuNotu = parseFloat(finalGrade.toFixed(2));
        APP_STATE.gradesData[studentId].basariNotu = parseFloat(totalGrade.toFixed(2));
        APP_STATE.gradesData[studentId].harfNotu = letterGrade;
        
    } catch (error) {
        console.error("Öğrenci notu hesaplanırken hata oluştu:", error);
    }
}

/**
 * Test skorunu güncelleme
 * @param {HTMLInputElement} input - Test skoru input elementi
 */
function updateTestScore(input) {
    try {
        const studentId = input.dataset.studentId;
        const testId = input.dataset.testId;
        const field = input.dataset.field;
        const value = parseInt(input.value) || 0;
        
        // Test verisini güncelle
        updateTestScoreData(studentId, testId, field, value);
        
        // İlgili görünüm alanlarını güncelle
        updateTestScoreViews(studentId, testId, field, value, input);
        
        // Test sorularına rastgele doğru/yanlış dağılımı yap
        const testScore = APP_STATE.gradesData[studentId][testId];
        if (testScore && (field === 'correct' || field === 'wrong')) {
            // Doğru/yanlış değeri değiştiğinde modern test skoru dağıtım modalını göster
            showTestScoreDistributionModal(studentId, testId);
        }
    } catch (error) {
        console.error("Test skoru güncellenirken hata oluştu:", error);
        showModernToast("Test skoru güncellenirken hata oluştu!", "error");
    }
}

// Test score görünümlerini güncelleme (yardımcı fonksiyon)
function updateTestScoreViews(studentId, testId, field, value, sourceInput) {
    const testNode = findNodeById(testId);
    if (!testNode) return;
    
    const testScore = APP_STATE.gradesData[studentId][testId];
    const correct = testScore.dogru || 0;
    const wrong = testScore.yanlis || 0;
    const correctWeight = testNode.testDetails.correctWeight;
    const wrongPenalty = Math.abs(testNode.testDetails.wrongPenalty);
    const totalScore = correct * correctWeight - wrong * wrongPenalty;
    
    // Değerlendirme sekmesindeki toplam puan hücresini güncelle
    const assessmentRow = document.querySelector(`tr:has(input[data-student-id="${studentId}"][data-test-id="${testId}"])`);
    const assessmentTotalScore = assessmentRow?.querySelector('.total-score');
    if (assessmentTotalScore) {
        assessmentTotalScore.textContent = totalScore.toFixed(2);
    }
    
    // Basit giriş formundaki değeri de güncelle
    const simpleInput = document.querySelector(`input[data-student-id="${studentId}"][data-activity-id="${testId}"]`);
    if (simpleInput) {
        simpleInput.value = totalScore.toFixed(2);
    }
    
    // Öğrenci görünümündeki ilgili alanları güncelle
    if (field === 'correct' || field === 'wrong') {
        // Karşılık gelen inputu bul ve güncelle (kendisi değilse)
        const studentViewInput = document.querySelector(`#studentGradesContainer input[data-student-id="${studentId}"][data-test-id="${testId}"][data-field="${field}"]`);
        if (studentViewInput && studentViewInput !== sourceInput) {
            studentViewInput.value = value;
        }
    }
    
    // Öğrenci görünümündeki toplam skoru güncelle
    updateStudentViewTestTotal(studentId, testId);
    
    // Notları yeniden hesapla
    updateStudentCalculatedGrade(studentId);
    
    // Öğrenci özet bilgilerini güncelle
    updateStudentSummary(studentId);
    
    // Assessment tablosundaki not özeti hücrelerini güncelle
    updateAssessmentGradeSummary(studentId);
        
        // Assessment tablosundaki not özeti hücrelerini güncelle
        updateAssessmentGradeSummary(studentId);
}

/**
 * Notları hesaplama ve görüntüleme
 */
function calculateGrades() {
    try {
        if (!APP_STATE.gradesData || Object.keys(APP_STATE.gradesData).length === 0) {
            showModernToast("Henüz not girişi yapılmamış!", "warning");
            return;
        }
        
        // Tüm notları hesapla
        calculateFinalGrades();
        
        // Notlar tablosunu göster
        const finalGrades = {};
        
        APP_STATE.studentData.forEach(student => {
            const studentId = student.studentId;
            if (!APP_STATE.gradesData[studentId]) {
                finalGrades[studentId] = {
                    studentId,
                    name: student.name,
                    surname: student.surname,
                    termGrade: 0,
                    finalGrade: 0,
                    totalGrade: 0,
                    letterGrade: 'FF'
                };
                return;
            }
            
            finalGrades[studentId] = {
                studentId,
                name: student.name,
                surname: student.surname,
                termGrade: APP_STATE.gradesData[studentId].yariyilIciNotu || 0,
                finalGrade: APP_STATE.gradesData[studentId].yariyilSonuNotu || 0,
                totalGrade: APP_STATE.gradesData[studentId].basariNotu || 0,
                letterGrade: APP_STATE.gradesData[studentId].harfNotu || 'FF'
            };
        });

        // Notlar sekmesine geç
        switchTab('grades');
        
        // Notlar tablosunu güncelle
        updateGradesTable(finalGrades);
        
        // İstatistikleri güncelle
        updateGradeStatistics(finalGrades);
        
        showModernToast("Notlar başarıyla hesaplandı.");
    } catch (error) {
        console.error("Notlar hesaplanırken hata oluştu:", error);
        showModernToast("Notlar hesaplanırken hata oluştu!", "error");
    }
}

/**
 * Notlar tablosunu güncelleme
 * @param {Object} finalGrades - Hesaplanan son notlar
 */
function updateGradesTable(finalGrades) {
    try {
        const tableBody = document.createElement('tbody');
        
        APP_STATE.studentData.forEach((student, index) => {
            const studentGrade = finalGrades[student.studentId] || {
                termGrade: 0,
                finalGrade: 0,
                totalGrade: 0,
                letterGrade: 'FF'
            };
            
            const row = document.createElement('tr');
            
            // Geçme/kalma durumuna göre satır stilini belirle
            const letterGrade = studentGrade.letterGrade;
            if (['AA', 'BA', 'BB', 'CB', 'CC'].includes(letterGrade)) {
                row.style.backgroundColor = 'rgba(40, 167, 69, 0.1)'; // Başarılı
            } else if (['DC', 'DD'].includes(letterGrade)) {
                row.style.backgroundColor = 'rgba(255, 193, 7, 0.1)'; // Koşullu başarılı
            } else {
                row.style.backgroundColor = 'rgba(220, 53, 69, 0.1)'; // Başarısız
            }
            
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${student.studentId}</td>
                <td>${student.name}</td>
                <td>${student.surname}</td>
                <td>${studentGrade.termGrade}</td>
                <td>${studentGrade.finalGrade}</td>
                <td>${studentGrade.totalGrade}</td>
                <td>${studentGrade.letterGrade}</td>
            `;
            tableBody.appendChild(row);
        });
        
        // Tabloyu güncelle - genel ağırlıkları da göster
        gradesTable.innerHTML = `
            <thead>
                <tr>
                    <th>No</th>
                    <th>Öğrenci No</th>
                    <th>Adı</th>
                    <th>Soyadı</th>
                    <th>Yarıyıl İçi (${APP_STATE.termWeight}%)</th>
                    <th>Yarıyıl Sonu (${APP_STATE.finalWeight}%)</th>
                    <th>Toplam Puan</th>
                    <th>Harf Notu</th>
                </tr>
            </thead>
        `;
        gradesTable.appendChild(tableBody);
    } catch (error) {
        console.error("Notlar tablosu güncellenirken hata oluştu:", error);
    }
}

/**
 * Not istatistiklerini güncelleme
 * @param {Object} finalGrades - Hesaplanan son notlar
 */
function updateGradeStatistics(finalGrades) {
    try {
        const grades = Object.values(finalGrades);
        
        // Ortalama hesapla
        const totalSum = grades.reduce((sum, grade) => sum + parseFloat(grade.totalGrade), 0);
        const average = totalSum / grades.length;
        
        // Harf notları dağılımı
        const letterGradeCounts = {};
        grades.forEach(grade => {
            const letter = grade.letterGrade;
            letterGradeCounts[letter] = (letterGradeCounts[letter] || 0) + 1;
        });
        
        // Geçme/kalma oranı
        const passingLetters = ['AA', 'BA', 'BB', 'CB', 'CC', 'DC', 'DD'];
        const passingCount = grades.filter(grade => passingLetters.includes(grade.letterGrade)).length;
        const failingCount = grades.length - passingCount;
        const passRate = (passingCount / grades.length) * 100;
        
        // İstatistikleri göster
        statsContent.innerHTML = `
            <div class="stats-grid">
                <div class="stats-card">
                    <h5>Genel İstatistikler</h5>
                    <p>Sınıf Mevcudu: <strong>${grades.length}</strong> öğrenci</p>
                    <p>Sınıf Ortalaması: <strong>${average.toFixed(2)}</strong></p>
                    <p>Geçen Öğrenci Sayısı: <strong>${passingCount}</strong> (${passRate.toFixed(2)}%)</p>
                    <p>Kalan Öğrenci Sayısı: <strong>${failingCount}</strong> (${(100 - passRate).toFixed(2)}%)</p>
                </div>
                
                <div class="stats-card">
                    <h5>Harf Notu Dağılımı</h5>
                    <ul class="grade-distribution">
                        ${Object.entries(letterGradeCounts).sort().map(([letter, count]) => {
                            // Harf notuna göre renk belirle
                            let colorClass = '';
                            if (['AA', 'BA', 'BB'].includes(letter)) {
                                colorClass = 'grade-high';
                            } else if (['CB', 'CC'].includes(letter)) {
                                colorClass = 'grade-mid';
                            } else if (['DC', 'DD'].includes(letter)) {
                                colorClass = 'grade-low';
                            } else {
                                colorClass = 'grade-fail';
                            }
                            
                            return `
                                <li class="${colorClass}">
                                    <span class="grade-letter">${letter}</span>
                                    <span class="grade-count">${count} öğrenci</span>
                                    <span class="grade-percent">(${((count / grades.length) * 100).toFixed(2)}%)</span>
                                    <div class="grade-bar" style="width: ${(count / grades.length) * 100}%"></div>
                                </li>
                            `;
                        }).join('')}
                    </ul>
                </div>
            </div>
        `;
        
        // Grafik oluştur (eğer Chart.js kütüphanesi yüklenmişse)
        if (window.Chart) {
            chartContainer.innerHTML = '<canvas id="gradeChart"></canvas>';
            const ctx = document.getElementById('gradeChart').getContext('2d');
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(letterGradeCounts).sort(),
                    datasets: [{
                        data: Object.values(letterGradeCounts).sort((a, b) => b - a),
                        backgroundColor: [
                            'rgba(40, 167, 69, 0.8)', // AA
                            'rgba(40, 167, 69, 0.6)', // BA
                            'rgba(40, 167, 69, 0.4)', // BB
                            'rgba(23, 162, 184, 0.8)', // CB
                            'rgba(23, 162, 184, 0.6)', // CC
                            'rgba(255, 193, 7, 0.8)', // DC
                            'rgba(255, 193, 7, 0.6)', // DD
                            'rgba(220, 53, 69, 0.8)', // FD
                            'rgba(220, 53, 69, 0.6)'  // FF
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    legend: {
                        position: 'right',
                    },
                    title: {
                        display: true,
                        text: 'Harf Notu Dağılımı'
                    }
                }
            });
        }
    } catch (error) {
        console.error("Not istatistikleri güncellenirken hata oluştu:", error);
    }
}

// =====================================================
// ÖĞRENCİ VERİLERİ FONKSIYONLARI
// =====================================================

/**
 * Öğrenci tablosunu güncelleme
 */
function updateStudentTable() {
    try {
        const tableHeader = document.createElement('tr');
        tableHeader.innerHTML = `
            <th>No</th>
            <th>Öğrenci No</th>
            <th>Adı</th>
            <th>Soyadı</th>
            <th>Durum</th>
        `;
        
        const tableBody = document.createElement('tbody');
        tableBody.appendChild(tableHeader);
        
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            const emptyRow = document.createElement('tr');
            emptyRow.innerHTML = `<td colspan="5" class="empty-message">Öğrenci listesi yüklenmedi</td>`;
            tableBody.appendChild(emptyRow);
        } else {
            APP_STATE.studentData.forEach((student, index) => {
                const row = document.createElement('tr');
                
                // Duruma göre satır stili
                if (student.status === 'İlişiği Kesilmiş') {
                    row.style.color = 'var(--text-light)';
                    row.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                }
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${student.studentId}</td>
                    <td>${student.name}</td>
                    <td>${student.surname}</td>
                    <td>${student.status || 'Aktif'}</td>
                `;
                tableBody.appendChild(row);
            });
        }
        
        studentTable.innerHTML = '';
        studentTable.appendChild(tableBody);
        
        // Grup sistemini başlat
        initializeGroupSystem();
        
        // ÖÇ tooltip sistemini başlat
        initializeOutcomeTooltips();
        
        // Default grup atamasını yap
        assignDefaultGroups();
        
        // Öğrenci grup bilgilerini güncelle
        updateStudentGroupInfoDisplay();
        
        // Debug: Grup atamalarını konsola yazdır
        debugGroupAssignments();
        
        // Öğrenci filtresi seçeneklerini güncelle
        updateAssessmentStudentFilterOptions();
        
        // Değerlendirme görünümünü güncelle
        updateAssessmentView();
    } catch (error) {
        console.error("Öğrenci tablosu güncellenirken hata oluştu:", error);
        showModernToast("Öğrenci tablosu güncellenemedi!", "error");
    }
}

/**
 * Öğrenci grup bilgilerini gösterme
 */
function updateStudentGroupInfoDisplay() {
    try {
        const studentGroupInfoCard = document.getElementById('studentGroupInfoCard');
        const studentGroupInfoContainer = document.getElementById('studentGroupInfoContainer');
        
        if (!studentGroupInfoCard || !studentGroupInfoContainer) {
            return;
        }
        
        // Öğrenci verisi yoksa kartı gizle
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            studentGroupInfoCard.style.display = 'none';
            return;
        }
        
        // Grup bilgisi yoksa basit mesaj göster
        if (!APP_STATE.courseData?.grupHaritalari || Object.keys(APP_STATE.courseData.grupHaritalari).length === 0) {
            studentGroupInfoCard.style.display = 'block';
            studentGroupInfoContainer.innerHTML = '<p class="empty-message">Henüz grup ataması yapılmamış. Grup düzenlemeleri "Değerlendirme Girişi" sekmesinden yapabilirsiniz.</p>';
            return;
        }
        
        // Sadece ana etkinliklerin grup bilgilerini topla (alt bileşenler hariç)
        const mainComponentGroups = {};
        Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
            // Sadece ana etkinlikleri al (A1, A2, F1, F2 gibi - nokta içermeyenler)
            if (!componentId.includes('.')) {
            const component = APP_STATE.courseData.grupHaritalari[componentId];
            if (component.gruplar && component.gruplar.length > 0) {
                    mainComponentGroups[componentId] = component.gruplar;
                }
            }
        });
        
        // Grup bilgisi varsa detaylı gösterim
        if (Object.keys(mainComponentGroups).length > 0) {
            let html = '<div class="group-info-grid">';
            
            Object.keys(mainComponentGroups).forEach(componentId => {
                const groups = mainComponentGroups[componentId];
                
                // Ana etkinlik için grup bilgisi
                html += `
                    <div class="component-group-card">
                        <h4 class="component-title">${getComponentDisplayName(componentId)}</h4>
                        <div class="group-distribution">
                `;
                
                groups.forEach(groupId => {
                    // Öğrencileri bu gruba ata ve filtrele
                    const studentsInGroup = APP_STATE.studentData.filter(student => {
                        const studentGroup = getStudentGroupForComponent(student.studentId, componentId);
                        return studentGroup === groupId;
                    });
                    
                    // Eğer tek grup varsa ve hiç öğrenci atanmamışsa, tüm öğrencileri bu gruba ata
                    if (groups.length === 1 && studentsInGroup.length === 0 && groupId === 'A') {
                        // Tüm öğrencileri A grubuna ata
                        APP_STATE.studentData.forEach(student => {
                            if (!student.grup || !groups.includes(student.grup)) {
                                student.grup = 'A';
                            }
                            // Bileşen bazlı grup ataması da yap
                            if (!APP_STATE.studentComponentGroups) {
                                APP_STATE.studentComponentGroups = {};
                            }
                            if (!APP_STATE.studentComponentGroups[student.studentId]) {
                                APP_STATE.studentComponentGroups[student.studentId] = {};
                            }
                            APP_STATE.studentComponentGroups[student.studentId][componentId] = 'A';
                        });
                        // Yeniden filtrele
                        const allStudents = APP_STATE.studentData.slice();
                        studentsInGroup.length = 0;
                        studentsInGroup.push(...allStudents);
                    }
                    
                    html += `
                        <div class="group-item">
                            <span class="group-badge">${groupId} Grubu</span>
                            <span class="student-count">${studentsInGroup.length} öğrenci</span>
                            <div class="student-list">
                                ${studentsInGroup.map(s => `<span class="student-name">${s.name} ${s.surname}</span>`).join(', ')}
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                `;
                
                // Ana etkinliğin alt bileşenlerini göster
                const mainActivity = APP_STATE.assessmentTree.find(node => node.id === componentId);
                if (mainActivity && mainActivity.children && mainActivity.children.length > 0) {
                    html += `
                        <div class="sub-components-info">
                            <h5 class="sub-components-title">Alt Bileşenler:</h5>
                            <div class="sub-components-list">
                    `;
                    
                    mainActivity.children.forEach(subComponent => {
                        html += `
                            <div class="sub-component-item">
                                <span class="sub-component-id">${subComponent.id}</span>
                                <span class="sub-component-name">${subComponent.name}</span>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                html += `
                    </div>
                `;
            });
            
            html += '</div>';
            studentGroupInfoContainer.innerHTML = html;
        } else {
            studentGroupInfoContainer.innerHTML = '<p class="empty-message">Tüm bileşenler tek grup kullanıyor. Grup düzenlemeleri "Değerlendirme Girişi" sekmesinden yapabilirsiniz.</p>';
        }
        
        studentGroupInfoCard.style.display = 'block';
        
    } catch (error) {
        console.error("Öğrenci grup bilgileri güncellenirken hata:", error);
    }
}

/**
 * Bileşen ID'sinden etkinlik adını getir
 * @param {string} componentId - Bileşen ID'si (A1, A2, F1, vb.)
 * @returns {string} - Etkinlik adı
 */
function getComponentDisplayName(componentId) {
    try {
        // assessmentTree'den ilgili bileşeni bul
        const component = APP_STATE.assessmentTree?.find(node => node.id === componentId);
        
        if (component && component.name) {
            return `${componentId} - ${component.name}`;
        }
        
        // Eğer bulunamazsa sadece ID'yi döndür
        return `${componentId} Bileşeni`;
    } catch (error) {
        console.error('Bileşen adı alınırken hata:', error);
        return `${componentId} Bileşeni`;
    }
}

/**
 * Debug: Grup atamalarını konsola yazdır
 */
function debugGroupAssignments() {
    try {
        console.log('\n=== 🔍 DEBUG: GRUP ATAMALARI ===');
        
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            console.log('⚠️ Öğrenci verisi yok');
            return;
        }
        
        console.log(`👥 Toplam öğrenci sayısı: ${APP_STATE.studentData.length}`);
        
        // Genel grup atamaları
        console.log('\n📋 Genel grup atamaları:');
        APP_STATE.studentData.forEach((student, index) => {
            console.log(`  ${index + 1}. ${student.name} ${student.surname} (${student.studentId}) → Grup: ${student.grup || 'YOK'}`);
        });
        
        // Bileşen bazlı grup atamaları
        if (APP_STATE.courseData?.grupHaritalari) {
            console.log('\n🎯 Bileşen bazlı grup atamaları:');
            Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
                const component = APP_STATE.courseData.grupHaritalari[componentId];
                console.log(`\n  📊 ${getComponentDisplayName(componentId)} (Gruplar: ${component.gruplar?.join(', ') || 'YOK'}):`);
                
                APP_STATE.studentData.forEach((student, index) => {
                    const studentGroup = getStudentGroupForComponent(student.studentId, componentId);
                    console.log(`    ${index + 1}. ${student.name} ${student.surname} → ${studentGroup}`);
                });
            });
        }
        
        console.log('\n=== 🔍 DEBUG TAMAMLANDI ===\n');
        
    } catch (error) {
        console.error('Debug grup atamaları sırasında hata:', error);
    }
}

/**
 * Bir öğrencinin belirli bir bileşendeki grubunu al
 * @param {string} studentId - Öğrenci ID
 * @param {string} componentId - Bileşen ID
 * @returns {string} - Grup ID
 */
function getStudentGroupForComponent(studentId, componentId) {
    // Bu bileşenin mevcut gruplarını kontrol et
    const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
    const availableGroups = component?.gruplar || ['A'];
    
    console.log(`🔍 getStudentGroupForComponent(${studentId}, ${componentId}): availableGroups=${availableGroups.join(',')}`);
    
    // 1. ÖNCELİK: courseData.ogrenciNotlari v5 formatından grup bilgisini al (en güncel)
    if (APP_STATE.courseData && APP_STATE.courseData.ogrenciNotlari && APP_STATE.courseData.ogrenciNotlari[studentId] &&
        APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri && 
        APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri[componentId]) {
        const courseDataGroup = APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri[componentId];
        if (availableGroups.includes(courseDataGroup)) {
            console.log(`  ✅ courseData v5 formatından grup bulundu: ${courseDataGroup}`);
            return courseDataGroup;
        }
    }
    
    // 2. İKİNCİ ÖNCELİK: gradesData v5 formatından grup bilgisini al
    if (APP_STATE.gradesData && APP_STATE.gradesData[studentId] && 
        APP_STATE.gradesData[studentId].grupBilgileri && 
        APP_STATE.gradesData[studentId].grupBilgileri[componentId]) {
        const v5Group = APP_STATE.gradesData[studentId].grupBilgileri[componentId];
        if (availableGroups.includes(v5Group)) {
            console.log(`  ✅ gradesData v5 formatından grup bulundu: ${v5Group}`);
            return v5Group;
        }
    }
    
    // 3. ÜÇÜNCÜ ÖNCELİK: Runtime sistem (studentComponentGroups)
    if (APP_STATE.studentComponentGroups && 
        APP_STATE.studentComponentGroups[studentId] && 
        APP_STATE.studentComponentGroups[studentId][componentId]) {
        const componentGroup = APP_STATE.studentComponentGroups[studentId][componentId];
        if (availableGroups.includes(componentGroup)) {
            console.log(`  ✅ Runtime sisteminden grup bulundu: ${componentGroup}`);
            return componentGroup;
        }
    }
    
    // 4. DÖRDÜNCÜ ÖNCELİK: Öğrencinin genel grubu
    const student = APP_STATE.studentData?.find(s => s.studentId === studentId);
    if (student && student.grup && availableGroups.includes(student.grup)) {
        console.log(`  ✅ Öğrencinin genel grubundan: ${student.grup}`);
        return student.grup;
    }
    
    // 5. VARSAYILAN: Bu bileşenin ilk grubunu döndür (genellikle A)
    const defaultGroup = availableGroups[0] || 'A';
    console.log(`  🔧 Varsayılan grup kullanılıyor: ${defaultGroup}`);
    return defaultGroup;
}

/**
 * Öğrenci listesini temizleme
 */
function clearStudents() {
    // Önce silinecek öğrenci var mı kontrol et
    const hasStudents = (APP_STATE.studentData && APP_STATE.studentData.length > 0) || 
                       (APP_STATE.students && APP_STATE.students.length > 0);
    
    if (!hasStudents) {
        showModernToast("ℹ️ Silinecek öğrenci bulunmuyor.", "info");
        return;
    }
    
    showModernConfirm(
        '🎓 Öğrenci Listesini Temizle',
        'Öğrenci listesini temizlemek istediğinizden emin misiniz?\n\n• Öğrenci listesi silinecek\n• Notlar korunacak\n• Değerlendirme yapısı korunacak\n\nBu işlem geri alınamaz!',
        function() {
            try {
                APP_STATE.studentData = [];
                APP_STATE.gradesData = {};
                updateStudentTable();
                
                // Değerlendirme görünümünü güncelle
                updateAssessmentView();
                
                showModernToast("🎓 Öğrenci listesi temizlendi!", "success");
            } catch (error) {
                console.error("Öğrenci listesi temizlenirken hata oluştu:", error);
                showModernToast("❌ Öğrenci listesi temizlenemedi!", "error");
            }
        }
    );
}

/**
 * Öğrenci verilerini içe aktarma - Tüm formatları destekler
 * @param {Object} jsonData - JSON veri
 */
function importStudentData(jsonData) {
    try {
        let studentData = [];
        let gradesData = {};
        
        // Öğrenci listesini farklı formatlarda kontrol et
        if (jsonData.ogrenciler && Array.isArray(jsonData.ogrenciler)) {
            // Format 1: Ders değerlendirme sistemi formatı
            studentData = jsonData.ogrenciler.map(student => ({
                studentId: student.ogrenciNo,
                name: student.ad,
                surname: student.soyad,
                status: student.durum || 'Aktif',
                grup: student.grup || 'A',
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
            
            // ogrenciNotlari formatı
            if (jsonData.ogrenciNotlari) {
                gradesData = jsonData.ogrenciNotlari;
            }
        } 
        else if (jsonData.students && Array.isArray(jsonData.students)) {
            // Format 2: Normal/İngilizce format
            studentData = jsonData.students.map(student => ({
                studentId: student.student_id || student.studentId || student.ogrenciNo,
                name: student.name || student.ad,
                surname: student.surname || student.soyad,
                status: student.status || student.durum || 'Aktif',
                grup: student.grup || student.group || 'A',
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
            
            // grades veya rawGrades formatı
            if (jsonData.grades) {
                gradesData = jsonData.grades;
            } else if (jsonData.rawGrades) {
                gradesData = jsonData.rawGrades;
            }
        } 
        else if (jsonData.courseData && jsonData.courseData.ogrenciler) {
            // Format 3: Excel-to-MUDEK formatı
            studentData = jsonData.courseData.ogrenciler.map(student => ({
                studentId: student.ogrenciNo,
                name: student.ad,
                surname: student.soyad,
                status: student.durum || 'Aktif',
                grup: student.grup || 'A',
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
        } 
        else {
            throw new Error('Geçerli öğrenci verisi bulunamadı.');
        }
        
        if (!studentData.length) {
            throw new Error('Öğrenci listesi boş.');
        }
        
        // Öğrenci verilerini kaydet
        APP_STATE.studentData = studentData;
        
        // Grup haritası bilgilerini yükle
        if (jsonData.grupHaritalari) {
            if (!APP_STATE.courseData) {
                APP_STATE.courseData = {};
            }
            APP_STATE.courseData.grupHaritalari = jsonData.grupHaritalari;
            console.log('Grup haritaları yüklendi:', jsonData.grupHaritalari);
        }
        
        // Grup sistemini başlat
        initializeGroupSystem();
        
        // Tüm ilgili UI'ları güncelle
        updateStudentTable();
        updateGroupSelectors();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        
        // Not verilerini de yükle
        if (Object.keys(gradesData).length > 0) {
            APP_STATE.gradesData = gradesData;
            console.log('Not verileri yüklendi:', Object.keys(gradesData).length, 'öğrenci');
            
            // HAM PUAN KONTROLÜ VE GRUP BAZLI HESAPLAMA
            recalculateAllGradesBasedOnGroups();
        }
        
        // Değerlendirme görünümünü güncelle
        updateAssessmentView();
        
        // Değerlendirme sekmesine geç
        switchTab('assessment');
        
        showModernToast(`${APP_STATE.studentData.length} öğrenci başarıyla yüklendi.`);
    } catch (error) {
        console.error("Öğrenci verileri içe aktarılırken hata oluştu:", error);
        showModernToast("Öğrenci verileri içe aktarılamadı! Lütfen dosya formatını kontrol edin.", "error");
        throw error;
    }
}

// =====================================================
// JSON VE DOSYA İŞLEMLERİ
// =====================================================

/**
 * Not verilerini içe aktarma
 */
function importGrades() {
    try {
        // Not girişlerinin kontrolü
        if (!APP_STATE.assessmentTree.length || !APP_STATE.studentData.length) {
            showModernToast("Değerlendirme kriterleri ve öğrenci listesi yüklenmeden not girişi yapılamaz!", "warning");
            return;
        }
        
        // Not içe aktarma modalını göster
        openModal(importModal);
        
        // Modalda açıklama ekle
        jsonContent.value = "";
        jsonContent.placeholder = "Not verilerini JSON formatında yapıştırın veya dosyadan yükleyin.\n\n" +
            "Örnek format:\n{\n  \"12345\": {\n    \"A1\": 85,\n    \"F1\": 75\n  }\n}";
            
        // Modalın başlığını değiştir
        document.querySelector('#importModal .modal-header h2').textContent = "Notları İçe Aktar";
        
        // Apply butonuna farklı bir işlev ata
        btnApplyJson.onclick = function() {
            applyGradesJson();
        };
        
    } catch (error) {
        console.error("Not içe aktarma modalı gösterilirken hata oluştu:", error);
        showModernToast("Not içe aktarma işlemi başlatılamadı!", "error");
    }
}

/**
 * Not JSON verilerini uygulama
 */
function applyGradesJson() {
    try {
        const jsonString = jsonContent.value.trim();
        
        if (!jsonString) {
            showModernToast("Lütfen geçerli bir JSON içeriği girin.", "warning");
            return;
        }
        
        const jsonData = JSON.parse(jsonString);
        
        // Temel doğrulama
        if (!jsonData || typeof jsonData !== 'object') {
            throw new Error('Geçersiz JSON formatı.');
        }
        
        // Not verilerini yükle
        if (jsonData.grades) {
            APP_STATE.gradesData = jsonData.grades;
        } else if (jsonData.ogrenciNotlari) {
            APP_STATE.gradesData = jsonData.ogrenciNotlari;
        } else if (jsonData.rawGrades) {
            APP_STATE.gradesData = jsonData.rawGrades;
        } else {
            // Doğrudan not verisi olarak kabul et
            APP_STATE.gradesData = jsonData;
        }
        
        // JSON yüklendikten sonra alanları uyumlu hale getir
        normalizeGradeFields();
        
        // Değerlendirme görünümünü güncelle
        updateAssessmentView();
        
        closeModal(importModal);
        showModernToast("Not verileri başarıyla yüklendi.");
        
        // Değerlendirme sekmesine geç
        switchTab('assessment');
        
    } catch (error) {
        console.error("Not JSON verisi uygulanırken hata oluştu:", error);
        showModernToast("Not verileri yüklenemedi: " + error.message, "error");
    }
}
/**
 * Not verilerini kaydetme
 */
function saveGrades() {
    try {
        // Not girişlerinin kontrolü
        if (!APP_STATE.assessmentTree.length || !APP_STATE.studentData.length) {
            showModernToast("Değerlendirme kriterleri ve öğrenci listesi yüklenmeden not kaydı yapılamaz!", "warning");
            return;
        }
        
        // Notları kaydet - dosya sisteminde kalıcı olarak saklanmasına gerek yok,
        // çünkü zaten APP_STATE.gradesData içinde tutuluyorlar
        
        showModernToast("Notlar başarıyla kaydedildi.");
        
        // İsteğe bağlı olarak notları JSON olarak dışa aktarma modalını göster
        showExportGradesModal('json');
    } catch (error) {
        console.error("Notlar kaydedilirken hata oluştu:", error);
        showModernToast("Notlar kaydedilemedi!", "error");
    }
}

/**
 * Not dışa aktarma modalını gösterme
 * @param {string} type - Dışa aktarma tipi (json/csv)
 */
function showExportGradesModal(type) {
    try {
        // Tip kontrolü
        if (type !== 'json' && type !== 'csv') {
            throw new Error('Geçersiz dışa aktarma tipi!');
        }
        
        // İçerik oluştur
        let content = '';
        
        if (type === 'json') {
            // JSON verisi oluştur
            const gradesData = createGradesExportData();
            content = JSON.stringify(gradesData, null, 2);
        } else {
            // CSV verisi oluştur
            content = createGradesCSV();
        }
        
        // Modal içeriğini ayarla
        exportGradesContent.value = content;
        
        // Modalı göster
        openModal(exportGradesModal);
        
        showModernToast(`Notlar ${type.toUpperCase()} formatında hazırlandı.`);
    } catch (error) {
        console.error("Not dışa aktarma modalı gösterilirken hata oluştu:", error);
        showModernToast("Not verileri dışa aktarılamadı!", "error");
    }
}

// İlk applyJsonData fonksiyonu silindi - ikinci fonksiyon daha kapsamlı

/**
 * Öğrenci JSON verilerini uygulama
 */
function applyStudentJsonData() {
    try {
        const jsonData = JSON.parse(studentJsonContent.value);
        
        // Öğrenci verilerini içe aktar
        importStudentData(jsonData);
        
        closeModal(importStudentsModal);
        showModernToast("Öğrenci listesi başarıyla yüklendi.");
    } catch (error) {
        console.error("Öğrenci JSON verisi uygulanırken hata oluştu:", error);
        showModernToast("Öğrenci listesi yüklenemedi! Lütfen dosya formatını kontrol edin.", "error");
    }
}

/**
 * Ders verilerinden değerlendirme ağacı oluşturma
 */
function createAssessmentTreeFromCourseData() {
    try {
        // Temiz bir ağaç yapısı oluştur
        APP_STATE.assessmentTree = [];
        
        if (!APP_STATE.courseData) return;
        
        // Derste tanımlı değerlendirme etkinliklerini kontrol et
        const assessmentActivities = APP_STATE.courseData.dersDegerlendirme?.yariyilIciEtkinlikleri || [];
        const finalActivities = APP_STATE.courseData.dersDegerlendirme?.yariyilSonuEtkinlikleri || [];
        
        // Yarıyıl içi etkinlikler
        if (assessmentActivities.length > 0) {
            assessmentActivities.forEach((activity, index) => {
                // v5 formatında ID zaten var, yoksa oluştur
                const activityId = activity.id || `A${index + 1}`;
                
                // ÖÇ'leri kullan - eğer JSON'da ÖÇ varsa onları akıllıca dağıt
                const randomOutcomes = getSmartOutcomes(2);
                
                const node = {
                    id: activityId,
                    name: activity.etkinlik,
                    type: activity.etkinlik,
                    weight: activity.katkiYuzdesi,
                    points: 100,
                    outcomes: randomOutcomes,
                    description: 'Yarıyıl içi değerlendirme',
                    expanded: true,
                    children: []
                };
                
                // v5 formatında detaylar varsa onları kullan
                if (activity.detaylar && Array.isArray(activity.detaylar)) {
                    node.children = activity.detaylar.map(detail => ({
                        id: detail.id,
                        name: detail.isim,
                        type: detail.tip,
                        weight: detail.agirlik,
                        points: detail.puan,
                        outcomes: detail.ogrenmeÇiktilari || [],
                        description: detail.aciklama || 'Değerlendirme bileşeni',
                        expanded: false,
                        children: []
                    }));
                }
                // Eski format veya assessment details varsa
                else if (APP_STATE.courseData.assessmentDetails && APP_STATE.courseData.assessmentDetails[activityId]) {
                    const details = APP_STATE.courseData.assessmentDetails[activityId];
                    if (details.children && Array.isArray(details.children)) {
                        node.children = details.children;
                    }
                } else {
                    // Varsayılan olarak bazı soru ve rubrikler ekle
                    if (activity.etkinlik === 'Ara Sınav' || activity.etkinlik === 'Quiz') {
                        // Örnek sorular ekle
                        for (let i = 1; i <= 5; i++) {
                            const questionOutcome = getSmartOutcomes(1);
                            
                            node.children.push({
                                id: `${activityId}.${i}`,
                                name: `Soru ${i}`,
                                type: 'Soru',
                                weight: 20,
                                points: 20,
                                outcomes: questionOutcome,
                                description: 'Değerlendirme sorusu',
                                expanded: false,
                                children: []
                            });
                        }
                    } else if (activity.etkinlik === 'Proje Hazırlama' || activity.etkinlik === 'Rapor' || activity.etkinlik === 'Ev Ödevi') {
                        // Örnek rubrikler ekle
                        const rubricTypes = [
                            { name: 'İçerik', desc: 'İçerik kalitesi ve kapsamı' },
                            { name: 'Organizasyon', desc: 'Çalışmanın düzeni ve yapısı' },
                            { name: 'Sunum', desc: 'Sunum kalitesi ve profesyonellik' },
                            { name: 'Kaynaklar', desc: 'Kaynakların kullanımı ve atıf yapılması' },
                            { name: 'Özgünlük', desc: 'Çalışmanın özgünlük düzeyi' }
                        ];
                        
                        rubricTypes.forEach((rubric, idx) => {
                            const rubricOutcome = getSmartOutcomes(1);
                            
                            node.children.push({
                                id: `${activityId}.${idx + 1}`,
                                name: rubric.name,
                                type: 'Rubrik',
                                weight: 20,
                                points: 20,
                                outcomes: rubricOutcome,
                                description: rubric.desc,
                                expanded: false,
                                children: []
                            });
                        });
                    }
                }
                
                APP_STATE.assessmentTree.push(node);
            });
        } else {
            // Varsayılan bir yarıyıl içi etkinlik ekle
            APP_STATE.assessmentTree.push({
                id: 'A1',
                name: 'Ara Sınav',
                type: 'Ara Sınav',
                weight: 40,
                points: 100,
                outcomes: getSmartOutcomes(3),
                description: 'Yarıyıl içi değerlendirme',
                expanded: true,
                children: []
            });
        }
        
        // Yarıyıl sonu etkinlikler
        if (finalActivities.length > 0) {
            finalActivities.forEach((activity, index) => {
                // v5 formatında ID zaten var, yoksa oluştur
                const activityId = activity.id || `F${index + 1}`;
                
                // ÖÇ'leri akıllıca dağıt
                const randomOutcomes = getSmartOutcomes(3);
                
                const node = {
                    id: activityId,
                    name: activity.etkinlik,
                    type: activity.etkinlik,
                    weight: activity.katkiYuzdesi,
                    points: 100,
                    outcomes: randomOutcomes,
                    description: 'Yarıyıl sonu değerlendirme',
                    expanded: true,
                    children: []
                };
                
                // v5 formatında detaylar varsa onları kullan
                if (activity.detaylar && Array.isArray(activity.detaylar)) {
                    node.children = activity.detaylar.map(detail => ({
                        id: detail.id,
                        name: detail.isim,
                        type: detail.tip,
                        weight: detail.agirlik,
                        points: detail.puan,
                        outcomes: detail.ogrenmeÇiktilari || [],
                        description: detail.aciklama || 'Değerlendirme bileşeni',
                        expanded: false,
                        children: []
                    }));
                }
                // Eski format veya assessment details varsa
                else if (APP_STATE.courseData.assessmentDetails && APP_STATE.courseData.assessmentDetails[activityId]) {
                    const details = APP_STATE.courseData.assessmentDetails[activityId];
                    if (details.children && Array.isArray(details.children)) {
                        node.children = details.children;
                    }
                } else {
                    // Final sınavı için örnek sorular ekle
                    if (activity.etkinlik === 'Final Sınavı') {
                        for (let i = 1; i <= 5; i++) {
                            const questionOutcome = getSmartOutcomes(1);
                            
                            node.children.push({
                                id: `${activityId}.${i}`,
                                name: `Soru ${i}`,
                                type: 'Soru',
                                weight: 20,
                                points: 20,
                                outcomes: questionOutcome,
                                description: 'Değerlendirme sorusu',
                                expanded: false,
                                children: []
                            });
                        }
                    }
                }
                
                APP_STATE.assessmentTree.push(node);
            });
        } else {
            // Varsayılan bir yarıyıl sonu etkinlik ekle
            APP_STATE.assessmentTree.push({
                id: 'F1',
                name: 'Final Sınavı',
                type: 'Final Sınavı',
                weight: 60,
                points: 100,
                outcomes: getSmartOutcomes(4),
                description: 'Yarıyıl sonu değerlendirme',
                expanded: true,
                children: []
            });
        }
        
        // Ana bileşenler oluşturuldu
        console.log('🎯 Ana değerlendirme bileşenleri oluşturuldu');
        // Bu noktada sadece ağaç yapısı hazır, DOM henüz render edilmemiş
        
    } catch (error) {
        console.error("Değerlendirme ağacı oluşturulurken hata oluştu:", error);
        showModernToast("Değerlendirme ağacı oluşturulamadı!", "error");
    }
}

/**
 * Dışa aktarılacak JSON verisi oluştur
 * @returns {Object} - Dışa aktarılacak veri
 */
function createExportData() {
    try {
        // Grup haritalamalarını temizleme - sadece pozisyon->soru mapping'lerini koru
        function cleanGroupMappings(haritalar) {
            const result = {};
            const sortedGroups = Object.keys(haritalar).sort();
            
            sortedGroups.forEach(group => {
                result[group] = {};
                // Sadece sayısal anahtar (pozisyon) olan mapping'leri koru - ters mapping'leri filtrele
                Object.keys(haritalar[group]).forEach(key => {
                    if (/^\d+$/.test(key)) { // Sadece sayısal anahtarlar (1,2,3,4,5...)
                        result[group][key] = haritalar[group][key];
                    }
                });
            });
            return result;
        }
        
        // Tarih ve zaman bilgisi
        const now = new Date();
        const formattedDateTime = now.toISOString().slice(0, 19).replace('T', ' ');
        
        // Dışa aktarılacak veri yapısı - tamamen Türkçe anahtar isimlerini kullanıyor
        const exportData = {
            disaAktarmaTarihi: now.toISOString(),
            dersBilgisi: {
                dersKodu: APP_STATE.courseData?.dersGenel?.dersKodu || '',
                dersAdi: APP_STATE.courseData?.dersGenel?.dersAdi || '',
                akademikYil: APP_STATE.courseData?.dersGenel?.akademikYil || '',
                donem: APP_STATE.courseData?.dersGenel?.ogretimYiliDonemi || 'Bahar Dönemi',
                ogretimUyesi: APP_STATE.courseData?.dersIcerik?.dersiVerenOgretimUyesiOgretimGorevlisi || ''
            },
            ogrenciler: APP_STATE.studentData.map(student => ({
                ogrenciNo: student.studentId,
                ad: student.name,
                soyad: student.surname,
                durum: student.status || 'Aktif',
                email: student.email || '', // Email korunuyor
                tcKimlik: student.tcKimlik || '', // TC Kimlik korunuyor
                telefon: student.telefon || '' // Telefon korunuyor
            })),
            dersDegerlendirme: {
                yariyilIciEtkinlikleri: APP_STATE.assessmentTree.filter(node => node.id.startsWith('A')).map(node => {
                    // Grup haritalama bilgilerini al
                    const groupMapping = APP_STATE.courseData?.grupHaritalari?.[node.id];
                    
                    return {
                        id: node.id,
                    etkinlik: node.type,
                    sayi: 1,
                    katkiYuzdesi: node.weight,
                    detaylar: node.children && node.children.map(child => ({
                        id: child.id,
                        isim: child.name,
                        tip: child.type,
                        agirlik: child.weight,
                        puan: child.points,
                        ogrenmeÇiktilari: child.outcomes || [],
                        aciklama: child.description || (child.type === 'Soru' ? 'Değerlendirme sorusu' : 'Değerlendirme bileşeni')
                        })) || [],
                        grupBilgileri: {
                            gruplar: groupMapping?.gruplar || groupMapping?.groups || ["A"],
                            haritalar: groupMapping?.haritalar ? 
                                // Mevcut haritalar varsa, sadece pozisyon->soru mapping'lerini koru
                                cleanGroupMappings(groupMapping.haritalar) :
                                // Yoksa varsayılan oluştur (pozisyon: soruId formatında)
                                {
                                    "A": node.children ? node.children.reduce((acc, child, index) => {
                                        acc[(index + 1).toString()] = child.id;
                                        return acc;
                                    }, {}) : {}
                                }
                        }
                    };
                }),
                yariyilSonuEtkinlikleri: APP_STATE.assessmentTree.filter(node => node.id.startsWith('F')).map(node => {
                    // Grup haritalama bilgilerini al
                    const groupMapping = APP_STATE.courseData?.grupHaritalari?.[node.id];
                    
                    return {
                        id: node.id,
                    etkinlik: node.type,
                    sayi: 1,
                    katkiYuzdesi: node.weight,
                    detaylar: node.children && node.children.map(child => ({
                        id: child.id,
                        isim: child.name,
                        tip: child.type,
                        agirlik: child.weight,
                        puan: child.points,
                        ogrenmeÇiktilari: child.outcomes || [],
                        aciklama: child.description || (child.type === 'Soru' ? 'Değerlendirme sorusu' : 'Değerlendirme bileşeni')
                        })) || [],
                        grupBilgileri: {
                            gruplar: groupMapping?.gruplar || ["A"],
                            haritalar: groupMapping?.haritalar ? 
                                // Mevcut haritalar varsa, sadece pozisyon->soru mapping'lerini koru
                                cleanGroupMappings(groupMapping.haritalar) :
                                // Yoksa varsayılan oluştur (pozisyon: soruId formatında)
                                {
                                    "A": node.children ? node.children.reduce((acc, child, index) => {
                                        acc[(index + 1).toString()] = child.id;
                                        return acc;
                                    }, {}) : {}
                                }
                        }
                    };
                })
            },
            // Öğrenci notlarını kağıt sırasına göre düzenle
            ogrenciNotlari: (() => {
                const notlari = {};
                
                APP_STATE.studentData.forEach(student => {
                    const studentId = student.studentId;
                    const studentGrades = {};
                    
                    // Her etkinlik için notları düzenle
                    APP_STATE.assessmentTree.forEach(activity => {
                        if (activity.children && activity.children.length > 0) {
                            const activityGrades = {};
                            
                                        // Kağıt sırasına göre puanları al
            activity.children.forEach((child, index) => {
                const questionOrder = (index + 1).toString();
                
                // Öğrencinin grup bilgisine göre hangi soru ID'sine denk geldiğini bul
                const studentGroup = getStudentGroupForComponent(studentId, activity.id) || 'A';
                const groupMapping = APP_STATE.courseData?.grupHaritalari?.[activity.id]?.haritalar?.[studentGroup];
                let questionId = child.id;
                
                if (groupMapping && groupMapping[questionOrder]) {
                    questionId = groupMapping[questionOrder];
                }
                
                // ✅ FIX: Doğru soru ID'sinden puanı al - grup haritalama sonrası
                const grade = getStudentGrade(studentId, questionId) || 0;
                
                activityGrades[questionOrder] = {
                    puan: parseFloat(grade.toFixed(2)),
                    soruId: questionId
                };
            });
                            
                            studentGrades[activity.id] = activityGrades;
                        }
                    });
                    
                    // Her öğrenci için grup bilgilerini ekle (v5 format uyumlu)
                    studentGrades.grupBilgileri = {};
                    APP_STATE.assessmentTree.forEach(activity => {
                        studentGrades.grupBilgileri[activity.id] = getStudentGroupForComponent(studentId, activity.id) || 'A';
                    });
                    
                    notlari[studentId] = studentGrades;
                });
                
                return notlari;
            })(),
            
            // Genel ders bilgileri
            dersGenel: APP_STATE.courseData?.dersGenel || {},
            dersIcerik: APP_STATE.courseData?.dersIcerik || {},
            
            // Öğrenme çıktıları varsa ekle
            dersOgrenmeÇiktilari: APP_STATE.learningOutcomes.map(outcome => ({
                id: outcome.id,
                aciklama: outcome.aciklama
            })),
            
            // Etkinlik türleri listesi (import'tan koru)
            etkinlikTurleri: APP_STATE.courseData?.etkinlikTurleri || [
                "Alan Çalışması", "Alan Gezisi", "Ara Sınav", "Ara Sınav İçin Bireysel Çalışma",
                "Beyin Fırtınası", "Bireysel Çalışma", "Bütünleme Sınavı", "Deney",
                "Deney Sonrası Quiz", "Derse Katılım", "Ev Ödevi", "Final Sınavı",
                "Final Sınavı İçin Bireysel Çalışma", "Gösterme", "Gözlem", "Laboratuvar",
                "Laboratuvar Ara Sınavı", "Laboratuvar Sınavı", "Makale Kritik Etme",
                "Makale Yazma", "Multirom CD Çalışması", "Ödev Problemleri İçin Çalışma",
                "Okuma", "Örnek Vaka İncelemesi", "Performans", "Problem Çözümü",
                "Proje Hazırlama", "Proje Sunma", "Proje Tasarımı/Yönetimi", "Quiz",
                "Quiz İçin Bireysel Çalışma", "Rapor", "Rapor Hazırlama", "Rapor Sunma",
                "Rehberli Problem Çözümü", "Rol Oynama / Dramatizasyon", "Seminer",
                "Soru-Yanıt", "Sözlü Sınav", "Takım/Grup Çalışması", "Tartışma",
                "Toplantı Başkanlığı Yapma", "Uygulama/Pratik"
            ],
            
            // Yarıyıl içi olası etkinlikler (import'tan koru)
            yariyilIciOlasiEtkinlikler: APP_STATE.courseData?.yariyilIciOlasiEtkinlikler || [
                "Ara Sınav", "Laboratuvar Sınavı", "Deney", "Deney Sonrası Quiz",
                "Performans", "Quiz", "Rapor", "Rapor Sunma", "Makale Kritik Etme",
                "Makale Yazma", "Proje Hazırlama", "Proje Sunma", "Rehberli Problem Çözümü",
                "Seminer", "Sözlü Sınav", "Ödev Problemleri İçin Çalışma", "Proje Tasarımı/Yönetimi"
            ],
            
            // Yarıyıl sonu olası etkinlikler (import'tan koru)
            yariyilSonuOlasiEtkinlikler: APP_STATE.courseData?.yariyilSonuOlasiEtkinlikler || [
                "Final Sınavı", "Laboratuvar Ara Sınavı", "Makale Yazma", "Proje Hazırlama",
                "Proje Sunma", "Proje Tasarımı/Yönetimi", "Quiz", "Rapor", "Rapor Hazırlama",
                "Rapor Sunma", "Seminer", "Sözlü Sınav", "Gözlem"
            ],
            
            // Denetim bilgileri
            denetimBilgileri: {
                olusturmaTarihi: APP_STATE.courseData?.denetimBilgileri?.olusturmaTarihi || formattedDateTime,
                olusturan: APP_STATE.courseData?.denetimBilgileri?.olusturan || 'Ders Değerlendirme Sistemi',
                sonGuncellenmeTarihi: formattedDateTime,
                guncelleyen: 'Ders Değerlendirme Sistemi',
                durum: 'Taslak'
            }
        };
        
        // Ders Genel ve İçerik bilgilerini APP_STATE'den al
        if (APP_STATE.courseData) {
            if (APP_STATE.courseData.dersGenel) {
                exportData.dersGenel = JSON.parse(JSON.stringify(APP_STATE.courseData.dersGenel));
            }
            
            if (APP_STATE.courseData.dersIcerik) {
                exportData.dersIcerik = JSON.parse(JSON.stringify(APP_STATE.courseData.dersIcerik));
            }
            
            // Diğer önemli bilgileri koru
            if (APP_STATE.courseData.haftalikDersIcerikleri) {
                exportData.haftalikDersIcerikleri = JSON.parse(JSON.stringify(APP_STATE.courseData.haftalikDersIcerikleri));
            }
            
            if (APP_STATE.courseData.dersIsYuku) {
                exportData.dersIsYuku = JSON.parse(JSON.stringify(APP_STATE.courseData.dersIsYuku));
            }
            
            if (APP_STATE.courseData.programCiktilari) {
                exportData.programCiktilari = JSON.parse(JSON.stringify(APP_STATE.courseData.programCiktilari));
            }
            
            if (APP_STATE.courseData.programVeOgrenmeIliskisi) {
                exportData.programVeOgrenmeIliskisi = JSON.parse(JSON.stringify(APP_STATE.courseData.programVeOgrenmeIliskisi));
            }
            
            if (APP_STATE.courseData.toplumsalKatkiVeSurdurulebilirlik) {
                exportData.toplumsalKatkiVeSurdurulebilirlik = JSON.parse(JSON.stringify(APP_STATE.courseData.toplumsalKatkiVeSurdurulebilirlik));
            }
            
            if (APP_STATE.courseData.dersSekmeler) {
                exportData.dersSekmeler = JSON.parse(JSON.stringify(APP_STATE.courseData.dersSekmeler));
            }
            
            if (APP_STATE.courseData.numaralandirmaDegerleri) {
                exportData.numaralandirmaDegerleri = JSON.parse(JSON.stringify(APP_STATE.courseData.numaralandirmaDegerleri));
            }
        }
        
        return exportData;
    } catch (error) {
        console.error("Dışa aktarılacak veri oluşturulurken hata oluştu:", error);
        showModernToast("Dışa aktarılacak veri oluşturulamadı!", "error");
        return {};
    }
}

/**
 * Notları JSON olarak dışa aktarma - Yeni temiz yapı
 * @returns {Object} - Dışa aktarılacak not verisi
 */
function createGradesExportData() {
    try {
        // Sadece öğrenci notları - temiz yapı
        const exportData = {
            ogrenciNotlari: {}
        };
        
        // Her öğrenci için notları oluştur
        APP_STATE.studentData.forEach(student => {
            const studentId = student.studentId;
            const studentGrades = {};
            
            // Her etkinlik için notları al
            APP_STATE.assessmentTree.forEach(activity => {
                if (activity.children && activity.children.length > 0) {
                    const activityGrades = {};
                    
                    // Grup bilgisini al
                    const studentGroup = getStudentGroup(studentId, activity.id) || 'A';
                    const groupMapping = APP_STATE.courseData?.grupHaritalari?.[activity.id]?.haritalar?.[studentGroup];
                    
                    // Her soru için puan ve soru ID'si
                    activity.children.forEach((child, index) => {
                        const questionOrder = (index + 1).toString();
                        
                        // Hangi soru ID'sine denk geldiğini bul
                        let questionId = child.id;
                        if (groupMapping && groupMapping[questionOrder]) {
                            questionId = groupMapping[questionOrder];
                        }
                        
                        // ✅ FIX: Doğru soru ID'sinden puanı al - grup haritalama sonrası
                        const grade = getStudentGrade(studentId, questionId) || 0;
                        
                        activityGrades[questionOrder] = {
                                                            puan: parseFloat(grade.toFixed(2)),
                            soruId: questionId
                        };
                    });
                    
                    studentGrades[activity.id] = activityGrades;
                }
            });
            
            // Grup bilgilerini ekle
            studentGrades.grupBilgileri = {};
            APP_STATE.assessmentTree.forEach(activity => {
                studentGrades.grupBilgileri[activity.id] = getStudentGroup(studentId, activity.id) || 'A';
            });
            
            exportData.ogrenciNotlari[studentId] = studentGrades;
        });
        
        return exportData;
    } catch (error) {
        console.error("Not verileri dışa aktarılırken hata oluştu:", error);
        showModernToast("Not verileri dışa aktarılamadı!", "error");
        return {};
    }
}

/**
 * Notları CSV olarak dışa aktarma
 * @returns {string} - CSV formatındaki not verisi
 */
function createGradesCSV() {
    try {
        // Final notlarını hesapla
        const finalGrades = {};
        
        APP_STATE.studentData.forEach(student => {
            const studentId = student.studentId;
            
            // Yarıyıl içi etkinlikler
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            let termGrade = 0;
            
            termActivities.forEach(activity => {
                const activityWeight = activity.weight / APP_STATE.termWeight; // Normalize
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler - grup haritalama dikkate alınarak
                    const studentGroup = getStudentGroupForComponent(studentId, activity.id) || 'A';
                    const groupMapping = APP_STATE.courseData?.grupHaritalari?.[activity.id]?.haritalar?.[studentGroup];
                    
                    activity.children.forEach((subItem, index) => {
                        const subItemWeight = subItem.weight / 100; // subItem içinde normalize
                        
                        // Grup haritalama varsa doğru soru ID'sini kullan
                        let questionId = subItem.id;
                        if (groupMapping) {
                            const questionOrder = (index + 1).toString();
                            if (groupMapping[questionOrder]) {
                                questionId = groupMapping[questionOrder];
                            }
                        }
                        
                        const grade = getStudentGrade(studentId, questionId) || 0;
                        const scaledGrade = (grade / subItem.points) * 100; // 100 üzerinden
                        activityGrade += scaledGrade * subItemWeight;
                    });
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / activity.points) * 100; // 100 üzerinden
                }
                
                termGrade += activityGrade * activityWeight;
            });
            
            // Yarıyıl sonu etkinlikler
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            let finalGrade = 0;
            
            finalActivities.forEach(activity => {
                const activityWeight = activity.weight / APP_STATE.finalWeight; // Normalize
                let activityGrade = 0;
                
                if (activity.children && activity.children.length > 0) {
                    // Alt etkinlikler - grup haritalama dikkate alınarak
                    const studentGroup = getStudentGroupForComponent(studentId, activity.id) || 'A';
                    const groupMapping = APP_STATE.courseData?.grupHaritalari?.[activity.id]?.haritalar?.[studentGroup];
                    
                    activity.children.forEach((subItem, index) => {
                        const subItemWeight = subItem.weight / 100; // subItem içinde normalize
                        
                        // Grup haritalama varsa doğru soru ID'sini kullan
                        let questionId = subItem.id;
                        if (groupMapping) {
                            const questionOrder = (index + 1).toString();
                            if (groupMapping[questionOrder]) {
                                questionId = groupMapping[questionOrder];
                            }
                        }
                        
                        const grade = getStudentGrade(studentId, questionId) || 0;
                        const scaledGrade = (grade / subItem.points) * 100; // 100 üzerinden
                        activityGrade += scaledGrade * subItemWeight;
                    });
                } else {
                    // Basit etkinlik
                    const grade = getStudentGrade(studentId, activity.id) || 0;
                    activityGrade = (grade / activity.points) * 100; // 100 üzerinden
                }
                
                finalGrade += activityGrade * activityWeight;
            });
            
            // Toplam ve harf notu
            const totalGrade = (termGrade * APP_STATE.termWeight / 100) + (finalGrade * APP_STATE.finalWeight / 100);
            const letterGrade = getLetterGrade(totalGrade);
            
            finalGrades[studentId] = {
                termGrade: termGrade.toFixed(2),
                finalGrade: finalGrade.toFixed(2),
                totalGrade: totalGrade.toFixed(2),
                letterGrade: letterGrade
            };
        });
        
        // CSV başlık satırı
        let csv = "Öğrenci No,Adı,Soyadı,Durum,Yarıyıl İçi,Yarıyıl Sonu,Toplam,Harf Notu\n";
        
        // Her öğrenci için satır ekle
        APP_STATE.studentData.forEach(student => {
            const studentGrade = finalGrades[student.studentId] || {
                termGrade: "0.00",
                finalGrade: "0.00",
                totalGrade: "0.00",
                letterGrade: "FF"
            };
            
            csv += `${student.studentId},${student.name},${student.surname},${student.status || 'Aktif'},${studentGrade.termGrade},${studentGrade.finalGrade},${studentGrade.totalGrade},${studentGrade.letterGrade}\n`;
        });
        
        return csv;
    } catch (error) {
        console.error("CSV oluşturulurken hata oluştu:", error);
        showModernToast("CSV oluşturulamadı!", "error");
        return '';
    }
}

/**
 * JSON verisini panoya kopyala
 */
function copyJsonToClipboard() {
    try {
        exportJsonContent.select();
        document.execCommand('copy');
        showModernToast("JSON verisi panoya kopyalandı.");
    } catch (error) {
        console.error("JSON verisi kopyalanırken hata oluştu:", error);
        showModernToast("JSON verisi kopyalanamadı!", "error");
    }
}

/**
 * Notları panoya kopyala
 */
function copyGradesToClipboard() {
    try {
        exportGradesContent.select();
        document.execCommand('copy');
        showModernToast("Not verileri panoya kopyalandı.");
    } catch (error) {
        console.error("Not verileri kopyalanırken hata oluştu:", error);
        showModernToast("Not verileri kopyalanamadı!", "error");
    }
}

/**
 * JSON verisini dosyaya kaydet
 */
function saveJsonToFile() {
    try {
        const jsonData = exportJsonContent.value;
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        
        // Eğer orijinal dosya adı varsa kullan, yoksa yeni bir ad oluştur
        if (APP_STATE.jsonFileName) {  // jsonFileName -> APP_STATE.jsonFileName
            a.download = APP_STATE.jsonFileName;
        } else {
            const dersKodu = APP_STATE.courseData?.dersGenel?.dersKodu || 'ders';
            a.download = `${dersKodu}_degerlendirme.json`;
        }
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showModernToast("JSON dosyası başarıyla kaydedildi.");
    } catch (error) {
        console.error("JSON dosyası kaydedilirken hata oluştu:", error);
        showModernToast("JSON dosyası kaydedilemedi!", "error");
    }
}


/**
 * Dosya yükleme işlemi
 * @param {Event} event - Dosya seçme olayı
 */
function loadJsonFromFile(event) {
    try {
        const file = event.target.files[0];
        if (!file) {
            showModernToast("Dosya seçilmedi.", "warning");
            return;
        }
        
        APP_STATE.jsonFileName = file.name;
        selectedFileName.textContent = file.name;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                jsonContent.value = e.target.result;
                showModernToast("Dosya başarıyla yüklendi. Uygulamak için 'Uygula' butonuna tıklayın.");
            } catch (error) {
                console.error("Dosya okuma hatası:", error);
                showModernToast("Dosya okunamadı: " + error.message, "error");
            }
        };
        
        reader.onerror = function() {
            showModernToast("Dosya okuma hatası oluştu.", "error");
        };
        
        reader.readAsText(file);
    } catch (error) {
        console.error("Dosya yükleme hatası:", error);
        showModernToast("Dosya yüklenemedi: " + error.message, "error");
    }
}

/**
 * JSON verisini uygulama - Tüm formatları destekler
 */
function applyJsonData() {
    try {
        const jsonString = jsonContent.value.trim();
        
        if (!jsonString) {
            showModernToast("Lütfen geçerli bir JSON içeriği girin.", "warning");
            return;
        }
        
        const jsonData = JSON.parse(jsonString);
        
        // Temel doğrulama
        if (!jsonData || typeof jsonData !== 'object') {
            throw new Error('Geçersiz JSON formatı.');
        }
        
        // Ders verilerini kaydet
        APP_STATE.courseData = jsonData;
        
        // Öğrenme çıktılarını ayarla
        if (jsonData.dersOgrenmeÇiktilari && Array.isArray(jsonData.dersOgrenmeÇiktilari)) {
            APP_STATE.learningOutcomes = jsonData.dersOgrenmeÇiktilari;
            console.log('ÖÇ verileri yüklendi:', APP_STATE.learningOutcomes);
            renderOutcomes();
            showModernToast(`${APP_STATE.learningOutcomes.length} adet öğrenme çıktısı yüklendi.`, "success");
        } else {
            console.log('ÖÇ verileri bulunamadı:', jsonData.dersOgrenmeÇiktilari);
            showModernToast("JSON'da öğrenme çıktısı bulunamadı!", "warning");
        }
        
        // Program çıktılarını ayarla
        if (jsonData.programCiktilari && Array.isArray(jsonData.programCiktilari)) {
            APP_STATE.programOutcomes = jsonData.programCiktilari;
            renderProgramOutcomes();
            showModernToast(`${APP_STATE.programOutcomes.length} adet program çıktısı yüklendi.`, "success");
        } else {
            showModernToast("JSON'da program çıktısı bulunamadı!", "warning");
        }
        
        // ÖÇ-PÇ İlişki Matrisini ayarla
        if (jsonData.programVeOgrenmeIliskisi && jsonData.programVeOgrenmeIliskisi.iliskiTablosu) {
            APP_STATE.outcomeMatrix = jsonData.programVeOgrenmeIliskisi;
            renderOutcomeMatrix();
        }
        
        // Ders bilgilerini güncelle
        updateCourseInfo();
        
        // Ders detaylarını render et
        renderCourseDetails();
        
        // Değerlendirme ağacı için veri yapısı oluştur
        if (jsonData.degerlendirmeAgaci) {
            // Doğrudan ağacı al (eğer daha önce kaydedilmişse)
            APP_STATE.assessmentTree = jsonData.degerlendirmeAgaci;
            showModernToast("Değerlendirme ağacı JSON'dan yüklendi.", "success");
        } else if (jsonData.assessmentTree) {
            APP_STATE.assessmentTree = jsonData.assessmentTree;
            showModernToast("Değerlendirme ağacı JSON'dan yüklendi.", "success");
        } else {
            // Ders verilerinden ağaç oluştur
            createAssessmentTreeFromCourseData();
            showModernToast("Değerlendirme ağacı ders verilerinden oluşturuldu ve ÖÇ'ler otomatik atandı.", "info");
        }
        
        // Eğer değerlendirme ağacı hala boşsa, default sorular ekle
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            createDefaultAssessmentTree();
            showModernToast("Varsayılan değerlendirme ağacı oluşturuldu ve ÖÇ'ler otomatik atandı.", "info");
        }
        
        // Temel dosya format için default grup sistemi ve soru ataması
        if (!isTamDosyaFormat(jsonData)) {
            console.log("🔧 Temel dosya format tespit edildi, default grup sistemi oluşturuluyor...");
            createDefaultGroupSystemForTemelDosya();
            showModernToast("Temel dosya format için A grubu ve soru atamaları oluşturuldu!", "success");
        }

        
        // Grup haritalama bilgilerini ÖNCE yükle
        console.log("🔧 Grup haritalama bilgileri yükleme çağrısı yapılıyor...");
        console.log("📄 JSON data kontrolü:", {
            hasJsonData: !!jsonData,
            hasDersDegerlendirme: !!jsonData.dersDegerlendirme,
            jsonKeys: Object.keys(jsonData)
        });
        
        // Fonksiyonun var olup olmadığını kontrol et
        if (typeof loadGroupMappingsFromAssessmentData === 'function') {
            console.log("✅ loadGroupMappingsFromAssessmentData fonksiyonu bulundu, çağrılıyor...");
            try {
                loadGroupMappingsFromAssessmentData(jsonData);
                console.log("✅ loadGroupMappingsFromAssessmentData çağrısı başarıyla tamamlandı");
            } catch (error) {
                console.error("❌ loadGroupMappingsFromAssessmentData çağrısında hata:", error);
            }
        } else {
            console.error("❌ loadGroupMappingsFromAssessmentData fonksiyonu bulunamadı!");
            console.log("🔍 Mevcut fonksiyonlar:", Object.keys(window).filter(key => key.includes('loadGroup')));
        }
        
        console.log("🔧 Grup haritalama bilgileri yükleme çağrısı tamamlandı");
        
        // Ağacı render et
        renderTree();
        
        // v5 format için ek grup bilgisi güncelleme
        setTimeout(() => {
            console.log("🔄 JSON import sonrası grup UI zorlamalı güncellemesi...");
            updateAllInlineGroupInputs();
            
            // Bileşen grup bilgilerini de güncelle
            document.querySelectorAll('.componentGroupInfo').forEach(input => {
                const componentId = input.dataset.componentId;
                if (componentId) {
                    updateComponentGroupInfo(componentId);
                }
            });
        }, 200);
        
        // Öğrencileri içe aktar
        let hasStudentData = false;
        
        // Format 1: ogrenciler dizisi
        if (jsonData.ogrenciler && Array.isArray(jsonData.ogrenciler)) {
            APP_STATE.studentData = jsonData.ogrenciler.map((student, index) => ({
                studentId: student.ogrenciNo,
                name: student.ad,
                surname: student.soyad,
                status: student.durum || 'Aktif',
                grup: student.grup || 'A', // Default grup ataması
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
            hasStudentData = true;
            showModernToast(`${APP_STATE.studentData.length} öğrenci verisi yüklendi.`, "success");
        } 
        // Format 2: students dizisi
        else if (jsonData.students && Array.isArray(jsonData.students)) {
            APP_STATE.studentData = jsonData.students.map((student, index) => ({
                studentId: student.studentId || student.student_id || student.ogrenciNo,
                name: student.name || student.ad,
                surname: student.surname || student.soyad, 
                status: student.status || student.durum || 'Aktif',
                grup: student.grup || student.group || 'A', // Default grup ataması
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
            hasStudentData = true;
            showModernToast(`${APP_STATE.studentData.length} öğrenci verisi yüklendi.`, "success");
        }
        // Format 3: courseData.ogrenciler
        else if (jsonData.courseData && jsonData.courseData.ogrenciler && Array.isArray(jsonData.courseData.ogrenciler)) {
            APP_STATE.studentData = jsonData.courseData.ogrenciler.map((student, index) => ({
                studentId: student.ogrenciNo,
                name: student.ad,
                surname: student.soyad,
                status: student.durum || 'Aktif',
                grup: student.grup || 'A', // Default grup ataması
                email: student.email || '', // Email bilgisini koru
                tcKimlik: student.tcKimlik || '', // TC Kimlik bilgisini koru
                telefon: student.telefon || '' // Telefon bilgisini koru
            }));
            hasStudentData = true;
            showModernToast(`${APP_STATE.studentData.length} öğrenci verisi yüklendi.`, "success");
        } else {
            showModernToast("JSON'da öğrenci verisi bulunamadı!", "warning");
        }
        
        // Öğrenci notları yükleme
        if (hasStudentData) {
            // Önce not verilerini sıfırla
            APP_STATE.gradesData = {};
            
            // Format 1: ogrenciNotlari (en yaygın format) - v5 formatını destekle
            if (jsonData.ogrenciNotlari && typeof jsonData.ogrenciNotlari === 'object') {
                // v5 formatını tam olarak destekle
                loadStudentGradesNewFormat(jsonData);
                const gradeCount = Object.keys(APP_STATE.gradesData).length;
                showModernToast(`${gradeCount} öğrencinin not verisi yüklendi (Tam Dosya format).`, "success");
            }
            // Format 2: grades
            else if (jsonData.grades && typeof jsonData.grades === 'object') {
                // Tam olarak kopyala - derin kopya
                APP_STATE.gradesData = JSON.parse(JSON.stringify(jsonData.grades));
                const gradeCount = Object.keys(APP_STATE.gradesData).length;
                showModernToast(`${gradeCount} öğrencinin not verisi yüklendi.`, "success");
            }
            // Format 3: rawGrades
            else if (jsonData.rawGrades && typeof jsonData.rawGrades === 'object') {
                // Tam olarak kopyala - derin kopya
                APP_STATE.gradesData = JSON.parse(JSON.stringify(jsonData.rawGrades));
                const gradeCount = Object.keys(APP_STATE.gradesData).length;
                showModernToast(`${gradeCount} öğrencinin not verisi yüklendi.`, "success");
            } else {
                showModernToast("JSON'da not verisi bulunamadı!", "warning");
            }
            
            // Grup sistem bilgilerini yükle ve doğrula
            if (jsonData.grupHaritalari && typeof jsonData.grupHaritalari === 'object') {
                // Grup haritalarını courseData'ya kaydet (derin kopya ile)
                if (!APP_STATE.courseData) {
                    APP_STATE.courseData = {};
                }
                APP_STATE.courseData.grupHaritalari = JSON.parse(JSON.stringify(jsonData.grupHaritalari));
                
                // Grup veri yapısını doğrula ve eksik kısımları tamamla
                validateAndCompleteGroupData();
                
                // Grup sistemini başlat
                initializeGroupSystem();
                
                console.log('Grup haritaları yüklendi ve doğrulandı:', APP_STATE.courseData.grupHaritalari);
                showModernToast("Grup haritaları yüklendi ve doğrulandı.", "success");
            } else {
                // Varsayılan grup sistemi başlat
                initializeGroupSystem();
                
                // Eğer öğrencilerde grup bilgisi eksikse, hepsini A grubuna ata ve sırala
                assignDefaultGroups();
                
                console.log('Varsayılan grup sistemi oluşturuldu');
                showModernToast("Varsayılan grup sistemi oluşturuldu.", "info");
            }
            
            // Öğrenci tablosunu güncelle
            updateStudentTable();
            
            // Grup seçicilerini güncelle
            updateGroupSelectors();
            
            // Dual range slider uyarısını güncelle
            const minSlider = document.getElementById('groupMinSlider');
            const maxSlider = document.getElementById('groupMaxSlider');
            if (minSlider && maxSlider) {
                updateDualRangeWarning(parseInt(minSlider.value), parseInt(maxSlider.value));
            }
        }
        
        // Değerlendirme görünümünü güncelle
        updateAssessmentView();
        
        // Öğrenci sayılarını güncelle (JSON yüklendikten sonra)
        if (hasStudentData) {
            const passRateSlider = document.getElementById('passRateSlider');
            if (passRateSlider) {
                const passRate = parseInt(passRateSlider.value);
                updateStudentCounts(passRate);
            }
            updatePassFailCounts();
        }
        
        closeModal(importModal);
        showModernToast("JSON verisi başarıyla yüklendi.");
        
        // Öğrenci verileri yüklendiyse değerlendirme sekmesine geç
        if (hasStudentData) {
            setTimeout(() => {
                switchTab('assessment');
            }, 500);
        }
        
    } catch (error) {
        console.error("JSON verisi uygulanırken hata oluştu:", error);
        showModernToast("JSON verisi uygulanamadı: " + error.message, "error");
    }
}

/**
 * Öğrenci dosyasını yükleme
 * @param {Event} event - Dosya seçme olayı
 */
function loadStudentJsonFromFile(event) {
    try {
        const file = event.target.files[0];
        if (!file) {
            showModernToast("Dosya seçilmedi.", "warning");
            return;
        }
        
        selectedStudentFileName.textContent = file.name;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                studentJsonContent.value = e.target.result;
                showModernToast("Öğrenci dosyası başarıyla yüklendi. Uygulamak için 'Uygula' butonuna tıklayın.");
            } catch (error) {
                console.error("Dosya okuma hatası:", error);
                showModernToast("Dosya okunamadı: " + error.message, "error");
            }
        };
        
        reader.onerror = function() {
            showModernToast("Dosya okuma hatası oluştu.", "error");
        };
        
        reader.readAsText(file);
    } catch (error) {
        console.error("Öğrenci dosyası yükleme hatası:", error);
        showModernToast("Öğrenci dosyası yüklenemedi: " + error.message, "error");
    }
}

/**
 * Öğrenci dosyasını doğrudan yükleme
 * @param {Event} event - Dosya seçme olayı
 */
function loadStudentsFromFile(event) {
    try {
        const file = event.target.files[0];
        if (!file) {
            showModernToast("Dosya seçilmedi.", "warning");
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                importStudentData(jsonData);
                showModernToast("Öğrenci listesi başarıyla yüklendi.");
            } catch (error) {
                console.error("Öğrenci verisi işleme hatası:", error);
                showModernToast("Öğrenci dosyası işlenemedi: " + error.message, "error");
            }
        };
        
        reader.onerror = function() {
            showModernToast("Dosya okuma hatası oluştu.", "error");
        };
        
        reader.readAsText(file);
    } catch (error) {
        console.error("Öğrenci dosyası yükleme hatası:", error);
        showModernToast("Öğrenci dosyası yüklenemedi: " + error.message, "error");
    }
}

/**
 * Not verilerini dosyaya kaydet
 */
function saveGradesToFile() {
    try {
        const data = exportGradesContent.value;
        
        // İçerik kontrolü
        if (!data || data.trim() === '') {
            showModernToast("Kaydedilecek veri bulunamadı!", "warning");
            return;
        }
        
        const isCSV = data.startsWith("Öğrenci No,Adı");
        const mimeType = isCSV ? 'text/csv' : 'application/json';
        const extension = isCSV ? 'csv' : 'json';
        
        const blob = new Blob([data], { type: mimeType });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        
        const dersKodu = APP_STATE.courseData?.dersGenel?.dersKodu || 'ders';
        const dateStr = new Date().toISOString().slice(0, 10);
        a.download = `${dersKodu}_notlar_${dateStr}.${extension}`;
        
        document.body.appendChild(a);
        a.click();
        
        // Temizlemeyi geciktir - indirme işleminin başlaması için zaman ver
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 200);
        
        showModernToast(`Not dosyası (.${extension}) başarıyla kaydedildi.`);
    } catch (error) {
        console.error("Not dosyası kaydedilirken hata oluştu:", error);
        showModernToast("Not dosyası kaydedilemedi: " + error.message, "error");
    }
}

/**
 * Test detayları modalını gösterme
 */
function showTestDetailsModal() {
    if (!APP_STATE.testDetailsNode) return;
    
    const node = APP_STATE.testDetailsNode;
    
    totalQuestionsInput.value = node.testDetails?.totalQuestions || 20;
    correctWeightInput.value = node.testDetails?.correctWeight || 5;
    wrongPenaltyInput.value = node.testDetails?.wrongPenalty || 0;
    
    openModal(testDetailsModal);
}

/**
 * Test detaylarını kaydetme
 */
function saveTestDetails() {
    if (!APP_STATE.testDetailsNode) return;
    
    try {
        const totalQuestions = parseInt(totalQuestionsInput.value) || 20;
        const correctWeight = parseFloat(correctWeightInput.value) || 5;
        const wrongPenalty = parseFloat(wrongPenaltyInput.value) || 0;
        
        APP_STATE.testDetailsNode.testDetails = {
            totalQuestions,
            correctWeight,
            wrongPenalty
        };
        
        // Toplam puanı hesapla
        APP_STATE.testDetailsNode.points = totalQuestions * correctWeight;
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
        
        // Modalı kapat
        closeModal(testDetailsModal);
        
        showModernToast("Test detayları kaydedildi.");
    } catch (error) {
        console.error("Test detayları kaydedilirken hata oluştu:", error);
        showModernToast("Test detayları kaydedilemedi!", "error");
    }
}

/**
 * Modali açma fonksiyonu
 * @param {HTMLElement} modal - Açılacak modal elementi
 */
function openModal(modal) {
    if (modal) {
        modal.style.display = 'flex';
    }
}

/**
 * Modali kapatma fonksiyonu
 * @param {HTMLElement} modal - Kapatılacak modal elementi
 */
function closeModal(modal) {
    if (modal) {
        modal.style.display = 'none';
    }
}


/**
 * Seçili sekmeyi değiştirme
 * @param {string} tabId - Sekme ID'si
 */
function switchTab(tabId) {
    const tabs = document.querySelectorAll('.nav-tab');
    const contents = document.querySelectorAll('.nav-content');
    
    // Önce tüm tabları pasif yap
    tabs.forEach(tab => tab.classList.remove('active'));
    contents.forEach(content => {
        content.classList.remove('active');
        content.style.display = 'none';
    });
    
    // Seçili tabı aktif yap
    const selectedTab = document.querySelector(`.nav-tab[data-tab="${tabId}"]`);
    const selectedContent = document.getElementById(`${tabId}-content`);
    
    if (selectedTab && selectedContent) {
        selectedTab.classList.add('active');
        selectedContent.classList.add('active');
        selectedContent.style.display = 'block';
        APP_STATE.currentActiveTabId = tabId;
        
        // Öğrenci bazlı not girişi sekmesi kaldırıldı
    }
}
/**
 * Tarihi okunabilir formata çevirme
 * @param {string} isoDate - ISO formatlı tarih
 * @returns {string} - Formatlanmış tarih
 */
function formatDate(isoDate) {
    if (!isoDate) return '';
    
    const date = new Date(isoDate);
    return date.toLocaleDateString('tr-TR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

/**
 * Dosya adından uzantıyı çıkarma
 * @param {string} filename - Dosya adı
 * @returns {string} - Uzantısız dosya adı
 */
function removeExtension(filename) {
    if (!filename) return '';
    return filename.replace(/\.[^/.]+$/, "");
}

// =====================================================
// EVENT LISTENERS VE GLOBAL FONKSİYONLAR
// =====================================================

// Global scope'a fonksiyonları ekle
window.updateStudentGrade = updateStudentGrade;
window.updateTestScore = updateTestScore;
window.updateStudentGradeFromStudentView = updateStudentGradeFromStudentView;
window.updateTestScoreFromStudentView = updateTestScoreFromStudentView;

// =====================================================
// OTOMATIK GÜNCELLEME SİSTEMİ
// =====================================================

/**
 * Değerlendirme ile ilgili bileşenleri günceller
 * updateAssessmentView içinden çağrılır
 */
function updateAssessmentRelatedComponents() {
    try {
        console.log('🔄 Değerlendirme bileşenleri güncelleniyor...');
        
        // Güncelleme işlemlerini sırayla yap (grup seçicileri hariç - HTML oluşturma sırasında yapılıyor)
        const updateOperations = [
            // { name: 'Grup seçicileri', func: () => updateGroupSelectors() }, // Kaldırıldı
            { name: 'ÖÇ görünümleri', func: () => updateOutcomesTextarea?.() },
            { name: 'Kategori ağırlıkları', func: () => updateCategoryWeights?.() },
            { name: 'Grup haritalama bilgileri', func: () => updateAllMappingDisplays?.() },
            { name: 'Maksimum puan bilgileri', func: () => addMaxPointsToInputs?.() },
            { name: 'Grup bilgileri', func: () => updateAllInlineGroupInputs?.() },
            { name: 'Öğrenci filtre seçenekleri', func: () => updateAssessmentStudentFilterOptions?.() }
        ];
        
        let successCount = 0;
        let errorCount = 0;
        
        updateOperations.forEach(operation => {
            try {
                if (operation.func) {
                    operation.func();
                    successCount++;
                    console.log(`✅ ${operation.name} güncellendi`);
                } else {
                    console.warn(`⚠️ ${operation.name} fonksiyonu bulunamadı`);
                }
            } catch (error) {
                errorCount++;
                console.error(`❌ ${operation.name} güncellenirken hata:`, error);
            }
        });
        
        console.log(`🔄 Değerlendirme bileşenleri güncellendi: ${successCount} başarılı, ${errorCount} hatalı`);
        
    } catch (error) {
        console.error('❌ updateAssessmentRelatedComponents genel hatası:', error);
    }
}

// =====================================================
// MEVCUT FONKSİYONLARA OTOMATİK GÜNCELLEME EKLEMESİ
// =====================================================

// Tüm olay dinleyicileri ayarla
// Tüm olay dinleyicileri ayarla
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Öğrenci bazlı not girişi sekmesi kaldırıldı - butonlar temizlendi
        
        // Not işlemleri butonları
        if (btnImportGrades) btnImportGrades.addEventListener('click', importGrades);
        if (btnSaveGrades) {
            btnSaveGrades.addEventListener('click', saveGrades);
            btnSaveGrades.addEventListener('click', saveGradesToFile);
        }
        
        // JSON işlemleri butonları
        if (btnImport) btnImport.addEventListener('click', () => openModal(importModal));
        if (closeImportModal) closeImportModal.addEventListener('click', () => closeModal(importModal));
        if (btnExport) {
            btnExport.addEventListener('click', () => {
                try {
                    // JSON verisi oluştur
                    const exportData = createExportData();
                    if (exportJsonContent) {
                        exportJsonContent.value = JSON.stringify(exportData, null, 2);
                    }
                    openModal(exportModal);
                } catch (error) {
                    console.error("JSON dışa aktarma hatası:", error);
                    showModernToast("JSON dışa aktarma işlemi başarısız oldu!", "error");
                }
            });
        }
        
        // Modal kapatma butonları
        if (closeExportModal) closeExportModal.addEventListener('click', () => closeModal(exportModal));
        if (closeImportStudentsModal) closeImportStudentsModal.addEventListener('click', () => closeModal(importStudentsModal));
        if (closeExportGradesModal) closeExportGradesModal.addEventListener('click', () => closeModal(exportGradesModal));
        if (closeTestDetailsModal) closeTestDetailsModal.addEventListener('click', () => closeModal(testDetailsModal));
        if (closeMultipleItemsModal) closeMultipleItemsModal.addEventListener('click', () => closeModal(multipleItemsModal));
        
        // Dosya işlemleri butonları
        if (btnSelectFile) btnSelectFile.addEventListener('click', () => fileInput && fileInput.click());
        if (btnApplyJson) btnApplyJson.addEventListener('click', applyJsonData);
        if (fileInput) fileInput.addEventListener('change', loadJsonFromFile);
        if (btnCopyJson) btnCopyJson.addEventListener('click', copyJsonToClipboard);
        if (btnSaveJson) btnSaveJson.addEventListener('click', saveJsonToFile);
        
        // Öğrenci işlemleri butonları
        if (btnImportStudents) btnImportStudents.addEventListener('click', () => openModal(importStudentsModal));
        if (btnSelectStudentFile) btnSelectStudentFile.addEventListener('click', () => studentJsonInput && studentJsonInput.click());
        if (btnApplyStudentJson) btnApplyStudentJson.addEventListener('click', applyStudentJsonData);
        if (studentJsonInput) studentJsonInput.addEventListener('change', loadStudentJsonFromFile);
        if (studentFileInput) studentFileInput.addEventListener('change', loadStudentsFromFile);
        // btnClearStudents event listener'ı aşağıda test butonları kısmında tanımlandı
        
        // Öğrenci listesi sekmesindeki temizleme butonu (farklı ID ve fonksiyon)
        const btnClearStudentList = document.getElementById('btnClearStudentList');
        if (btnClearStudentList) btnClearStudentList.addEventListener('click', clearStudents);
        
        // Not dışa aktarma butonları
        if (btnExportGradesJSON) btnExportGradesJSON.addEventListener('click', () => showExportGradesModal('json'));
        if (btnExportGradesExcel) btnExportGradesExcel.addEventListener('click', () => showExportGradesModal('csv'));
        if (btnCopyGrades) btnCopyGrades.addEventListener('click', copyGradesToClipboard);
        if (btnSaveGradesToFile) btnSaveGradesToFile.addEventListener('click', saveGradesToFile);
        if (btnCalculateGrades) btnCalculateGrades.addEventListener('click', calculateGrades);
        if (btnExportFinalGrades) btnExportFinalGrades.addEventListener('click', () => showExportGradesModal('csv'));
        
        // Test detayları butonları
        if (btnSaveTestDetails) btnSaveTestDetails.addEventListener('click', saveTestDetails);
        
        // İlk yüklemede status badge'leri güncelle
        updatePassFailCounts();
        
        // Sekme işlemleri için event listeners
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                if (tabId) switchTab(tabId);
            });
        });
        
        // Daha detaylı tab işlemleri
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                try {
                    // Aktif sekme sınıfını kaldır
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    
                    // Aktif içerik sınıfını kaldır
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Seçilen sekmeyi aktif yap
                    tab.classList.add('active');
                    
                    // İlgili içeriği göster
                    const tabId = tab.getAttribute('data-tab');
                    if (tabId) {
                        const contentElement = document.getElementById(`${tabId}Tab`);
                        if (contentElement) contentElement.classList.add('active');
                    }
                } catch (error) {
                    console.error("Tab işlemi hatası:", error);
                }
            });
        });
        
        // Etkinlik ekleme butonları
        if (btnAddTerm) btnAddTerm.addEventListener('click', addTermActivity);
        if (btnAddFinal) btnAddFinal.addEventListener('click', addFinalActivity);
        
        // Soru ve Rubrik ekleme butonları - seçili unsur olmasa da çalışmalı
        if (btnAddQuestion) btnAddQuestion.addEventListener('click', function() {
            // Çoklu soru eklemek için modal göster - seçili unsur kontrolü modal içinde yapılacak
            showMultipleItemsModal('soru');
        });
        
        if (btnAddRubric) btnAddRubric.addEventListener('click', function() {
            // Çoklu rubrik eklemek için modal göster - seçili unsur kontrolü modal içinde yapılacak
            showMultipleItemsModal('rubrik');
        });
        
        // Diğer ağaç işlem butonları
        if (btnRemove) btnRemove.addEventListener('click', removeNode);
        if (btnExpandAll) btnExpandAll.addEventListener('click', expandAll);
        if (btnCollapseAll) btnCollapseAll.addEventListener('click', collapseAll);
        
        // Rubrik ve soru türleri için click event
        document.querySelectorAll('.rubric-item').forEach(item => {
            item.addEventListener('click', function() {
                try {
                    if (!APP_STATE.selectedNode) {
                        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
                        return;
                    }
                    
                    // Seçili düğüm kök değilse alt düğüm eklenmemeli
                    if (APP_STATE.selectedNode.id.includes('.')) {
                        showModernToast("Rubrikler sadece ana etkinliklere eklenebilir.", "warning");
                        return;
                    }
                    
                    const rubricType = this.getAttribute('data-type');
                    const description = this.getAttribute('data-description');
                    addRubricToNode(APP_STATE.selectedNode, rubricType, description);
                } catch (error) {
                    console.error("Rubrik ekleme hatası:", error);
                    showModernToast("Rubrik eklenirken bir hata oluştu!", "error");
                }
            });
        });
        
        document.querySelectorAll('.question-type-item').forEach(item => {
            item.addEventListener('click', function() {
                try {
                    if (!APP_STATE.selectedNode) {
                        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
                        return;
                    }
                    
                    // Seçili düğüm kök değilse alt düğüm eklenmemeli
                    if (APP_STATE.selectedNode.id.includes('.')) {
                        showModernToast("Sorular sadece ana etkinliklere eklenebilir.", "warning");
                        return;
                    }
                    
                    const questionType = this.getAttribute('data-type');
                    
                    // Test türü için özel işlem
                    if (questionType === 'Test') {
                        addTestToNode(APP_STATE.selectedNode);
                        return;
                    }
                    
                    const description = this.getAttribute('data-description');
                    addQuestionToNode(APP_STATE.selectedNode, questionType, description);
                } catch (error) {
                    console.error("Soru ekleme hatası:", error);
                    showModernToast("Soru eklenirken bir hata oluştu!", "error");
                }
            });
        });
        
        // Öğrenme çıktıları için tıklama işlemleri
        document.querySelectorAll('.outcome-item').forEach(item => {
            item.addEventListener('click', function() {
                try {
                    if (APP_STATE.selectedNode) {
                        const outcomeId = this.getAttribute('data-id');
                        if (!outcomeId) return;
                        
                        const outcomesInput = document.querySelector(`.tree-node[data-id="${APP_STATE.selectedNode.id}"] .nodeOutcomes`);
                        if (outcomesInput) {
                            const currentValue = outcomesInput.value.trim();
                            
                            // Alt düğüm ise (soru veya rubrik), sadece bir ÖÇ atanabilsin
                            const isSubItem = APP_STATE.selectedNode.id.includes('.');
                            
                            if (isSubItem) {
                                outcomesInput.value = outcomeId;
                            } else {
                                // Değer boşsa veya virgülle bitiyorsa
                                if (!currentValue) {
                                    outcomesInput.value = outcomeId;
                                } else if (currentValue.endsWith(',')) {
                                    outcomesInput.value = currentValue + ' ' + outcomeId;
                                } else {
                                    outcomesInput.value = currentValue + ', ' + outcomeId;
                                }
                            }
                            
                            // Değeri değişmiş gibi tetikle
                            outcomesInput.dispatchEvent(new Event('change'));
                            
                            showModernToast(`"${outcomeId}" öğrenme çıktısı eklendi.`);
                        }
                    } else {
                        showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
                    }
                } catch (error) {
                    console.error("Öğrenme çıktısı ekleme hatası:", error);
                    showModernToast("Öğrenme çıktısı eklenirken bir hata oluştu!", "error");
                }
            });
        });
        
        // Tüm close-modal sınıfına sahip butonlara tıklama olayı ekle
        document.querySelectorAll('.close-modal').forEach(button => {
            button.addEventListener('click', function() {
                try {
                    // En yakın modal elementini bul
                    const modal = this.closest('.modal');
                    if (modal) {
                        closeModal(modal);
                    }
                } catch (error) {
                    console.error("Modal kapatma hatası:", error);
                }
            });
        });
        
        // İtem tipi değişikliğini dinle (çoklu öğe ekleme modalında)
        if (itemType) {
            itemType.addEventListener('change', function() {
                try {
                    const type = this.value;
                    if (questionTypeContainer && rubricTypeContainer) {
                        if (type === 'soru') {
                            questionTypeContainer.style.display = 'block';
                            rubricTypeContainer.style.display = 'none';
                        } else {
                            questionTypeContainer.style.display = 'none';
                            rubricTypeContainer.style.display = 'block';
                        }
                    }
                } catch (error) {
                    console.error("Tip değişikliği hatası:", error);
                }
            });
        }
        
        // Çoklu öğe ekleme butonunu dinle
        if (btnAddMultipleItems) {
            btnAddMultipleItems.addEventListener('click', addMultipleItems);
        }
        
        // İlk açılışta aktif sekmeyi ayarla
        switchTab(APP_STATE.currentActiveTabId || 'definition');

		// Puan dağıtma butonu
		const btnDistributePoints = document.getElementById('btnDistributePoints');
		if (btnDistributePoints) {
			btnDistributePoints.addEventListener('click', function() {
				if (!APP_STATE.selectedNode) {
					showModernToast("Lütfen önce bir etkinlik seçin.", "warning");
					return;
				}
				
				// Eğer alt düğüm seçiliyse üst düğümü bul
				let parentNode = APP_STATE.selectedNode;
				if (parentNode.id.includes('.')) {
					const parentId = parentNode.id.substring(0, parentNode.id.lastIndexOf('.'));
					parentNode = findNodeById(parentId);
				}
				
				// Puanları dağıt
				if (parentNode && parentNode.children && parentNode.children.length > 0) {
					// Alt öğelerin toplam ağırlığını hesapla
					const totalWeight = parentNode.children.reduce((sum, child) => sum + (parseInt(child.weight) || 0), 0);
					
					// Dağıtım modalını göster
					showDistributePointsModal(parentNode, totalWeight);
				} else {
					showModernToast("Seçilen etkinliğin alt öğeleri bulunmuyor.", "warning");
				}
			});
		}
		
		
		// Test dağılım butonu
		const btnDistributeTestScores = document.getElementById('btnDistributeTestScores');
		if (btnDistributeTestScores) {
			btnDistributeTestScores.addEventListener('click', function() {
				if (!APP_STATE.testDetailsNode) {
					showModernToast("Test detayları bulunamadı.", "error");
					return;
				}
				
				// Test detaylarını al
				const testId = APP_STATE.testDetailsNode.id;
				const totalQuestions = parseInt(totalQuestionsInput.value) || 20;
				
				// Öğrenci verileri var mı kontrol et
				if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
					showModernToast("Öğrenci verisi bulunamadı.", "warning");
					return;
				}
				
				// İşlemi onaylamak için modern onay modalı göster
				showDeleteConfirmModal(
					// Onay verildiğinde çalışacak fonksiyon
					function() {
						// Her öğrenci için rastgele doğru/yanlış sayısı belirle ve dağılım yap
						APP_STATE.studentData.forEach(student => {
							const studentId = student.studentId;
							
							// Rastgele doğru sayısı üret
							const correct = Math.floor(Math.random() * (totalQuestions + 1));
							
							// Rastgele yanlış sayısı üret (toplam soruyu geçmeyecek şekilde)
							const maxWrong = totalQuestions - correct;
							const wrong = Math.floor(Math.random() * (maxWrong + 1));
							
							// Not verilerini kaydeden yardımcı fonksiyon kullan
							// (saveTestDistribution fonksiyonunu kullan, modal göstermeyen)
							saveTestDistribution(studentId, testId, correct, wrong);
						});
						
						// Değerlendirme görünümünü güncelle
						updateAssessmentView();
						
						showModernToast("Tüm öğrenciler için rastgele test puanları oluşturuldu ve dağıtıldı.", "success");
					},
					// Onay mesajı
					"Tüm öğrenciler için rastgele test puanları oluşturmak istediğinizden emin misiniz?"
				);
			});
		}
				
        
        // Varsayılan grup ataması yap
        assignDefaultGroups();
        
        console.log("Tüm olay dinleyicileri başarıyla yüklendi.");
    } catch (error) {
        console.error("Olay dinleyicileri yüklenirken hata oluştu:", error);
        showModernToast("Uygulama başlatılırken bir hata oluştu. Lütfen sayfayı yenileyin veya daha sonra tekrar deneyin.", "error", 8000);
    }
});

/**
 * Alan adlarını normalleştirme (İngilizce/Türkçe uyumu)
 */
function normalizeGradeFields() {
    try {
        if (!APP_STATE.gradesData) return;
        
        // Tüm öğrenciler için
        Object.keys(APP_STATE.gradesData).forEach(studentId => {
            const studentGrades = APP_STATE.gradesData[studentId];
            
            // Hesaplanmış notlar için standart alanları ekle/normalleştir
            if (studentGrades.yariyilIciNotu !== undefined || studentGrades.termGrade !== undefined) {
                const termGrade = studentGrades.yariyilIciNotu || studentGrades.termGrade || 0;
                studentGrades.yariyilIciNotu = parseFloat(termGrade);
                studentGrades.termGrade = parseFloat(termGrade);
            }
            
            if (studentGrades.yariyilSonuNotu !== undefined || studentGrades.finalGrade !== undefined) {
                const finalGrade = studentGrades.yariyilSonuNotu || studentGrades.finalGrade || 0;
                studentGrades.yariyilSonuNotu = parseFloat(finalGrade);
                studentGrades.finalGrade = parseFloat(finalGrade);
            }
            
            if (studentGrades.basariNotu !== undefined || studentGrades.totalGrade !== undefined) {
                const totalGrade = studentGrades.basariNotu || studentGrades.totalGrade || 0;
                studentGrades.basariNotu = parseFloat(totalGrade);
                studentGrades.totalGrade = parseFloat(totalGrade);
            }
            
            if (studentGrades.harfNotu !== undefined || studentGrades.letterGrade !== undefined) {
                const letterGrade = studentGrades.harfNotu || studentGrades.letterGrade || 'FF';
                studentGrades.harfNotu = letterGrade;
                studentGrades.letterGrade = letterGrade;
            }
            
            // Tüm aktiviteler için
            Object.keys(studentGrades).forEach(activityId => {
                const grade = studentGrades[activityId];
                
                // Nesne ise ve test skorlarını içeriyorsa
                if (typeof grade === 'object' && grade !== null) {
                    // Type/tip alanlarını kontrol et
                    if (grade.type === 'test' || grade.tip === 'test') {
                        // Her iki dilde de alanları ayarla
                        grade.type = 'test';
                        grade.tip = 'test';
                        
                        // Doğru sayısı için
                        if (grade.correct !== undefined || grade.dogru !== undefined) {
                            const correctValue = grade.correct !== undefined ? grade.correct : grade.dogru;
                            grade.correct = correctValue;
                            grade.dogru = correctValue;
                        }
                        
                        // Yanlış sayısı için
                        if (grade.wrong !== undefined || grade.yanlis !== undefined) {
                            const wrongValue = grade.wrong !== undefined ? grade.wrong : grade.yanlis;
                            grade.wrong = wrongValue;
                            grade.yanlis = wrongValue;
                        }
                    }
                    
                    // Alt nesneleri kontrol et (iç içe yapı için)
                    Object.keys(grade).forEach(subKey => {
                        const subGrade = grade[subKey];
                        if (typeof subGrade === 'object' && subGrade !== null) {
                            if (subGrade.type === 'test' || subGrade.tip === 'test') {
                                // Her iki dilde de alanları ayarla
                                subGrade.type = 'test';
                                subGrade.tip = 'test';
                                
                                // Doğru sayısı için
                                if (subGrade.correct !== undefined || subGrade.dogru !== undefined) {
                                    const correctValue = subGrade.correct !== undefined ? subGrade.correct : subGrade.dogru;
                                    subGrade.correct = correctValue;
                                    subGrade.dogru = correctValue;
                                }
                                
                                // Yanlış sayısı için
                                if (subGrade.wrong !== undefined || subGrade.yanlis !== undefined) {
                                    const wrongValue = subGrade.wrong !== undefined ? subGrade.wrong : subGrade.yanlis;
                                    subGrade.wrong = wrongValue;
                                    subGrade.yanlis = wrongValue;
                                }
                            }
                        }
                    });
                }
            });
        });
    } catch (error) {
        console.error("Not alanları normalleştirilirken hata oluştu:", error);
    }
}

/**
 * Hesaplanmış notları güncelleme
 */
function updateCalculatedGrades() {
    try {
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            return;
        }
        
        APP_STATE.studentData.forEach(student => {
            const studentId = student.studentId;
            
            // Yarıyıl içi etkinlikler
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            let termGrade = 0;
            
            // İç ağırlık toplamı
            const termInternalTotal = termActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
            
            if (termInternalTotal > 0) {
                termActivities.forEach(activity => {
                    // İç ağırlık normalleştirmesi
                    const activityWeight = activity.weight / termInternalTotal; 
                    let activityGrade = 0;
                    
                    if (activity.children && activity.children.length > 0) {
                        // Alt etkinlikler
                        const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                        
                        if (childrenTotalWeight > 0) {
                            activity.children.forEach(subItem => {
                                // Alt öğe ağırlık normalleştirmesi
                                const subItemWeight = subItem.weight / childrenTotalWeight; 
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                                const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                                activityGrade += scaledGrade * subItemWeight;
                            });
                        }
                    } else {
                        // Basit etkinlik
                        const grade = getStudentGrade(studentId, activity.id) || 0;
                        activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                    }
                    
                    termGrade += activityGrade * activityWeight;
                });
            }
            
            // Yarıyıl sonu etkinlikler
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            let finalGrade = 0;
            
            // İç ağırlık toplamı
            const finalInternalTotal = finalActivities.reduce((sum, node) => sum + parseFloat(node.weight || 0), 0);
            
            if (finalInternalTotal > 0) {
                finalActivities.forEach(activity => {
                    // İç ağırlık normalleştirmesi
                    const activityWeight = activity.weight / finalInternalTotal;
                    let activityGrade = 0;
                    
                    if (activity.children && activity.children.length > 0) {
                        // Alt etkinlikler
                        const childrenTotalWeight = activity.children.reduce((sum, child) => sum + parseFloat(child.weight || 0), 0);
                        
                        if (childrenTotalWeight > 0) {
                            activity.children.forEach(subItem => {
                                // Alt öğe ağırlık normalleştirmesi
                                const subItemWeight = subItem.weight / childrenTotalWeight;
                            const grade = getStudentGrade(studentId, subItem.id) || 0;
                                const scaledGrade = (grade / (subItem.points || 1)) * 100; // 100 üzerinden
                                activityGrade += scaledGrade * subItemWeight;
                            });
                        }
                    } else {
                        // Basit etkinlik
                        const grade = getStudentGrade(studentId, activity.id) || 0;
                        activityGrade = (grade / (activity.points || 1)) * 100; // 100 üzerinden
                    }
                    
                    finalGrade += activityGrade * activityWeight;
                });
            }
            
            // Toplam ve harf notu
            const totalGrade = (termGrade * APP_STATE.termWeight / 100) + (finalGrade * APP_STATE.finalWeight / 100);
            const letterGrade = getLetterGrade(totalGrade);
            
            // Öğrenci notları nesnesini oluştur
            if (!APP_STATE.gradesData[studentId]) {
                APP_STATE.gradesData[studentId] = {};
            }
            
            // Yarıyıl içi, sonu ve toplam not bilgilerini ekle
            APP_STATE.gradesData[studentId].yariyilIciNotu = parseFloat(termGrade.toFixed(2));
            APP_STATE.gradesData[studentId].yariyilSonuNotu = parseFloat(finalGrade.toFixed(2));
            APP_STATE.gradesData[studentId].basariNotu = parseFloat(totalGrade.toFixed(2));
            APP_STATE.gradesData[studentId].harfNotu = letterGrade;
        });
    } catch (error) {
        console.error("Notlar hesaplanırken hata oluştu:", error);
    }
}

// Öğrenci bazlı not girişi sekmesi kaldırıldı - updateStudentSelector fonksiyonu temizlendi

// Öğrenci bazlı not girişi sekmesi kaldırıldı - showStudentGrades fonksiyonu temizlendi

/**
 * Öğrenci görünümünde etkinlik bölümü oluşturma
 * @param {Object} student - Öğrenci
 * @param {Object} activity - Etkinlik
 * @returns {string} - HTML içeriği
 */
function createStudentActivitySection(student, activity) {
    try {
        let html = `
            <div class="student-activity" data-activity-id="${activity.id}">
                <h5>${activity.name} <span class="badge badge-primary">${activity.weight}%</span></h5>
        `;
        
        // Aktivitenin alt öğeleri var mı kontrol et
        if (activity.children && activity.children.length > 0) {
            // Alt öğeler var, her biri için giriş alanı oluştur
            html += '<div class="student-subitems">';
            
            activity.children.forEach(subItem => {
                if (subItem.type === 'Test') {
                    html += createStudentTestInputSection(student, subItem);
                } else {
                    html += createStudentSubItemInputSection(student, subItem);
                }
            });
            
            html += '</div>';
        } else {
            // Alt öğe yoksa basit bir puan girişi göster
            const grade = getStudentGrade(student.studentId, activity.id) || '';
            
            html += `
                <div class="student-grade-input">
                    <label>Puan:</label>
                    <input type="number" min="0" max="${activity.points}" 
                        data-student-id="${student.studentId}" 
                        data-activity-id="${activity.id}" 
                        value="${grade}"
                        onchange="updateStudentGradeFromStudentView(this)">
                    <span>/ ${activity.points}</span>
                </div>
            `;
        }
        
        html += '</div>';
        return html;
    } catch (error) {
        console.error("Öğrenci etkinlik bölümü oluşturulurken hata oluştu:", error);
        return '<div class="error-message">Etkinlik bilgileri yüklenemedi.</div>';
    }
}

/**
 * Öğrenci görünümünde alt öğe giriş bölümü oluşturma (Soru/Rubrik)
 * @param {Object} student - Öğrenci
 * @param {Object} subItem - Alt öğe
 * @returns {string} - HTML içeriği
 */
function createStudentSubItemInputSection(student, subItem) {
    try {
        // Üst bileşen ID'sini bul
        const parentComponentId = getParentComponentId(subItem.id) || subItem.id;
        const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
        const useGroupSystem = component && component.gruplar && component.gruplar.length > 1;
        
        if (!useGroupSystem || !subItem.children || subItem.children.length === 0) {
            // Grup sistemi yok veya alt sorular yok - basit giriş
        const grade = getStudentGrade(student.studentId, subItem.id) || '';
        
        return `
            <div class="student-subitem" data-subitem-id="${subItem.id}">
                <div class="subitem-header">
                    <span>${subItem.name}</span>
                    <span class="badge badge-primary">${subItem.points} puan</span>
                    <span class="badge badge-success">${subItem.outcomes.join(', ')}</span>
                </div>
                <div class="student-grade-input">
                    <input type="number" min="0" max="${subItem.points}" 
                        data-student-id="${student.studentId}" 
                        data-activity-id="${subItem.id}" 
                        value="${grade}"
                        onchange="updateStudentGradeFromStudentView(this)">
                    <span>/ ${subItem.points}</span>
                </div>
            </div>
        `;
        }
        
        // Grup sistemi var ve alt sorular var - detaylı tablo (Öğrenci bazlı görünüm)
        const componentDisplayName = getComponentDisplayName(parentComponentId);
        const studentCurrentGroup = getStudentGroupForComponent(student.studentId, parentComponentId);
        
        let html = `
            <div class="student-subitem" data-subitem-id="${subItem.id}" data-component-id="${parentComponentId}">
                <div class="subitem-header">
                    <span>${componentDisplayName}</span>
                    <span class="badge badge-primary">${subItem.points} puan</span>
                    <span class="badge badge-success">${subItem.outcomes.join(', ')}</span>
                    <span class="badge badge-info">Grup: ${studentCurrentGroup}</span>
                </div>
                <div class="subitem-questions-table">
                    <table class="assessment-table">
                        <thead>
                            <tr>
                                <th>Kağıt Sırası</th>
                                <th>Soru Sırası</th>
                                <th>Etkinlik Adı<br/><small>(Soru/Rubrik)</small></th>
                                <th>Açıklama</th>
                                <th>Etkinlik Max. Puan<br/><small>(Soru/Rubrik)</small></th>
                                <th>Toplam Puan</th>
                                <th>ÖÇ</th>
                                                <th>Alınan Puan<br/><small>(Etkinlik Puanı)</small></th>
            </tr>
        </thead>
        <tbody>
        `;
        
        // Her soru için satır oluştur (Öğrenci bazlı görünüm - grup seçici yok)
        subItem.children.forEach((question, paperOrder) => {
            const actualQuestionId = getQuestionIdByPaperOrder(student.studentId, paperOrder + 1, parentComponentId);
            const actualQuestion = findNodeById(actualQuestionId);
            const answerKeyOrder = getAnswerKeyOrder(student.studentId, paperOrder + 1, parentComponentId);
            
            // Soru bilgilerini al
            const questionName = `Soru ${answerKeyOrder || paperOrder + 1}`;
            const questionDescription = actualQuestion?.description || actualQuestion?.name || '-';
            const questionPointsForGroup = getQuestionPointsForStudentGroup(student.studentId, actualQuestionId, parentComponentId);
            const maxPoints = questionPointsForGroup || actualQuestion?.points || 0;
            const studentOutcomes = getQuestionOutcomesForStudent(student.studentId, actualQuestionId, parentComponentId);
            
            // Mevcut puanı al
            const currentGrade = getStudentGrade(student.studentId, actualQuestionId) || '';
            
            html += `
                <tr data-question-id="${actualQuestionId}" data-paper-order="${paperOrder + 1}" data-student-id="${student.studentId}" data-component-id="${parentComponentId}">
                    <td class="paper-order-cell">
                        <span class="paper-order-badge">${paperOrder + 1}</span>
                    </td>
                    <td class="answer-key-order-cell">
                        <span class="answer-key-badge">${answerKeyOrder}</span>
                    </td>
                    <td class="question-name-cell">
                        <span class="question-name-badge">${questionName}</span>
                    </td>
                    <td class="question-description-cell">
                        <span class="question-desc-badge" title="${questionDescription}">${questionDescription}</span>
                    </td>
                    <td class="points-cell">
                        <span class="points-badge">${maxPoints}</span>
                    </td>
                    <td class="total-points-cell">
                        <span class="total-points-badge">${getStudentTotalEarnedPointsForComponent(student.studentId, parentComponentId)}</span>
                    </td>
                    <td class="outcomes-cell">
                        <span class="outcomes-badge">${Array.isArray(studentOutcomes) ? studentOutcomes.join(', ') : (studentOutcomes || '-')}</span>
                    </td>
                    <td class="grade-input-cell">
                        <input type="number" 
                               min="0" 
                               max="${maxPoints}" 
                               step="0.1"
                               class="grade-input" 
                               data-student-id="${student.studentId}" 
                               data-activity-id="${actualQuestionId}" 
                               value="${currentGrade}"
                               onchange="updateStudentGradeFromStudentView(this)">
                    </td>
                </tr>
            `;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        </div>
        `;
        
        return html;
    } catch (error) {
        console.error("Alt öğe giriş bölümü oluşturulurken hata oluştu:", error);
        return '<div class="error-message">Alt öğe bilgileri yüklenemedi.</div>';
    }
}

/**
 * Öğrenci görünümünde test giriş bölümü oluşturma
 * @param {Object} student - Öğrenci
 * @param {Object} testItem - Test öğesi
 * @returns {string} - HTML içeriği
 */
function createStudentTestInputSection(student, testItem) {
    try {
        // Üst bileşen ID'sini bul
        const parentComponentId = getParentComponentId(testItem.id) || testItem.id;
        const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
        const useGroupSystem = component && component.gruplar && component.gruplar.length > 1;
        
        if (!useGroupSystem || !testItem.children || testItem.children.length === 0) {
            // Grup sistemi yok veya soru detayları yok - basit test girişi
        const testScore = getStudentTestScore(student.studentId, testItem.id);
        const correct = testScore?.correct || 0;
        const wrong = testScore?.wrong || 0;
        const totalScore = correct * testItem.testDetails.correctWeight - wrong * Math.abs(testItem.testDetails.wrongPenalty);
        
        return `
            <div class="student-subitem student-test-item" data-subitem-id="${testItem.id}">
                <div class="subitem-header">
                    <span>${testItem.name}</span>
                    <span class="badge badge-primary">${testItem.points} puan</span>
                    <span class="badge badge-success">${testItem.outcomes.join(', ')}</span>
                </div>
                <div class="test-info">
                    <p>Toplam ${testItem.testDetails.totalQuestions} soru, her doğru: ${testItem.testDetails.correctWeight} puan, her yanlış: ${testItem.testDetails.wrongPenalty} puan</p>
                </div>
                <div class="test-inputs">
                    <div class="student-grade-input">
                        <label>Doğru:</label>
                        <input type="number" min="0" max="${testItem.testDetails.totalQuestions}" 
                            data-student-id="${student.studentId}" 
                            data-test-id="${testItem.id}" 
                            data-field="correct"
                            value="${correct}"
                            onchange="updateTestScoreFromStudentView(this)">
                    </div>
                    <div class="student-grade-input">
                        <label>Yanlış:</label>
                        <input type="number" min="0" max="${testItem.testDetails.totalQuestions}" 
                            data-student-id="${student.studentId}" 
                            data-test-id="${testItem.id}" 
                            data-field="wrong"
                            value="${wrong}"
                            onchange="updateTestScoreFromStudentView(this)">
                    </div>
                    <div class="student-grade-input">
                        <label>Toplam:</label>
                        <span class="total-test-score">${totalScore.toFixed(2)}</span>
                    </div>
                </div>
            </div>
        `;
        }
        
        // Grup sistemi var ve soru detayları var - detaylı tablo (Öğrenci bazlı görünüm)
        const componentDisplayName = getComponentDisplayName(parentComponentId);
        const studentCurrentGroup = getStudentGroupForComponent(student.studentId, parentComponentId);
        
        let html = `
            <div class="student-subitem student-test-item" data-subitem-id="${testItem.id}" data-component-id="${parentComponentId}">
                <div class="subitem-header">
                    <span>${componentDisplayName}</span>
                    <span class="badge badge-primary">${testItem.points} puan</span>
                    <span class="badge badge-success">${testItem.outcomes.join(', ')}</span>
                    <span class="badge badge-info">Grup: ${studentCurrentGroup}</span>
                </div>
                <div class="test-questions-table">
                    <table class="assessment-table">
                        <thead>
                            <tr>
                                <th>Kağıt Sırası</th>
                                <th>Soru Sırası</th>
                                <th>Etkinlik Adı<br/><small>(Soru/Rubrik)</small></th>
                                <th>Açıklama</th>
                                <th>Etkinlik Max. Puan<br/><small>(Soru/Rubrik)</small></th>
                                <th>Toplam Puan</th>
                                <th>ÖÇ</th>
                                                <th>Alınan Puan<br/><small>(Etkinlik Puanı)</small></th>
            </tr>
        </thead>
        <tbody>
        `;
        
        // Her soru için satır oluştur (Öğrenci bazlı görünüm - grup seçici yok)
        testItem.children.forEach((question, paperOrder) => {
            const actualQuestionId = getQuestionIdByPaperOrder(student.studentId, paperOrder + 1, parentComponentId);
            const actualQuestion = findNodeById(actualQuestionId);
            const answerKeyOrder = getAnswerKeyOrder(student.studentId, paperOrder + 1, parentComponentId);
            
            // Soru bilgilerini al
            const questionName = `Soru ${answerKeyOrder || paperOrder + 1}`;
            const questionDescription = actualQuestion?.description || actualQuestion?.name || '-';
            const questionPointsForGroup = getQuestionPointsForStudentGroup(student.studentId, actualQuestionId, parentComponentId);
            const maxPoints = questionPointsForGroup || actualQuestion?.points || 0;
            const studentOutcomes = getQuestionOutcomesForStudent(student.studentId, actualQuestionId, parentComponentId);
            
            // Mevcut puanı al
            const currentGrade = getStudentGrade(student.studentId, actualQuestionId) || '';
            
            html += `
                <tr data-question-id="${actualQuestionId}" data-paper-order="${paperOrder + 1}" data-student-id="${student.studentId}" data-component-id="${parentComponentId}">
                    <td class="paper-order-cell">
                        <span class="paper-order-badge">${paperOrder + 1}</span>
                    </td>
                    <td class="answer-key-order-cell">
                        <span class="answer-key-badge">${answerKeyOrder}</span>
                    </td>
                    <td class="question-name-cell">
                        <span class="question-name-badge">${questionName}</span>
                    </td>
                    <td class="question-description-cell">
                        <span class="question-desc-badge" title="${questionDescription}">${questionDescription}</span>
                    </td>
                    <td class="points-cell">
                        <span class="points-badge">${maxPoints}</span>
                    </td>
                    <td class="total-points-cell">
                        <span class="total-points-badge">${getStudentTotalEarnedPointsForComponent(student.studentId, parentComponentId)}</span>
                    </td>
                    <td class="outcomes-cell">
                        <span class="outcomes-badge">${Array.isArray(studentOutcomes) ? studentOutcomes.join(', ') : (studentOutcomes || '-')}</span>
                    </td>
                    <td class="grade-input-cell">
                        <input type="number" 
                               min="0" 
                               max="${maxPoints}" 
                               step="0.1"
                               class="grade-input" 
                               data-student-id="${student.studentId}" 
                               data-activity-id="${actualQuestionId}" 
                               value="${currentGrade}"
                               onchange="updateStudentGradeFromStudentView(this)">
                    </td>
                </tr>
            `;
        });
        
        html += `
                    </tbody>
                </table>
            </div>
        </div>
        `;
        
        return html;
    } catch (error) {
        console.error("Test giriş bölümü oluşturulurken hata oluştu:", error);
        return '<div class="error-message">Test bilgileri yüklenemedi.</div>';
    }
}

/**
 * Öğrenci görünümünden not güncelleme
 * @param {HTMLInputElement} input - Not input elementi
 */
function updateStudentGradeFromStudentView(input) {
    try {
        const studentId = input.dataset.studentId;
        const activityId = input.dataset.activityId;
        
        // Aktiviteyi bul ve maksimum puanını kontrol et
        const activity = findNodeById(activityId);
        if (!activity) {
            console.error(`Aktivite bulunamadı: ${activityId}`);
            return;
        }
        
        // Maksimum puan kontrolü
        const maxPoints = activity.points || 100;
        let value = parseFloat(input.value) || 0;
        
        // Maksimum puanı aşan değerleri sınırla
        if (value > maxPoints) {
            value = maxPoints;
            input.value = maxPoints;
            showModernToast(`Dikkat: Puan ${maxPoints} değerinden büyük olamaz!`, "warning");
        }
        
        // Öğrenci verisi oluştur
        if (!APP_STATE.gradesData[studentId]) {
            APP_STATE.gradesData[studentId] = {};
        }
        
        // Test mi kontrol et
        if (activity && activity.type === 'Test') {
            // Test skorları için özel işlem
            const correctWeight = activity.testDetails?.correctWeight || 5;
            const wrongPenalty = Math.abs(activity.testDetails?.wrongPenalty || 0);
            
            // Basit yaklaşım: tüm puanı doğru sorudan gelecek şekilde ayarla
            const correctEstimate = Math.round(value / correctWeight);
            
            APP_STATE.gradesData[studentId][activityId] = {
                tip: 'test',
                dogru: correctEstimate,
                yanlis: 0
            };
            
            // Değerlendirme sekmesindeki form elementlerini bul ve güncelle
            const assessmentCorrectInput = document.querySelector(`#assessment-content input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="correct"]`);
            const assessmentWrongInput = document.querySelector(`#assessment-content input[data-student-id="${studentId}"][data-test-id="${activityId}"][data-field="wrong"]`);
            
            if (assessmentCorrectInput) assessmentCorrectInput.value = correctEstimate;
            if (assessmentWrongInput) assessmentWrongInput.value = 0;
            
            // Total score'u güncelle
            const assessmentTotalScore = document.querySelector(`#assessment-content tr:has(input[data-student-id="${studentId}"][data-test-id="${activityId}"]) .total-score`);
            if (assessmentTotalScore) {
                assessmentTotalScore.textContent = value.toFixed(2);
            }
            
        } else {
            // Normal not için
            APP_STATE.gradesData[studentId][activityId] = value;
            
            // Alt düğüm yapısını oluştur (A1.1 -> A1 altında storlama)
            const parts = activityId.split('.');
            if (parts.length > 1) {
                const parentId = parts[0]; // A1
                const shortId = parts[parts.length - 1]; // 1
                
                // Eğer üst aktivite yoksa oluştur
                if (!APP_STATE.gradesData[studentId][parentId]) {
                    APP_STATE.gradesData[studentId][parentId] = {
                        toplam: 0
                    };
                }
                
                // Not değerini ekle - hem tam ID, hem kısa ID olarak
                APP_STATE.gradesData[studentId][parentId][activityId] = value;
                APP_STATE.gradesData[studentId][parentId][shortId] = value;
                
                // Toplama hesapla
                updateParentActivityTotal(studentId, parentId);
            }
            
            // Değerlendirme sekmesindeki aynı inputu güncelle
            const assessmentInput = document.querySelector(`#assessment-content input[data-student-id="${studentId}"][data-activity-id="${activityId}"]`);
            if (assessmentInput && assessmentInput !== input) {
                assessmentInput.value = value;
            }
        }
        
        // Notları yeniden hesapla
        updateStudentCalculatedGrade(studentId);
        
        // Assessment tablosundaki not özeti hücrelerini güncelle
        updateAssessmentGradeSummary(studentId);
        
        // Özetleme bölümünü güncelle
        updateStudentSummary(studentId);
        
    } catch (error) {
        console.error("Öğrenci notu güncellenirken hata oluştu:", error);
        showModernToast("Not güncellenirken hata oluştu!", "error");
    }
}

/**
 * Öğrenci görünümünde test skorunu güncelleme
 * @param {HTMLInputElement} input - Test skoru input elementi
 */
function updateTestScoreFromStudentView(input) {
    try {
        const studentId = input.dataset.studentId;
        const testId = input.dataset.testId;
        const field = input.dataset.field;
        const value = parseInt(input.value) || 0;
        
        // Önce verileri güncelle
        updateTestScoreData(studentId, testId, field, value);
        
        // Değerlendirme sekmesindeki karşılık gelen test score alanlarını güncelle
        const assessmentInput = document.querySelector(`#assessment-content input[data-student-id="${studentId}"][data-test-id="${testId}"][data-field="${field}"]`);
        if (assessmentInput && assessmentInput !== input) {
            assessmentInput.value = value;
            // Event'i manuel tetikle
            assessmentInput.dispatchEvent(new Event('change'));
        }
        
        // Yalnızca öğrenci görünümündeki toplam skoru güncelle
        updateStudentViewTestTotal(studentId, testId);
        
        // Notları yeniden hesapla
        updateStudentCalculatedGrade(studentId);
        
        // Assessment tablosundaki not özeti hücrelerini güncelle
        updateAssessmentGradeSummary(studentId);
        
        // Özetleme bölümünü güncelle
        updateStudentSummary(studentId);
        
    } catch (error) {
        console.error("Test skoru güncellenirken hata oluştu:", error);
        showModernToast("Test skoru güncellenirken hata oluştu!", "error");
    }
}

// Test skoru verilerini güncelleme (yardımcı fonksiyon)
function updateTestScoreData(studentId, testId, field, value) {
    // Test düğümünü bul
    const testNode = findNodeById(testId);
    if (!testNode) return;
    
    // Öğrenci notları henüz yoksa oluştur
    if (!APP_STATE.gradesData[studentId]) {
        APP_STATE.gradesData[studentId] = {};
    }
    
    // Test notları henüz yoksa oluştur
    if (!APP_STATE.gradesData[studentId][testId]) {
        APP_STATE.gradesData[studentId][testId] = {
            tip: 'test',
            dogru: 0,
            yanlis: 0
        };
    }
    
    // İlgili alanı güncelle
    if (field === 'correct') {
        APP_STATE.gradesData[studentId][testId].dogru = value;
    } else if (field === 'wrong') {
        APP_STATE.gradesData[studentId][testId].yanlis = value;
    } else {
        APP_STATE.gradesData[studentId][testId][field] = value;
    }
    
    // Doğru ve yanlış sayılarını kontrol et
    const testScore = APP_STATE.gradesData[studentId][testId];
    const correct = testScore.dogru || 0;
    const wrong = testScore.yanlis || 0;
    const totalQuestions = testNode.testDetails.totalQuestions;
    
    // Doğru ve yanlış toplamı toplam soru sayısını geçemez
    if (correct + wrong > totalQuestions) {
        showModernToast(`Dikkat: Doğru ve yanlış soruların toplamı toplam soru sayısını (${totalQuestions}) geçemez.`, "warning");
        // Değeri düzelt
        if (field === 'correct') {
            APP_STATE.gradesData[studentId][testId].dogru = totalQuestions - wrong;
        } else {
            APP_STATE.gradesData[studentId][testId].yanlis = totalQuestions - correct;
        }
    }
    
    // Alt test yapısı oluştur (gerekiyorsa)
    const parts = testId.split('.');
    if (parts.length > 1) {
        const parentId = parts[0]; // A1
        const shortId = parts[parts.length - 1]; // 1
        
        // Eğer üst aktivite yoksa oluştur
        if (!APP_STATE.gradesData[studentId][parentId]) {
            APP_STATE.gradesData[studentId][parentId] = {
                toplam: 0
            };
        }
        
        // Kısa kod da ekle
        APP_STATE.gradesData[studentId][parentId][shortId] = {
            tip: 'test',
            dogru: testScore.dogru,
            yanlis: testScore.yanlis
        };
        
        // Alt yapıya da ekle
        if (!APP_STATE.gradesData[studentId][parentId][testId]) {
            APP_STATE.gradesData[studentId][parentId][testId] = {
                tip: 'test',
                dogru: testScore.dogru,
                yanlis: testScore.yanlis
            };
        } else {
            APP_STATE.gradesData[studentId][parentId][testId].dogru = testScore.dogru;
            APP_STATE.gradesData[studentId][parentId][testId].yanlis = testScore.yanlis;
        }
        
        // Toplama hesapla
        updateParentActivityTotal(studentId, parentId);
    }
}

// Üst aktivitenin toplamını güncelleme (yardımcı fonksiyon)
function updateParentActivityTotal(studentId, parentId) {
    const parentActivity = findNodeById(parentId);
    if (parentActivity && parentActivity.children && parentActivity.children.length > 0) {
        let total = 0;
        let maxPoints = 0;
        
        parentActivity.children.forEach(child => {
            let grade = 0;
            if (child.type === 'Test') {
                // Test notları için özel hesaplama
                const testScore = APP_STATE.gradesData[studentId][child.id];
                if (testScore && testScore.tip === 'test') {
                    const correct = testScore.dogru || 0;
                    const wrong = testScore.yanlis || 0;
                    grade = correct * (child.testDetails?.correctWeight || 5) - 
                            wrong * Math.abs(child.testDetails?.wrongPenalty || 0);
                }
            } else {
                grade = getStudentGrade(studentId, child.id) || 0;
            }
            total += grade;
            maxPoints += parseFloat(child.points) || 0;
        });
        
        // Toplam puanı hesapla (100 üzerinden)
        const normalized = maxPoints > 0 ? (total / maxPoints) * 100 : 0;
        APP_STATE.gradesData[studentId][parentId].toplam = normalized;
    }
}

// Öğrenci görünümünde test toplamını güncelleme (yardımcı fonksiyon)
function updateStudentViewTestTotal(studentId, testId) {
    const testNode = findNodeById(testId);
    if (!testNode) return;
    
    const testScore = APP_STATE.gradesData[studentId][testId];
    if (!testScore) return;
    
    const correct = testScore.dogru || 0;
    const wrong = testScore.yanlis || 0;
    const correctWeight = testNode.testDetails?.correctWeight || 5;
    const wrongPenalty = Math.abs(testNode.testDetails?.wrongPenalty || 0);
    const totalScore = correct * correctWeight - wrong * wrongPenalty;
    
    // Öğrenci görünümündeki toplam skoru güncelle
    const studentViewTotalElement = document.querySelector(`#studentGradesContainer .student-test-item[data-subitem-id="${testId}"] .total-test-score`);
    if (studentViewTotalElement) {
                    studentViewTotalElement.textContent = totalScore.toFixed(2);
    }
}

// Öğrenci özet bilgilerini güncelleme (yardımcı fonksiyon)
function updateStudentSummary(studentId) {
    const studentGrades = calculateStudentGrades(studentId);
    if (!studentGrades) return;
    
    // Özet alanını güncelle
    const summaryItems = document.querySelectorAll('#studentGradesContainer .student-summary .summary-item strong');
    if (summaryItems.length === 4) {
        summaryItems[0].textContent = studentGrades.termGrade;
        summaryItems[1].textContent = studentGrades.finalGrade;
        summaryItems[2].textContent = studentGrades.totalGrade;
        summaryItems[3].textContent = studentGrades.letterGrade;
        summaryItems[3].className = getLetterGradeClass(studentGrades.letterGrade);
    }
}

/**
 * Çoklu öğe ekleme modalını gösterme
 * @param {string} type - Eklenecek öğe tipi ('soru' veya 'rubrik')
 */
function showMultipleItemsModal(type = 'soru') {
    // Modal başlığını ayarla
    multipleItemsTitle.textContent = type === 'soru' ? 'Çoklu Soru Ekle' : 'Çoklu Rubrik Ekle';
    
    // Hedef etkinlik combobox'ını doldur
    const targetActivitySelect = document.getElementById('targetActivitySelect');
    targetActivitySelect.innerHTML = '';
    
    // Mevcut ana etkinlikleri bul ve ekle - çoklu veri kaynağı kontrolü
    const activities = [];
    
    // Önce APP_STATE.data.children kontrol et
    if (APP_STATE.data && APP_STATE.data.children) {
        APP_STATE.data.children.forEach(node => {
            // Ana etkinlikler (alt düğüm olmayan)
            if (!node.id.includes('.')) {
                activities.push({
                    id: node.id,
                    name: node.name || node.type || `Etkinlik ${node.id}`,
                    type: node.type || 'Bilinmeyen',
                    category: node.id.startsWith('A') ? 'Yarıyıl İçi' : 'Yarıyıl Sonu'
                });
            }
        });
    }
    
    // Eğer bulunamadıysa APP_STATE.assessmentTree kontrol et
    if (activities.length === 0 && APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0) {
        APP_STATE.assessmentTree.forEach(node => {
            // Ana etkinlikler (alt düğüm olmayan)
            if (!node.id.includes('.')) {
                activities.push({
                    id: node.id,
                    name: node.name || node.type || `Etkinlik ${node.id}`,
                    type: node.type || 'Bilinmeyen',
                    category: node.id.startsWith('A') ? 'Yarıyıl İçi' : 'Yarıyıl Sonu'
                });
            }
        });
    }
    
    // Son olarak DOM'dan kontrol et
    if (activities.length === 0) {
        document.querySelectorAll('.tree-node').forEach(nodeEl => {
            const nodeId = nodeEl.dataset.id;
            if (nodeId && !nodeId.includes('.')) {
                const nameEl = nodeEl.querySelector('.nodeName');
                const typeEl = nodeEl.querySelector('.nodeType');
                activities.push({
                    id: nodeId,
                    name: nameEl ? nameEl.value : `Etkinlik ${nodeId}`,
                    type: typeEl ? typeEl.value : 'Bilinmeyen',
                    category: nodeId.startsWith('A') ? 'Yarıyıl İçi' : 'Yarıyıl Sonu'
                });
            }
        });
    }
    
    console.log("🔍 showMultipleItemsModal - Bulunan etkinlikler:", activities);
    console.log("🔍 APP_STATE.data:", APP_STATE.data);
    console.log("🔍 APP_STATE.assessmentTree:", APP_STATE.assessmentTree);
    
    if (activities.length === 0) {
        const option = document.createElement('option');
        option.disabled = true;
        option.textContent = 'Henüz etkinlik tanımlanmamış - Lütfen önce etkinlik oluşturun';
        targetActivitySelect.appendChild(option);
        
        // Etkinlik yoksa bile modalı aç ama uyarı ver
        showModernToast("Henüz etkinlik tanımlanmamış. Önce 'Yarıyıl İçi Ekle' veya 'Yarıyıl Sonu Ekle' butonlarını kullanarak etkinlik oluşturun.", "warning");
        // return; // Bu satırı kaldırıyoruz ki modal açılsın
    }
    
    // Etkinlikleri kategoriye göre grupla ve ekle
    const termActivities = activities.filter(a => a.category === 'Yarıyıl İçi');
    const finalActivities = activities.filter(a => a.category === 'Yarıyıl Sonu');
    
    if (termActivities.length > 0) {
        const termGroup = document.createElement('optgroup');
        termGroup.label = '📚 Yarıyıl İçi Değerlendirme';
        termActivities.forEach(activity => {
            const option = document.createElement('option');
            option.value = activity.id;
            option.textContent = `${activity.id} - ${activity.name} (${activity.type})`;
            termGroup.appendChild(option);
        });
        targetActivitySelect.appendChild(termGroup);
    }
    
    if (finalActivities.length > 0) {
        const finalGroup = document.createElement('optgroup');
        finalGroup.label = '🎓 Yarıyıl Sonu Değerlendirme';
        finalActivities.forEach(activity => {
            const option = document.createElement('option');
            option.value = activity.id;
            option.textContent = `${activity.id} - ${activity.name} (${activity.type})`;
            finalGroup.appendChild(option);
        });
        targetActivitySelect.appendChild(finalGroup);
    }
    
    // Eğer seçili bir etkinlik varsa onu varsayılan olarak seç
    if (APP_STATE.selectedNode && !APP_STATE.selectedNode.id.includes('.')) {
        targetActivitySelect.value = APP_STATE.selectedNode.id;
    }
    
    // Tip değişimine göre uygun container'ı göster
    if (type === 'soru') {
        questionTypeContainer.style.display = 'block';
        rubricTypeContainer.style.display = 'none';
        
        // Soru tiplerini dinamik olarak doldur
        questionType.innerHTML = '';
        
        // Önce varsayılan 'Soru' seçeneği
        const defaultOption = document.createElement('option');
        defaultOption.value = 'Soru';
        defaultOption.textContent = 'Soru (Genel)';
        questionType.appendChild(defaultOption);
        
        // Diğer soru türlerini ekle
        document.querySelectorAll('.question-type-item').forEach(item => {
            const value = item.getAttribute('data-type');
            if (value !== 'Test') { // Test türünü hariç tut
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;
                questionType.appendChild(option);
            }
        });
    } else {
        questionTypeContainer.style.display = 'none';
        rubricTypeContainer.style.display = 'block';
        
        // Rubrik tiplerini dinamik olarak doldur
        rubricType.innerHTML = '';
        
        // Önce varsayılan 'Rubrik' seçeneği
        const defaultOption = document.createElement('option');
        defaultOption.value = 'Rubrik';
        defaultOption.textContent = 'Rubrik (Genel)';
        rubricType.appendChild(defaultOption);
        
        // Diğer rubrik türlerini ekle
        document.querySelectorAll('.rubric-item').forEach(item => {
            const value = item.getAttribute('data-type');
            const option = document.createElement('option');
            option.value = value;
            option.textContent = value;
            rubricType.appendChild(option);
        });
    }
    
    // Öğrenme Çıktılarını doldur
    const outcomeSelection = document.getElementById('outcomeSelection');
    outcomeSelection.innerHTML = '';
    
    // Öğrenme çıktılarını ekle
    if (APP_STATE.learningOutcomes && APP_STATE.learningOutcomes.length > 0) {
        APP_STATE.learningOutcomes.forEach(outcome => {
            const option = document.createElement('option');
            option.value = outcome.id;
            option.textContent = `${outcome.id}: ${outcome.aciklama}`;
            outcomeSelection.appendChild(option);
        });
    } else {
        // Öğrenme çıktısı yoksa bilgi mesajı ekle
        const option = document.createElement('option');
        option.disabled = true;
        option.textContent = 'Henüz öğrenme çıktısı tanımlanmamış';
        outcomeSelection.appendChild(option);
    }
    
    // Global değişkenleri ayarla
    APP_STATE.multipleItemsNode = APP_STATE.selectedNode;
    APP_STATE.multipleItemsType = type;
    
    // Modalı göster
    openModal(multipleItemsModal);
}

/**
 * Çoklu öğe ekleme işlemini gerçekleştirme
 */
function addMultipleItems() {
    try {
        const count = parseInt(itemCount.value) || 5;
        const type = APP_STATE.multipleItemsType;
        
        // Hedef etkinliği combobox'tan al
        const targetActivitySelect = document.getElementById('targetActivitySelect');
        const selectedActivityId = targetActivitySelect.value;
        
        if (!selectedActivityId || selectedActivityId === '') {
            showModernToast("Lütfen hedef etkinlik listesinden bir etkinlik seçin. Eğer liste boşsa önce 'Yarıyıl İçi Ekle' veya 'Yarıyıl Sonu Ekle' butonlarını kullanarak etkinlik oluşturun.", "warning");
            return;
        }
        
        // Seçilen etkinliği bul
        const selectedNode = findNodeById(selectedActivityId);
        
        if (!selectedNode) {
            showModernToast("Seçilen etkinlik bulunamadı.", "error");
            return;
        }
        
        // Seçilen etkinliğin bilgilerini al
        const activityInfo = `${selectedNode.id} - ${selectedNode.name || selectedNode.type} (${selectedNode.type})`;
        const category = selectedNode.id.startsWith('A') ? 'Yarıyıl İçi' : 'Yarıyıl Sonu';
        
        // Seçilen ÖÇ'leri al
        const outcomeSelection = document.getElementById('outcomeSelection');
        const selectedOutcomes = Array.from(outcomeSelection.selectedOptions).map(option => option.value);
        
        // Mevcut alt öğeleri kontrol et
        const existingChildrenCount = selectedNode.children ? selectedNode.children.length : 0;
        
        // Ağırlık hesaplama
        let newItemWeight = 0;
        
        if (existingChildrenCount === 0) {
            // Hiç alt öğe yoksa, 100'ü eşit böl
            newItemWeight = Math.floor(100 / count);
        } else {
            // Mevcut alt öğelerin toplam ağırlığını hesapla
            const totalExistingWeight = selectedNode.children.reduce((sum, child) => sum + (parseFloat(child.weight) || 0), 0);
            
            // Kalan ağırlığı bul (100'den fazla ise 0 olarak al)
            const remainingWeight = Math.max(0, 100 - totalExistingWeight);
            
            // Kalan ağırlığı eşit böl
            newItemWeight = Math.floor(remainingWeight / count);
            
            // Eğer kalan ağırlık 0 ise, mevcut öğelerin ağırlıklarını yeniden dağıt
            if (remainingWeight <= 0) {
                // Tüm alt öğelerin ağırlıklarını yeniden hesapla
                const totalItems = existingChildrenCount + count;
                const newWeightPerItem = Math.floor(100 / totalItems);
                
                // Mevcut alt öğelerin ağırlıklarını güncelle
                selectedNode.children.forEach(child => {
                    child.weight = newWeightPerItem;
                });
                
                newItemWeight = newWeightPerItem;
            }
        }
        
        // Seçilen tip ve sayıda öğe ekle
        if (type === 'soru') {
            const selectedQuestionType = questionType.value;
            const description = Array.from(document.querySelectorAll('.question-type-item'))
                .find(item => item.getAttribute('data-type') === selectedQuestionType)?.getAttribute('data-description') || '';
            
            // Çoklu soru ekle
            for (let i = 0; i < count; i++) {
                // ÖÇ ataması - dengeli dağıtım için sırayla atama
                let outcome = [];
                if (selectedOutcomes.length > 0) {
                    // i. öğeye i % selectedOutcomes.length indeksindeki ÖÇ'yi ata
                    outcome = [selectedOutcomes[i % selectedOutcomes.length]];
                }
                
                const newNode = {
                    id: `${selectedNode.id}.${(existingChildrenCount + i + 1)}`,
                    name: `${selectedQuestionType} ${existingChildrenCount + i + 1}`,
                    type: selectedQuestionType,
                    weight: newItemWeight,
                    points: 20, // Varsayılan puan
                    outcomes: outcome,
                    description: description || 'Değerlendirme sorusu',
                    expanded: false,
                    children: []
                };
                
                if (!selectedNode.children) {
                    selectedNode.children = [];
                }
                
                selectedNode.children.push(newNode);
            }
            
            showModernToast(`${count} adet "${selectedQuestionType}" sorusu "${activityInfo}" etkinliğine eklendi.`, "success");
        } else {
            const selectedRubricType = rubricType.value;
            const description = Array.from(document.querySelectorAll('.rubric-item'))
                .find(item => item.getAttribute('data-type') === selectedRubricType)?.getAttribute('data-description') || '';
            
            // Çoklu rubrik ekle
            for (let i = 0; i < count; i++) {
                // ÖÇ ataması - dengeli dağıtım için sırayla atama
                let outcome = [];
                if (selectedOutcomes.length > 0) {
                    // i. öğeye i % selectedOutcomes.length indeksindeki ÖÇ'yi ata
                    outcome = [selectedOutcomes[i % selectedOutcomes.length]];
                }
                
                const newNode = {
                    id: `${selectedNode.id}.${(existingChildrenCount + i + 1)}`,
                    name: `${selectedRubricType} ${existingChildrenCount + i + 1}`,
                    type: selectedRubricType,
                    weight: newItemWeight,
                    points: 20, // Varsayılan puan
                    outcomes: outcome,
                    description: description || 'Değerlendirme kriteri',
                    expanded: false,
                    children: []
                };
                
                if (!selectedNode.children) {
                    selectedNode.children = [];
                }
                
                selectedNode.children.push(newNode);
            }
            
            showModernToast(`${count} adet "${selectedRubricType}" rubriği "${activityInfo}" etkinliğine eklendi.`, "success");
        }
        
        // Modal'ı kapat
        closeModal(multipleItemsModal);
        
        // Ana düğümü genişlet
        selectedNode.expanded = true;
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
    } catch (error) {
        console.error("Çoklu öğe eklenirken hata oluştu:", error);
        showModernToast("Öğeler eklenemedi!", "error");
    }
}

/**
 * Test sorularına rastgele doğru/yanlış dağılımı yapma
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} testId - Test ID'si
 * @param {number} correct - Doğru sayısı
 * @param {number} wrong - Yanlış sayısı
 */
function distributeTestScores(studentId, testId, correct, wrong) {
    // Modern test dağıtım modalını göster
    showTestScoreDistributionModal(studentId, testId);
}

/**
 * Diziyi karıştırma (Fisher-Yates shuffle algoritması)
 * @param {Array} array - Karıştırılacak dizi
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * Puanları eşit olarak dağıt
 * @param {Object} parentNode - Ana etkinlik düğümü
 * @param {number} totalPoints - Toplam puan
 */
function distributePointsEqually(parentNode, totalPoints) {
    if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
        return;
    }
    
    const childCount = parentNode.children.length;
    
    // Eşit dağıtım için temel puanı hesapla
    const basePoint = Math.floor(totalPoints / childCount);
    const remainder = totalPoints - (basePoint * childCount);
    
    // Her alt öğeye eşit puan ver
    parentNode.children.forEach((child, index) => {
        // Son alt öğeye kalan puanları ekle
        if (index === childCount - 1) {
            child.points = basePoint + remainder;
        } else {
            child.points = basePoint;
        }
    });
    
    // Alt öğelerin ağırlıklarını güncelle
    updateSubItemWeights(parentNode);
}

/**
 * Soruların puanlarını rastgele ama dengeli dağıtma
 * @param {Object} parentNode - Ana etkinlik düğümü
 * @param {number} totalPoints - Toplam puan
 */
function distributePointsRandomly(parentNode, totalPoints) {
    if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
        return;
    }
    
    const childCount = parentNode.children.length;
    
    // Dengeli bir dağılım için önce eşit puan ver
    const basePoint = Math.floor(totalPoints / childCount);
    const remainder = totalPoints - (basePoint * childCount);
    
    // ÖÇ'leri grupla
    const outcomeGroups = {};
    parentNode.children.forEach(child => {
        if (child.outcomes && child.outcomes.length > 0) {
            const key = child.outcomes.join(',');
            if (!outcomeGroups[key]) {
                outcomeGroups[key] = [];
            }
            outcomeGroups[key].push(child);
        } else {
            // ÖÇ'si olmayan sorular için özel grup
            if (!outcomeGroups['no_outcome']) {
                outcomeGroups['no_outcome'] = [];
            }
            outcomeGroups['no_outcome'].push(child);
        }
    });
    
    // Düzgün bir dağılım yapabilmek için puan dizisi oluştur
    let points = parentNode.children.map(() => basePoint);
    
    // Kalan puanları rastgele dağıt (her ÖÇ grubuna eşit dağılım yaparak)
    const outcomeKeys = Object.keys(outcomeGroups);
    
    // Her gruba eşit sayıda ek puan dağıt
    const extraPointsPerGroup = Math.floor(remainder / outcomeKeys.length);
    let remainingExtra = remainder - (extraPointsPerGroup * outcomeKeys.length);
    
    outcomeKeys.forEach(key => {
        const group = outcomeGroups[key];
        const extraPointsForThisGroup = group.length > 0 ? Math.floor(extraPointsPerGroup / group.length) : 0;
        let groupRemainder = extraPointsPerGroup - (extraPointsForThisGroup * group.length);
        
        // Her soruya ek puanı ata
        group.forEach(child => {
            const index = parentNode.children.indexOf(child);
            if (index !== -1) {
                points[index] += extraPointsForThisGroup;
            }
        });
        
        // Gruptaki kalan puanları rastgele dağıt
        while (groupRemainder > 0 && group.length > 0) {
            const randomIndex = Math.floor(Math.random() * group.length);
            const childIndex = parentNode.children.indexOf(group[randomIndex]);
            if (childIndex !== -1) {
                points[childIndex]++;
                groupRemainder--;
            }
        }
    });
    
    // Son kalan puanları rastgele dağıt
    while (remainingExtra > 0 && parentNode.children.length > 0) {
        const randomIndex = Math.floor(Math.random() * parentNode.children.length);
        points[randomIndex]++;
        remainingExtra--;
    }
    
    // Puanları çocuk düğümlere ata
    parentNode.children.forEach((child, index) => {
        child.points = points[index];
    });
    
    // Alt öğelerin ağırlıklarını da güncelle
    updateSubItemWeights(parentNode);
}

/**
 * Alt öğelerin ağırlıklarını toplam puana göre günceller
 * @param {Object} parentNode - Ana etkinlik düğümü
 */
function updateSubItemWeights(parentNode) {
    if (!parentNode || !parentNode.children || parentNode.children.length === 0) {
        return;
    }
    
    // Toplam puanı hesapla
    const totalPoints = parentNode.children.reduce((sum, child) => sum + (parseInt(child.points) || 0), 0);
    
    // Her çocuk için ağırlık hesapla
    if (totalPoints > 0) {
        parentNode.children.forEach(child => {
            const childPoints = parseInt(child.points) || 0;
            child.weight = Math.round((childPoints / totalPoints) * 100);
        });
    }
}

/**
 * Soru veya rubrik eklendiğinde/çıkarıldığında puanları yeniden dağıtmak isteyip istemediğini sor
 * @param {Object} parentNode - Ana etkinlik düğümü
 */
function checkAndOfferRedistribution(parentNode) {
    if (!parentNode || !parentNode.children || parentNode.children.length <= 1) {
        return;
    }
    
    // Toplam ağırlığı kontrol et
    const totalWeight = parentNode.children.reduce((sum, child) => sum + (parseInt(child.weight) || 0), 0);
    
    if (totalWeight !== 100) {
        // Modern dağıtım modalını göster
        showDistributePointsModal(parentNode, totalWeight);
    }
}

// =====================================================
// MODERN MODAL & TOAST SİSTEMİ
// =====================================================

/**
 * Modern onay modalı gösterir
 * @param {string} title - Modal başlığı
 * @param {string} message - Onay mesajı
 * @param {Function} onConfirm - Onaylandığında çalışacak fonksiyon
 * @param {Function} onCancel - İptal edildiğinde çalışacak fonksiyon (opsiyonel)
 * @param {Object} options - Buton metinleri ve stiller (opsiyonel)
 */
function showModernConfirm(title, message, options = {}) {
    console.log("🔍 showModernConfirm çağrıldı:", title);
    console.log("🔍 Options:", options);
    
    return new Promise((resolve) => {
    const modal = document.getElementById('modernConfirmModal');
    const titleElement = document.getElementById('confirmModalTitle');
    const messageElement = document.getElementById('confirmModalMessage');
    const yesButton = document.getElementById('confirmModalYes');
    const noButton = document.getElementById('confirmModalNo');
        const headerElement = modal ? modal.querySelector('.modern-modal-header') : null;
        const iconElement = modal ? modal.querySelector('.modal-icon') : null;
        
        console.log("🔍 Modal elementleri kontrol ediliyor:");
        console.log("- modal:", modal ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- titleElement:", titleElement ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- messageElement:", messageElement ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- yesButton:", yesButton ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- noButton:", noButton ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- headerElement:", headerElement ? "✅ Bulundu" : "❌ Bulunamadı");
        console.log("- iconElement:", iconElement ? "✅ Bulundu" : "❌ Bulunamadı");
    
    if (!modal || !titleElement || !messageElement || !yesButton || !noButton) {
            console.error('❌ Modern confirm modal elementleri bulunamadı!');
        // Fallback olarak toast mesajı göster
        showModernToast("Modal yüklenemedi. Lütfen sayfayı yenileyin.", "error");
            resolve(false);
        return;
    }
    
    // Varsayılan buton metinleri ve stiller
    const defaultOptions = {
        confirmText: 'Evet, Sil',
        cancelText: 'İptal',
        confirmClass: 'btn-danger',
        cancelClass: 'btn-secondary',
        headerClass: 'danger-action',
        iconClass: 'danger'
    };
    
    // Options'ı birleştir
    const finalOptions = { ...defaultOptions, ...options };
    
    // Modal içeriğini ayarla
    titleElement.textContent = title;
    messageElement.textContent = message;
    
    // Buton metinlerini güncelle
    yesButton.textContent = finalOptions.confirmText;
    noButton.textContent = finalOptions.cancelText;
    
    // Buton sınıflarını güncelle
    yesButton.className = `modern-confirm-btn ${finalOptions.confirmClass}`;
    noButton.className = `modern-confirm-btn ${finalOptions.cancelClass}`;
    
    // Header renk sınıfını güncelle
    if (headerElement) {
        // Mevcut action sınıflarını temizle
        headerElement.classList.remove('create-action', 'success-action', 'info-action', 'warning-action', 'danger-action');
        // Yeni sınıfı ekle
        headerElement.classList.add(finalOptions.headerClass);
    }
    
    // İkon sınıfını ve içeriğini güncelle
    if (iconElement) {
        // Mevcut icon sınıflarını temizle
        iconElement.classList.remove('warning', 'danger', 'success', 'info');
        // Yeni sınıfı ekle
        iconElement.classList.add(finalOptions.iconClass);
        
        // İkon SVG içeriğini güncelle
        const iconSvg = iconElement.querySelector('svg');
        if (iconSvg) {
            // SVG boyutunu 64x64 yap
            iconSvg.setAttribute('width', '64');
            iconSvg.setAttribute('height', '64');
            
            switch(finalOptions.iconClass) {
                case 'success':
                    iconSvg.innerHTML = `
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                        <polyline points="22 4 12 14.01 9 11.01"></polyline>
                    `;
                    break;
                case 'info':
                    iconSvg.innerHTML = `
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    `;
                    break;
                case 'warning':
                    iconSvg.innerHTML = `
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    `;
                    break;
                case 'danger':
                default:
                    iconSvg.innerHTML = `
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="15" y1="9" x2="9" y2="15"></line>
                        <line x1="9" y1="9" x2="15" y2="15"></line>
                    `;
                    break;
            }
        }
    }
    
    // Promise'i yalnızca bir kez resolve etmek için flag
    let resolved = false;
    
    function handleYesClick() {
        if (resolved) return;
        resolved = true;
        console.log("✅ Modal EVET butonuna tıklandı");
            modal.classList.remove('active');
            setTimeout(() => modal.style.display = 'none', 300);
            resolve(true);
    }
    
    function handleNoClick() {
        if (resolved) return;
        resolved = true;
        console.log("❌ Modal İPTAL butonuna tıklandı");
            modal.classList.remove('active');
            setTimeout(() => modal.style.display = 'none', 300);
            resolve(false);
    }

    // Event listener'ları temizle ve yenilerini ekle
    yesButton.onclick = null;
    noButton.onclick = null;
    yesButton.onclick = handleYesClick;
    noButton.onclick = handleNoClick;
    
    console.log("🔧 Buton event handler'ları eklendi");
    
    // Close button'ları da handle et
    const closeButtons = modal.querySelectorAll('.modern-close');
    closeButtons.forEach(button => {
        button.onclick = null;
        button.onclick = handleNoClick;
    });
    
    // Modal dışına tıklamayı handle et
    modal.onclick = null;
    modal.onclick = (e) => {
        if (e.target === modal) {
            handleNoClick();
        }
    };
    
    // Modalı göster
        console.log("🎭 Modal gösteriliyor...");
    modal.style.display = 'flex';
        // CSS animasyonları için active sınıfını ekle
        setTimeout(() => {
            modal.classList.add('active');
            console.log("✅ Modal active sınıfı eklendi");
        }, 10);
    });
}

/**
 * Modern toast bildirimi gösterme
 * @param {string} message - Bildirim mesajı
 * @param {string} type - Bildirim tipi (success, error, warning, info)
 * @param {number} duration - Görünme süresi (ms)
 */
function showModernToast(message, type = 'success', duration = 4000) {
    const toast = document.getElementById('modernToast');
    const messageElement = document.getElementById('modernToastMessage');
    const iconElement = toast.querySelector('.modern-toast-icon');
    const progressBar = toast.querySelector('.modern-toast-progress-bar');
    
    // Mesajı ayarla
    messageElement.textContent = message;
    
    // İkon ve renk sınıflarını temizle
    iconElement.classList.remove('success', 'error', 'warning', 'info');
    
    // İkon ve renk ayarla
    switch(type) {
        case 'error':
            iconElement.classList.add('error');
            iconElement.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
            progressBar.style.backgroundColor = 'var(--danger-color)';
            break;
        case 'warning':
            iconElement.classList.add('warning');
            iconElement.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>';
            progressBar.style.backgroundColor = 'var(--warning-color)';
            break;
        case 'info':
            iconElement.classList.add('info');
            iconElement.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
            progressBar.style.backgroundColor = 'var(--info-color)';
            break;
        default: // success
            iconElement.classList.add('success');
            iconElement.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
            progressBar.style.backgroundColor = 'var(--success-color)';
    }
    
    // Animasyon süresini ayarla
    progressBar.style.animation = `progressShrink ${duration/1000}s linear forwards`;
    
    // Toastı göster
    toast.style.display = 'block';
    
    // Belirtilen süre sonra kapat
    const toastTimeout = setTimeout(() => {
        toast.style.display = 'none';
    }, duration);
    
    // Kapatma butonuna tıklandığında
    toast.querySelector('.modern-toast-close').onclick = function() {
        clearTimeout(toastTimeout);
        toast.style.display = 'none';
    };
}

/**
 * Modern modal açma
 * @param {string} modalId - Modal element ID'si
 */
function openModernModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('active'), 10);
        
        // Close butonları için event listener ekle
        modal.querySelectorAll('.modern-close').forEach(closeBtn => {
            closeBtn.onclick = () => closeModernModal(modalId);
        });
        
        // Modal dışına tıklama ile kapatma
        modal.onclick = function(e) {
            if (e.target === modal) {
                closeModernModal(modalId);
            }
        };
        
        // Escape tuşu ile kapatma
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                closeModernModal(modalId);
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    }
}

/**
 * Modern modal kapatma
 * @param {string} modalId - Modal element ID'si
 */
function closeModernModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.remove('active');
        setTimeout(() => {
        modal.style.display = 'none';
            // Event listener'ları temizle
            modal.onclick = null;
        }, 300);
    }
}

/**
 * Silme onay modalını gösterme
 * @param {Function} confirmCallback - Onay verildiğinde çalışacak fonksiyon
 * @param {string} message - Gösterilecek mesaj
 */
function showDeleteConfirmModal(confirmCallback, message = 'Bu öğeyi silmek istediğinizden emin misiniz?') {
    // Modern confirm sistemini kullan
    showModernConfirm(
        'Etkinlik Silme Onayı',
        message,
        {
            confirmText: 'Evet, Sil',
            cancelText: 'İptal',
            headerClass: 'danger-action',
            iconClass: 'danger'
        }
    ).then(confirmed => {
        if (confirmed && typeof confirmCallback === 'function') {
            confirmCallback();
        }
    });
}

/**
 * Puan dağıtım modalını gösterme
 * @param {Object} parentNode - Ana düğüm
 * @param {number} totalWeight - Mevcut toplam ağırlık
 */
function showDistributePointsModal(parentNode, totalWeight) {
    const modal = document.getElementById('distributePointsModal');
    const totalWeightElement = document.getElementById('currentTotalWeight');
    const confirmButton = document.getElementById('confirmDistributeBtn');
    const totalPointsInput = document.getElementById('totalPointsInput');
    const equalOption = document.getElementById('equalOption');
    const randomOption = document.getElementById('randomOption');
    
    let selectedDistribution = null;
    
    // Toplam ağırlığı göster
    totalWeightElement.textContent = totalWeight;
    
    // Seçim yapılana kadar onay butonunu devre dışı bırak
    confirmButton.disabled = true;
    
    // Dağıtım seçeneklerine tıklandığında
    equalOption.onclick = function() {
        equalOption.classList.add('selected');
        randomOption.classList.remove('selected');
        selectedDistribution = 'equal';
        confirmButton.disabled = false;
    };
    
    randomOption.onclick = function() {
        randomOption.classList.add('selected');
        equalOption.classList.remove('selected');
        selectedDistribution = 'random';
        confirmButton.disabled = false;
    };
    
    // Onay butonuna tıklandığında
    confirmButton.onclick = function() {
        const totalPoints = parseInt(totalPointsInput.value) || 100;
        
        if (selectedDistribution === 'equal') {
            distributePointsEqually(parentNode, totalPoints);
            showModernToast(`Puanlar ${parentNode.name} etkinliğine eşit olarak dağıtıldı.`, 'success');
        } else if (selectedDistribution === 'random') {
            distributePointsRandomly(parentNode, totalPoints);
            showModernToast(`Puanlar ${parentNode.name} etkinliğine rastgele dağıtıldı.`, 'success');
        }
        
        // Modalı kapat
        closeModernModal('distributePointsModal');
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle
        updateAssessmentView();
    };
    
    // Modalı göster
    openModernModal('distributePointsModal');
    
    // Seçimleri sıfırla
    equalOption.classList.remove('selected');
    randomOption.classList.remove('selected');
}

/**
 * Test skoru dağıtım modalını gösterme
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} testId - Test ID'si
 */
function showTestScoreDistributionModal(studentId, testId) {
    const modal = document.getElementById('testScoreDistributionModal');
    const testNode = findNodeById(testId);
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    
    if (!testNode || !student) {
        showModernToast("Test veya öğrenci bilgisi bulunamadı!", "error");
        return;
    }
    
    // Test bilgilerini ayarla
    document.getElementById('testStudentName').textContent = `${student.name} ${student.surname} (${studentId})`;
    document.getElementById('testName').textContent = testNode.name;
    document.getElementById('testTotalQuestions').textContent = testNode.testDetails.totalQuestions;
    
    const totalQuestions = testNode.testDetails.totalQuestions;
    const correctWeight = testNode.testDetails.correctWeight;
    const wrongPenalty = Math.abs(testNode.testDetails.wrongPenalty);
    
    // Slider'ları ayarla
    const correctSlider = document.getElementById('testCorrectSlider');
    const wrongSlider = document.getElementById('testWrongSlider');
    correctSlider.max = totalQuestions;
    wrongSlider.max = totalQuestions;
    
    // Mevcut değerleri al
    let correct = 0;
    let wrong = 0;
    
    // Öğrencinin mevcut test verilerini kontrol et
    if (APP_STATE.gradesData[studentId] && APP_STATE.gradesData[studentId][testId]) {
        const testData = APP_STATE.gradesData[studentId][testId];
        if (testData.tip === 'test' || testData.type === 'test') {
            correct = testData.dogru || testData.correct || 0;
            wrong = testData.yanlis || testData.wrong || 0;
        }
    }
    
    // Slider ve değerleri güncelle
    correctSlider.value = correct;
    wrongSlider.value = wrong;
    updateTestDistributionPreview(correct, wrong, totalQuestions, correctWeight, wrongPenalty);
    
    // Slider olayları
    correctSlider.oninput = function() {
        const correctValue = parseInt(this.value);
        const wrongValue = parseInt(wrongSlider.value);
        
        // Toplam soru sayısını kontrol et
        if (correctValue + wrongValue > totalQuestions) {
            wrongSlider.value = totalQuestions - correctValue;
            wrong = totalQuestions - correctValue;
        }
        
        correct = correctValue;
        updateTestDistributionPreview(correct, wrong, totalQuestions, correctWeight, wrongPenalty);
    };
    
    wrongSlider.oninput = function() {
        const wrongValue = parseInt(this.value);
        const correctValue = parseInt(correctSlider.value);
        
        // Toplam soru sayısını kontrol et
        if (correctValue + wrongValue > totalQuestions) {
            correctSlider.value = totalQuestions - wrongValue;
            correct = totalQuestions - wrongValue;
        }
        
        wrong = wrongValue;
        updateTestDistributionPreview(correct, wrong, totalQuestions, correctWeight, wrongPenalty);
    };
    
    // Rastgele dağıt butonu
    document.getElementById('randomizeTestDistribution').onclick = function() {
        // Rastgele doğru sayısı üret
        const randomCorrect = Math.floor(Math.random() * (totalQuestions + 1));
        
        // Rastgele yanlış sayısı üret (toplam soruyu geçmeyecek şekilde)
        const maxWrong = totalQuestions - randomCorrect;
        const randomWrong = Math.floor(Math.random() * (maxWrong + 1));
        
        // Değerleri güncelle
        correctSlider.value = randomCorrect;
        wrongSlider.value = randomWrong;
        correct = randomCorrect;
        wrong = randomWrong;
        
        updateTestDistributionPreview(correct, wrong, totalQuestions, correctWeight, wrongPenalty);
    };
    
    // Uygula butonu
    document.getElementById('applyTestDistribution').onclick = function() {
        // Test skorunu kaydet
        saveTestDistribution(studentId, testId, correct, wrong);
        
        // Modalı kapat
        closeModernModal('testScoreDistributionModal');
        
        showModernToast(`${student.name} ${student.surname} için test puanı güncellendi.`, "success");
    };
    
    // Modalı göster
    openModernModal('testScoreDistributionModal');
}

/**
 * Test dağılım önizlemesini güncelleme
 */
function updateTestDistributionPreview(correct, wrong, totalQuestions, correctWeight, wrongPenalty) {
    document.getElementById('testCorrectValue').textContent = correct;
    document.getElementById('testWrongValue').textContent = wrong;
    
    const empty = totalQuestions - correct - wrong;
    document.getElementById('testEmptyValue').textContent = empty;
    
    // Toplam puanı hesapla
    const totalScore = (correct * correctWeight) - (wrong * wrongPenalty);
    document.getElementById('testTotalScore').textContent = totalScore.toFixed(2);
    
    // Dağılım önizlemesini güncelle
    const previewElement = document.getElementById('distributionPreview');
    previewElement.innerHTML = '';
    
    // Doğru oranı
    if (correct > 0) {
        const correctBlock = document.createElement('div');
        correctBlock.className = 'question-block question-correct';
        correctBlock.style.width = `${(correct / totalQuestions) * 100}%`;
        previewElement.appendChild(correctBlock);
    }
    
    // Yanlış oranı
    if (wrong > 0) {
        const wrongBlock = document.createElement('div');
        wrongBlock.className = 'question-block question-wrong';
        wrongBlock.style.width = `${(wrong / totalQuestions) * 100}%`;
        previewElement.appendChild(wrongBlock);
    }
    
    // Boş oranı
    if (empty > 0) {
        const emptyBlock = document.createElement('div');
        emptyBlock.className = 'question-block question-empty';
        emptyBlock.style.width = `${(empty / totalQuestions) * 100}%`;
        previewElement.appendChild(emptyBlock);
    }
}

/**
 * Test dağılımını kaydetme
 */
function saveTestDistribution(studentId, testId, correct, wrong) {
    // Öğrenci verisi oluştur
    if (!APP_STATE.gradesData[studentId]) {
        APP_STATE.gradesData[studentId] = {};
    }
    
    // Test verisini kaydet
    APP_STATE.gradesData[studentId][testId] = {
        tip: 'test',
        type: 'test',
        dogru: correct,
        correct: correct,
        yanlis: wrong,
        wrong: wrong
    };
    
    // Alt düğüm yapısını oluştur (gerekiyorsa)
    const parts = testId.split('.');
    if (parts.length > 1) {
        const parentId = parts[0]; // Örneğin: A1
        const shortId = parts[parts.length - 1]; // Örneğin: 1
        
        // Eğer üst aktivite yoksa oluştur
        if (!APP_STATE.gradesData[studentId][parentId]) {
            APP_STATE.gradesData[studentId][parentId] = {
                toplam: 0
            };
        }
        
        // Kısa kod da ekle
        APP_STATE.gradesData[studentId][parentId][shortId] = {
            tip: 'test',
            type: 'test',
            dogru: correct,
            correct: correct,
            yanlis: wrong,
            wrong: wrong
        };
        
        // Alt yapıya da ekle
        APP_STATE.gradesData[studentId][parentId][testId] = {
            tip: 'test',
            type: 'test',
            dogru: correct,
            correct: correct,
            yanlis: wrong,
            wrong: wrong
        };
        
        // Toplama hesapla
        updateParentActivityTotal(studentId, parentId);
    }
    
    // Değerlendirme sekmesini güncelle
    updateAssessmentView();
    
    // Notları yeniden hesapla
    updateStudentCalculatedGrade(studentId);
    
    // Öğrenci görünümünü güncelle
    updateStudentViewTestTotal(studentId, testId);
}

// Modal kapatma düğmelerini ayarla
document.addEventListener('DOMContentLoaded', function() {
    // Tüm modern kapatma butonlarına tıklama olayı ekle
    document.querySelectorAll('.modern-close').forEach(button => {
        button.addEventListener('click', function() {
            // En yakın modal elementini bul
            const modal = this.closest('.modern-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    });
    
    // Modal dışına tıklanınca kapatma
    document.querySelectorAll('.modern-modal').forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
            }
        });
    });
});

// =====================================================
// GRUP YÖNETİMİ FONKSİYONLARI
// =====================================================

/**
 * Grup sistemini başlatma
 */
function initializeGroupSystem() {
    // Eğer grup haritalama yoksa varsayılan oluştur
    if (!APP_STATE.courseData) {
        APP_STATE.courseData = {};
    }
    
    if (!APP_STATE.courseData.grupHaritalari) {
        APP_STATE.courseData.grupHaritalari = {};
    }
    
    // Her zaman en az bir grup olmasını garanti et
    ensureDefaultGroupExists();
    
    // Öğrencilere grup atanmamışsa A grubu ata
    if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
        APP_STATE.studentData.forEach(student => {
            if (!student.grup) {
                student.grup = "A";
            }
        });
    }
    
    // Sorular için otomatik 1:1 haritalama oluştur (her parent activity kendi içinde)
    createDefaultMapping();
    
    // Grup haritalama verilerini debug et
    console.log('📊 Grup haritalama durumu:', APP_STATE.courseData?.grupHaritalari);
    
    // Tüm ilgili UI'ları güncelle
    updateGroupSelectors();
    updateAllInlineGroupInputs();
}

/**
 * Her değerlendirme bileşeni için varsayılan A grubunun var olmasını garanti eder
 * A GRUBU HER ZAMAN MEVCUT OLMALI - Bu sistem kuralıdır
 */
function ensureDefaultGroupExists() {
    console.log(`🔧 ensureDefaultGroupExists çalışıyor...`);
    
    // Ana değerlendirme bileşenlerini bul
    const mainComponents = APP_STATE.assessmentTree.filter(node => 
        node.id.startsWith('A') || node.id.startsWith('F')
    );
    
    console.log(`📋 ${mainComponents.length} ana bileşen bulundu:`, mainComponents.map(c => c.id));
    
    mainComponents.forEach(component => {
        console.log(`\n🔍 ${component.id} bileşeni kontrol ediliyor...`);
        
        if (!APP_STATE.courseData.grupHaritalari[component.id]) {
            // Hiç grup yapısı yoksa oluştur
            APP_STATE.courseData.grupHaritalari[component.id] = {
                gruplar: ["A"],
                haritalar: {
                    "A": {}
                }
            };
            console.log(`✅ ${component.id}: Yeni grup yapısı oluşturuldu (A grubu)`);
        } else {
            // Mevcut bileşeni kontrol et ve düzelt
            const existingComponent = APP_STATE.courseData.grupHaritalari[component.id];
            let needsUpdate = false;
            
            // Grup listesi kontrolü
            if (!existingComponent.gruplar || existingComponent.gruplar.length === 0) {
                existingComponent.gruplar = ["A"];
                needsUpdate = true;
                console.log(`🔧 ${component.id}: Grup listesi düzeltildi (A grubu eklendi)`);
            } else if (!existingComponent.gruplar.includes("A")) {
                // A grubu listede yoksa başa ekle
                existingComponent.gruplar.unshift("A");
                needsUpdate = true;
                console.log(`🔧 ${component.id}: A grubu listeye eklendi`);
            }
            
            // Mapping yapısı kontrolü
            if (!existingComponent.haritalar) {
                existingComponent.haritalar = {};
                needsUpdate = true;
                console.log(`🔧 ${component.id}: Mapping yapısı oluşturuldu`);
            }
            
            if (!existingComponent.haritalar["A"]) {
                existingComponent.haritalar["A"] = {};
                needsUpdate = true;
                console.log(`🔧 ${component.id}: A grubu mapping'i oluşturuldu`);
            }
            
            if (needsUpdate) {
                console.log(`✅ ${component.id}: Grup yapısı güncellendi`);
            } else {
                console.log(`✅ ${component.id}: Grup yapısı zaten uygun`);
            }
        }
        
        // Son kontrol
        const finalCheck = APP_STATE.courseData.grupHaritalari[component.id];
        console.log(`📊 ${component.id} final durum:`, {
            gruplar: finalCheck.gruplar,
            mappingKeys: Object.keys(finalCheck.haritalar || {}),
            hasAGroup: finalCheck.gruplar?.includes("A"),
            hasAMapping: !!finalCheck.haritalar?.["A"]
        });
    });
    
    console.log(`✅ ensureDefaultGroupExists tamamlandı - Tüm bileşenlerde A grubu garantili`);
}

/**
 * Yarıyıl içi ağırlığını getir
 */
function getTermWeight() {
    return APP_STATE.termWeight || 40;
}

/**
 * Yarıyıl sonu ağırlığını getir
 */
function getFinalWeight() {
    return APP_STATE.finalWeight || 60;
}

/**
 * Belirli bir değerlendirmenin ağırlığını getir
 * @param {string} activityId - Aktivite ID'si
 * @returns {number} - Ağırlık yüzdesi
 */
function getAssessmentWeight(activityId) {
    try {
        const activity = findNodeById(activityId);
        if (!activity) return 0;
        
        // Ana bileşen mi yoksa alt bileşen mi kontrol et
        if (activity.id.startsWith('A')) {
            // Yarıyıl içi değerlendirme
            return activity.weight || 0;
        } else if (activity.id.startsWith('F')) {
            // Yarıyıl sonu değerlendirme
            return activity.weight || 0;
        }
        
        // Alt bileşen ise, üst bileşenin ağırlığını al
        const parentId = getParentComponentId(activityId);
        if (parentId) {
            const parentActivity = findNodeById(parentId);
            return parentActivity?.weight || 0;
        }
        
        return 0;
    } catch (error) {
        console.error("Değerlendirme ağırlığı alınırken hata:", error);
        return 0;
    }
}

/**
 * Varsayılan 1:1 haritalama oluşturma - Her değerlendirme bileşeni için ayrı grup sistemi
 */
function createDefaultMapping() {
    // Grup haritalama yapısını başlat
    if (!APP_STATE.courseData.grupHaritalari) {
        APP_STATE.courseData.grupHaritalari = {};
    }
    
    // Her ana değerlendirme bileşeni için ayrı grup sistemi oluştur
    APP_STATE.assessmentTree.forEach(parentNode => {
        // Tüm ana bileşenler için grup yapısı oluştur (soru/rubrik olsun olmasın)
        if (!APP_STATE.courseData.grupHaritalari[parentNode.id]) {
            APP_STATE.courseData.grupHaritalari[parentNode.id] = {
                gruplar: ["A"], // Varsayılan olarak sadece A grubu
                haritalar: {
                    "A": {}
                }
            };
        }
        
        // Eğer alt soruları varsa haritalama oluştur
        if (parentNode.children && parentNode.children.length > 0) {
            let questionIndex = 1;
            parentNode.children.forEach(childNode => {
                if (isQuestionType(childNode.type) || isRubricType(childNode.type)) {
                    // A grubu için varsayılan 1:1 haritalama
                    APP_STATE.courseData.grupHaritalari[parentNode.id].haritalar.A[childNode.id] = questionIndex.toString();
                    questionIndex++;
                }
            });
        }
        // Eğer alt soruları yoksa (Laboratuvar gibi), haritalama gerekmez
        // Sadece grup yapısı yeterli
    });
    
    // Tüm öğrencileri A grubuna ata (grup bilgisi yoksa)
    if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
        APP_STATE.studentData.forEach(student => {
            if (!student.grup) {
                student.grup = 'A';
            }
        });
    }
}

/**
 * Mevcut haritalamayı temizleyip yeniden oluşturma
 */
function recreateDefaultMapping() {
    // Tüm değerlendirme bileşenleri için haritalamayı temizle
    APP_STATE.courseData.grupHaritalari = {};
    
    // Yeniden oluştur
    createDefaultMapping();
    
    // UI'ları güncelle
    updateAllInlineGroupInputs();
    updateGroupMappingColors();
    updateAllMappingDisplays();
    
    showModernToast("Grup haritalamalar düzeltildi - her değerlendirme bileşeni kendi grup sistemine sahip", "success");
}

/**
 * Tüm soruları toplama
 */
function getAllQuestions() {
    const questions = [];
    
    function collectQuestions(nodes) {
        nodes.forEach(node => {
            if (isQuestionType(node.type) || isRubricType(node.type)) {
                questions.push({
                    id: node.id,
                    name: node.name,
                    type: node.type
                });
            }
            if (node.children && node.children.length > 0) {
                collectQuestions(node.children);
            }
        });
    }
    
    collectQuestions(APP_STATE.assessmentTree);
    return questions;
}

/**
 * Belirli bir değerlendirme bileşenine yeni grup ekleme
 */
async function addNewGroupToComponent(componentId) {
    const groupNames = ['B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const component = APP_STATE.courseData.grupHaritalari[componentId];
    
    if (!component) {
        showModernToast("Değerlendirme bileşeni bulunamadı", "error");
        return;
    }
    
    const existingGroups = component.gruplar || [];
    const newGroupName = groupNames.find(name => !existingGroups.includes(name));
    
    if (!newGroupName) {
        showModernToast("Bu bileşen için maksimum grup sayısına ulaşıldı", "warning");
        return;
    }
    
    // Modern confirm dialog ile onay al
    const confirmed = await showModernConfirm(
        'Grup Ekleme Onayı',
        `${getComponentDisplayName(componentId)} bileşenine grup ${newGroupName} eklemek istediğinizden emin misiniz?`,
        {
            confirmText: 'Evet, Ekle',
            cancelText: 'İptal',
            headerClass: 'success-action',
            iconClass: 'success'
        }
    );
    
    if (!confirmed) {
        return;
    }
    
        // Yeni grubu listeye ekle
        component.gruplar.push(newGroupName);
        
        // A grubunun kopyası olarak mapping oluştur (derin kopya)
        const groupAMapping = component.haritalar.A || {};
        component.haritalar[newGroupName] = JSON.parse(JSON.stringify(groupAMapping));
        
        // Eğer A grubunda mapping yoksa, varsayılan 1:1 mapping oluştur
        if (Object.keys(groupAMapping).length === 0) {
            const componentNode = findNodeById(componentId);
            if (componentNode && componentNode.children) {
                let questionIndex = 1;
                componentNode.children.forEach(childNode => {
                    if (isQuestionType(childNode.type) || isRubricType(childNode.type)) {
                        // DÜZELTME: Veri yapısı {position: questionId} formatında
                        component.haritalar.A[questionIndex.toString()] = childNode.id;
                        component.haritalar[newGroupName][questionIndex.toString()] = childNode.id;
                        questionIndex++;
                    }
                });
            }
        }
        
        // UI'ları güncelle
        updateGroupSelectors();
        updateStudentTable();
        updateAssessmentView();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        updateGroupMappingColors();
        
        // Grup sayısını güncelle
        updateComponentGroupCounts();
        
        // Modal'ı güncelle (eğer açıksa)
        updateComponentGroupList(componentId);
        
        // Ders tanımlama sayfasındaki grup bilgilerini güncelle
        updateComponentGroupInfo(componentId);
        
        showModernToast(`${getComponentDisplayName(componentId)} bileşenine grup ${newGroupName} eklendi`, "success");
}

/**
 * Tüm değerlendirme bileşenlerine yeni grup ekleme (eski davranış için)
 */
function addNewGroup() {
    const groupNames = ['B', 'C', 'D', 'E', 'F', 'G', 'H'];
    let addedToAny = false;
    
    // Her değerlendirme bileşenine grup ekle
    Object.keys(APP_STATE.courseData.grupHaritalari || {}).forEach(componentId => {
        const component = APP_STATE.courseData.grupHaritalari[componentId];
        const existingGroups = component.gruplar || [];
        const newGroupName = groupNames.find(name => !existingGroups.includes(name));
        
        if (newGroupName) {
            component.gruplar.push(newGroupName);
            const groupAMapping = component.haritalar.A || {};
            component.haritalar[newGroupName] = {...groupAMapping};
            addedToAny = true;
        }
    });
    
    if (addedToAny) {
        // UI'ları güncelle
        updateGroupSelectors();
        updateStudentTable();
        updateAssessmentView();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        updateGroupMappingColors();
        
        showModernToast("Tüm değerlendirme bileşenlerine yeni grup eklendi", "success");
    } else {
        showModernToast("Maksimum grup sayısına ulaşıldı", "warning");
    }
}

/**
 * Belirli bir değerlendirme bileşeninden grup silme
 */
async function deleteGroupFromComponent(componentId, groupName) {
    const component = APP_STATE.courseData.grupHaritalari[componentId];
    
    if (!component || groupName === 'A') {
        showModernToast("A grubu silinemez", "warning");
        return;
    }
    
    if (!component.gruplar.includes(groupName)) {
        showModernToast("Grup bulunamadı", "warning");
        return;
    }
    
    // Modern confirm dialog ile onay al
    const confirmed = await showModernConfirm(
        'Grup Silme Onayı',
        `${getComponentDisplayName(componentId)} bileşeninden grup ${groupName}'ı silmek istediğinizden emin misiniz?`,
        {
            confirmText: 'Evet, Sil',
            cancelText: 'İptal',
            headerClass: 'danger-action',
            iconClass: 'danger'
        }
    );
    
    if (!confirmed) {
        return;
    }
    
            // Grubu listeden çıkar
            component.gruplar = component.gruplar.filter(g => g !== groupName);
            
            // Mapping'i sil
            delete component.haritalar[groupName];
            
            // Bu gruptaki öğrencileri A grubuna taşı (sadece bu bileşen için)
            // Not: Öğrenci grup ataması global olduğu için dikkatli olmalıyız
            
            // UI'ları güncelle
            updateGroupSelectors();
            updateStudentTable();
            updateAssessmentView();
            updateAllInlineGroupInputs();
            updateAllMappingDisplays();
            updateGroupMappingColors();
            
            // Grup sayısını güncelle
            updateComponentGroupCounts();
            
            // Modal'ı güncelle (eğer açıksa)
            updateComponentGroupList(componentId);
            
            // Tüm UI'ları güncelle
            updateAllInlineGroupInputs();
            updateGroupSelectors();
            updateAssessmentView();
            
            showModernToast(`${getComponentDisplayName(componentId)} bileşeninden grup ${groupName} silindi`, "success");
}

/**
 * Bileşen grup yönetimi modalı gösterme
 */
function showComponentGroupManagementModal(componentId) {
    const component = APP_STATE.courseData.grupHaritalari[componentId];
    if (!component) {
        showModernToast("Değerlendirme bileşeni bulunamadı", "error");
        return;
    }
    
    const groups = component.gruplar || ['A'];
    const totalQuestions = countQuestionsInComponent(componentId);
    
    // Modal body içeriği oluştur
    const modalBodyContent = `
        <div class="component-summary">
            <div class="summary-item">
                <span class="summary-label">Toplam Soru:</span>
                <span class="summary-value">${totalQuestions}</span>
            </div>
            <div class="summary-item">
                <span class="summary-label">Mevcut Grup Sayısı:</span>
                <span class="summary-value">${groups.length}</span>
            </div>
        </div>
        
        <div class="groups-container">
            <h4>Gruplar ve Durumları:</h4>
            <div class="groups-grid">
                ${groups.map(group => {
                    // DÜZELTME: Sadece bu bileşendeki soruların eşleştirme durumunu kontrol et
                    const componentQuestionCount = getComponentSpecificQuestionMappingCount(componentId, group);
                    const isComplete = componentQuestionCount === totalQuestions;
                    return `
                        <div class="group-card ${isComplete ? 'complete' : 'incomplete'}">
                            <div class="group-header">
                                <span class="group-name">Grup ${group}</span>
                                ${group !== 'A' ? `
                                    <button class="btn-delete-group" data-component-id="${componentId}" data-group="${group}" title="Grubu Sil">
                                        ×
                                    </button>
                                ` : '<span class="default-badge">Varsayılan</span>'}
                            </div>
                            <div class="group-stats">
                                <span class="mapped-count">${componentQuestionCount}/${totalQuestions} soru eşleştirildi</span>
                                <span class="status-badge ${isComplete ? 'complete' : 'incomplete'}">
                                    ${isComplete ? 'Tamamlandı' : 'Eksik'}
                                </span>
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        </div>
        
        <div class="group-actions">
            <button class="btn btn-success" id="addNewGroupBtn" data-component-id="${componentId}">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="9" cy="7" r="4"/>
                    <line x1="19" y1="8" x2="19" y2="14"/>
                    <line x1="22" y1="11" x2="16" y2="11"/>
                </svg>
                Yeni Grup Ekle
            </button>
        </div>
    `;
    
    // Modal body'yi güncelle
    const modalBody = document.getElementById('componentGroupModalBody');
    if (modalBody) {
        modalBody.innerHTML = modalBodyContent;
        
        // Modal başlığını güncelle
        const modalHeader = document.querySelector('#componentGroupManagementModal .modern-modal-header h2');
        if (modalHeader) {
            modalHeader.textContent = `${componentId} Bileşeni - Grup Ekle/Çıkar`;
        }
        
        // Event listener'ları ekle
        setupComponentGroupModalEvents(componentId);
        
        // Modal'ı göster
        openModernModal('componentGroupManagementModal');
    }
}

/**
 * Belirli bir bileşen ve grup için eşleştirilmiş soru sayısını hesaplama
 */
function getComponentSpecificQuestionMappingCount(componentId, groupId) {
    const component = APP_STATE.courseData.grupHaritalari[componentId];
    if (!component || !component.haritalar || !component.haritalar[groupId]) {
        return 0;
    }
    
    // Bu bileşendeki tüm soruları bul
    const componentNode = findNodeById(componentId);
    if (!componentNode || !componentNode.children) {
        return 0;
    }
    
    const componentQuestionIds = [];
    componentNode.children.forEach(child => {
        if (isQuestionType(child.type) || isRubricType(child.type)) {
            componentQuestionIds.push(child.id);
        }
    });
    
    // Bu bileşendeki sorulardan kaç tanesi bu grupta eşleştirilmiş
    let mappedCount = 0;
    const groupMappings = component.haritalar[groupId];
    
    componentQuestionIds.forEach(questionId => {
        // DÜZELTME: Veri yapısı {position: questionId} formatında, {questionId: position} değil
        // Bu yüzden Object.values() ile questionId'leri kontrol etmeliyiz
        const isQuestionMapped = Object.values(groupMappings).includes(questionId);
        
        if (isQuestionMapped) {
            mappedCount++;
        }
    });
    
    return mappedCount;
}

/**
 * Bileşen grup modalı event listener'larını kurma
 */
function setupComponentGroupModalEvents(componentId) {
    // Grup silme butonları
    document.querySelectorAll('#componentGroupManagementModal .btn-delete-group').forEach(btn => {
        btn.addEventListener('click', function() {
            const groupName = this.dataset.group;
            const compId = this.dataset.componentId;
            deleteGroupFromComponent(compId, groupName);
        });
    });
    
    // Yeni grup ekleme butonu
    const addNewGroupBtn = document.getElementById('addNewGroupBtn');
    if (addNewGroupBtn) {
        addNewGroupBtn.addEventListener('click', function() {
            const compId = this.dataset.componentId;
            addNewGroupToComponent(compId);
        });
    }
}

/**
 * Bileşen grup listesini güncelleme
 */
function updateComponentGroupList(componentId) {
    // Modal açık mı kontrol et
    const modal = document.getElementById('componentGroupManagementModal');
    if (modal && (modal.classList.contains('active') || modal.style.display === 'block')) {
        // Modal içeriğini yeniden oluştur
        showComponentGroupManagementModal(componentId);
    }
}

/**
 * Grup haritalama önizlemesi oluşturma
 */
function generateGroupMappingsPreview(componentId) {
    const component = APP_STATE.courseData.grupHaritalari[componentId];
    if (!component || !component.haritalar) {
        return '<p>Henüz haritalama yapılmamış</p>';
    }
    
    const groups = component.gruplar || ['A'];
    let preview = '<div class="mappings-grid">';
    
    groups.forEach(group => {
        const mappings = component.haritalar[group] || {};
        const mappingCount = Object.keys(mappings).length;
        
        preview += `
            <div class="mapping-preview-item">
                <div class="group-header">Grup ${group}</div>
                <div class="mapping-count">${mappingCount} haritalama</div>
                <div class="mapping-details">
                    ${Object.entries(mappings).map(([position, questionId]) => 
                        `<span class="mapping-detail">Soru ${position} → ${questionId}</span>`
                    ).join('')}
                </div>
            </div>
        `;
    });
    
    preview += '</div>';
    return preview;
}

/**
 * Tüm değerlendirme bileşenlerinden grup silme (eski davranış için)
 */
function deleteGroup() {
    // Tüm bileşenlerde ortak olan grupları bul
    const allGroups = new Set();
    Object.values(APP_STATE.courseData.grupHaritalari || {}).forEach(component => {
        (component.gruplar || []).forEach(group => allGroups.add(group));
    });
    
    const nonAGroups = Array.from(allGroups).filter(g => g !== 'A');
    
    if (nonAGroups.length === 0) {
        showModernToast("A grubu dışında silinecek grup yok", "warning");
        return;
    }
    
    // Son grubu sil (alfabetik sırayla son)
    const lastGroup = nonAGroups.sort().pop();
    
    showDeleteConfirmModal(
        function() {
            // Tüm bileşenlerden bu grubu sil
            Object.keys(APP_STATE.courseData.grupHaritalari || {}).forEach(componentId => {
                const component = APP_STATE.courseData.grupHaritalari[componentId];
                if (component.gruplar && component.gruplar.includes(lastGroup)) {
                    component.gruplar = component.gruplar.filter(g => g !== lastGroup);
                    delete component.haritalar[lastGroup];
                }
            });
            
            // Bu gruptaki öğrencileri A grubuna taşı
            APP_STATE.studentData.forEach(student => {
                if (student.grup === lastGroup) {
                    student.grup = 'A';
                }
            });
            
            // Tüm ilgili UI'ları güncelle
            updateGroupSelectors();
            updateStudentTable();
            updateAssessmentView();
            updateAllInlineGroupInputs();
            updateAllMappingDisplays();
            updateGroupMappingColors();
            
            // Öğrenci bazlı not girişi ekranını da güncelle
            if (APP_STATE.selectedStudentId) {
                showStudentGrades(APP_STATE.selectedStudentId);
            }
            
            showModernToast(`Grup ${lastGroup} tüm bileşenlerden silindi, öğrenciler A grubuna taşındı`, "success");
        },
        `Grup ${lastGroup}'ı tüm değerlendirme bileşenlerinden silmek istediğinizden emin misiniz? Bu gruptaki tüm öğrenciler A grubuna taşınacak.`
    );
}

/**
 * Aktif grupları görüntüleme
 */
// updateActiveGroupsDisplay fonksiyonu kaldırıldı - artık her bileşenin kendi grup bilgisi var

/**
 * Grup seçicileri güncelleme - Bileşen bazlı
 */
function updateGroupSelectors() {
    console.log('🔄 updateGroupSelectors çağrıldı');
    
    try {
        // Öğrenci tablosundaki grup seçicilerini güncelle (genel gruplar)
        updateStudentTableGroupSelectors();
        
        // Değerlendirme girişindeki grup seçicilerini güncelle (bileşen bazlı)
        updateAssessmentGroupSelectors();
        
        // Öğrenci bazlı not girişindeki grup seçicilerini güncelle
        updateStudentGradesGroupSelectors();
        
    } catch (error) {
        console.error('Grup seçicileri güncellenirken hata:', error);
    }
}

/**
 * Öğrenci tablosundaki grup seçicilerini güncelle (genel sistem grupları)
 */
function updateStudentTableGroupSelectors() {
    // Öğrenci tablosunda genel sistem grupları kullanılır
    const allGroups = new Set(['A']); // A grubu her zaman var
    
    // Mevcut öğrencilerin gruplarından grup listesi oluştur
    if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
        APP_STATE.studentData.forEach(student => {
            if (student.grup) {
                allGroups.add(student.grup);
            }
        });
    }
    
    // Eğer grup sistemi varsa, tüm mevcut grupları ekle
    if (APP_STATE.courseData?.grupHaritalari) {
        Object.values(APP_STATE.courseData.grupHaritalari).forEach(component => {
            if (component.gruplar) {
                component.gruplar.forEach(group => {
                    // Sadece tek harf olan grupları ekle (A, B, C, D... - bileşen kodları değil)
                    if (group.length === 1 && /^[A-Z]$/.test(group)) {
                        allGroups.add(group);
                    }
                });
            }
        });
    }
    
    const groups = Array.from(allGroups).sort();
    
    // Sadece öğrenci tablosundaki grup seçicilerini güncelle
    document.querySelectorAll('#student-content .group-selector').forEach(select => {
        const currentValue = select.value;
        const studentId = select.dataset.studentId;
        select.innerHTML = '';
        
        groups.forEach(groupId => {
            const option = document.createElement('option');
            option.value = groupId;
            option.textContent = groupId;
            if (groupId === currentValue) {
                option.selected = true;
            }
            select.appendChild(option);
        });
        
        // Eğer öğrencinin grubu seçenekler arasında yoksa, varsayılan grubu seç
        if (!groups.includes(currentValue) && groups.length > 0) {
            select.value = groups[0];
            if (studentId) {
                const student = APP_STATE.studentData.find(s => s.studentId === studentId);
                if (student) {
                    student.grup = groups[0];
                }
            }
        }
    });
}

/**
 * Değerlendirme girişindeki grup seçicilerini güncelle (bileşen bazlı)
 */
function updateAssessmentGroupSelectors() {
    console.log('🎯 updateAssessmentGroupSelectors çağrıldı');
    
    // Değerlendirme girişindeki her bileşen için ayrı ayrı grup seçicilerini güncelle
    const groupSelectors = document.querySelectorAll('#assessment-content .group-selector');
    console.log(`  📋 Toplam ${groupSelectors.length} grup seçici bulundu`);
    
    groupSelectors.forEach((select, index) => {
        const studentId = select.dataset.studentId;
        let componentId = select.dataset.componentId;
        
        console.log(`  🔍 Seçici ${index + 1}: studentId=${studentId}, componentId=${componentId}`);
        
        if (!componentId) {
            // Component ID yoksa, en yakın assessment-subsection'dan bul
            const subsection = select.closest('.assessment-subsection');
            if (subsection && subsection.dataset.activityId) {
                componentId = subsection.dataset.activityId;
                console.log(`    📍 Subsection'dan componentId bulundu: ${componentId}`);
            }
            
            // Hala yoksa TR elementinden bul
            if (!componentId) {
                const row = select.closest('tr');
                if (row && row.dataset.componentId) {
                    componentId = row.dataset.componentId;
                    console.log(`    📍 TR'den componentId bulundu: ${componentId}`);
                }
            }
        }
        
        if (componentId && studentId) {
            // Bu bileşenin gruplarını al
            const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
            const componentGroups = component?.gruplar || ['A'];
            
            console.log(`    📊 ${componentId} bileşeni grupları:`, componentGroups);
            
            // Öğrencinin bu bileşendeki mevcut grubunu al
            const currentGroup = getStudentGroupForComponent(studentId, componentId);
            console.log(`    👤 Öğrenci ${studentId} mevcut grup: ${currentGroup}`);
            
            // Seçiciyi güncelle - DOM manipulation ile
            const currentValue = select.value; // Mevcut değeri koru
            
            // Önce mevcut option'ları temizle
            while (select.firstChild) {
                select.removeChild(select.firstChild);
            }
            
            // Yeni option'ları ekle
            componentGroups.forEach(groupId => {
                const option = document.createElement('option');
                option.value = groupId;
                option.textContent = groupId;
                if (groupId === currentGroup) {
                    option.selected = true;
                }
                select.appendChild(option);
                console.log(`      ➕ Option eklendi: ${groupId} ${groupId === currentGroup ? '(seçili)' : ''}`);
            });
            
            // Son kontrol
            console.log(`      🔍 Select element option sayısı: ${select.children.length}`);
            
            console.log(`    ✅ ${componentId} bileşeni için öğrenci ${studentId}: ${componentGroups.join(', ')} grupları, seçili: ${currentGroup}`);
        } else {
            console.warn(`    ⚠️ ComponentId veya StudentId eksik: componentId=${componentId}, studentId=${studentId}`);
            
            // En azından A grubunu ekle
            if (select.children.length === 0) {
                const option = document.createElement('option');
                option.value = 'A';
                option.textContent = 'A';
                option.selected = true;
                select.appendChild(option);
                console.log(`    🔧 Varsayılan A grubu eklendi`);
            }
        }
    });
    
    console.log('✅ updateAssessmentGroupSelectors tamamlandı');
}

/**
 * Öğrenci bazlı not girişindeki grup seçicilerini güncelle
 */
function updateStudentGradesGroupSelectors() {
    // Öğrenci bazlı not girişinde genel sistem grupları kullanılır
    const allGroups = new Set(['A']); // A grubu her zaman var
    
    // Mevcut öğrencilerin gruplarından grup listesi oluştur
    if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
        APP_STATE.studentData.forEach(student => {
            if (student.grup) {
                allGroups.add(student.grup);
            }
        });
    }
    
    const groups = Array.from(allGroups).sort();
    
    // Sadece öğrenci bazlı not girişindeki grup seçicilerini güncelle
    document.querySelectorAll('#assessment-content .group-selector').forEach(select => {
        const currentValue = select.value;
        const studentId = select.dataset.studentId;
        select.innerHTML = '';
        
        groups.forEach(groupId => {
            const option = document.createElement('option');
            option.value = groupId;
            option.textContent = groupId;
            if (groupId === currentValue) {
                option.selected = true;
            }
            select.appendChild(option);
        });
        
        // Eğer öğrencinin grubu seçenekler arasında yoksa, varsayılan grubu seç
        if (!groups.includes(currentValue) && groups.length > 0) {
            select.value = groups[0];
            if (studentId) {
                const student = APP_STATE.studentData.find(s => s.studentId === studentId);
                if (student) {
                    student.grup = groups[0];
                }
            }
        }
    });
}

/**
 * Öğrenci grup güncelleme (Tüm sekmelerde senkronize)
 */
function updateStudentGroup(selectElement) {
    const studentId = selectElement.dataset.studentId;
    const groupId = selectElement.value;
    
    console.log(`🔄 updateStudentGroup çağrıldı:`);
    console.log(`  - studentId: ${studentId}`);
    console.log(`  - groupId: ${groupId}`);
    console.log(`  - selectElement:`, selectElement);
    
    // Hangi etkinlik içinde bu grup değişikliği yapıldığını bul
    const componentId = findComponentIdFromGroupSelector(selectElement);
    console.log(`  - componentId: ${componentId}`);
    
    if (!componentId) {
        console.error("❌ Component ID bulunamadı!");
        return;
    }
    
    // Öğrenci verilerini güncelle (sadece bu etkinlik için)
    setStudentGroupForComponent(studentId, groupId, componentId);
    
    // Sadece bu etkinlikteki aynı öğrencinin diğer satırlarını güncelle
    updateComponentGroupSelectors(studentId, groupId, componentId);
    
    // Sadece bu etkinlikteki soru bilgilerini güncelle
    updateQuestionInfoForComponent(studentId, groupId, componentId);
    
    // Toast mesajı
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    const studentName = student ? `${student.name} ${student.surname}` : studentId;
    showModernToast(`${studentName} öğrencisi ${getComponentDisplayName(componentId)} etkinliğinde ${groupId} grubuna atandı`, "success");
}

/**
 * Grup bazlı notları yükleme
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} newGroupId - Yeni grup ID'si
 */
function loadGroupBasedGrades(studentId, newGroupId) {
    console.log(`🔄 loadGroupBasedGrades çağrıldı - Öğrenci: ${studentId}, Yeni Grup: ${newGroupId}`);
    
    try {
        // Öğrencinin not verilerini kontrol et
        if (!APP_STATE.gradesData || !APP_STATE.gradesData[studentId]) {
            console.log(`⚠️ ${studentId} öğrencisi için not verisi bulunamadı`);
            return;
        }
        
        const studentGrades = APP_STATE.gradesData[studentId];
        
        // Grup bazlı notlar kontrolü
        if (!studentGrades.grupBazliNotlar) {
            console.log(`📝 ${studentId} öğrencisi için grup bazlı not yapısı oluşturuluyor`);
            studentGrades.grupBazliNotlar = {};
            return;
        }
        
        const groupGrades = studentGrades.grupBazliNotlar[newGroupId];
        if (!groupGrades) {
            console.log(`📝 ${studentId} öğrencisi için ${newGroupId} grubunda henüz not girilmemiş`);
            return;
        }
        
        console.log(`📋 ${studentId} öğrencisi için ${newGroupId} grubundaki notlar yükleniyor:`, groupGrades);
        
        // Grup bazlı notları input alanlarına yükle
        Object.keys(groupGrades).forEach(activityId => {
            const grade = groupGrades[activityId];
            
            // Input alanını bul ve değeri yükle
            const assessmentInput = document.querySelector(`input[data-student-id="${studentId}"][data-activity-id="${activityId}"]`);
            if (assessmentInput) {
                assessmentInput.value = grade;
                assessmentInput.style.borderColor = "";
                
                // Maksimum puan kontrolü
                const maxPoints = parseFloat(assessmentInput.max) || 100;
                if (grade > maxPoints) {
                    assessmentInput.style.borderColor = "#ff6b6b";
                    assessmentInput.title = `Bu öğrencinin grubundaki bu sorunun maksimum puanı: ${maxPoints} (Mevcut değer ${grade} maksimumdan büyük!)`;
                }
                
                console.log(`  ✅ ${activityId}: ${grade} puan yüklendi`);
            } else {
                console.log(`  ⚠️ ${activityId} için input alanı bulunamadı`);
            }
            
            // Ana not verisini güncelle
            APP_STATE.gradesData[studentId][activityId] = grade;
        });
        
        // Hesaplanmış notları güncelle
        updateStudentCalculatedGrade(studentId);
        updateAssessmentGradeSummary(studentId);
        updateStudentSummary(studentId);
        
        console.log(`✅ ${studentId} öğrencisi için ${newGroupId} grubundaki notlar başarıyla yüklendi`);
        
    } catch (error) {
        console.error("Grup bazlı notlar yüklenirken hata oluştu:", error);
    }
}

/**
 * Grup seçicisinden hangi etkinlik içinde olduğunu bul
 */
function findComponentIdFromGroupSelector(selectElement) {
    // Üst elementlerde component ID'si arayalım
    let currentElement = selectElement;
    
    while (currentElement && currentElement !== document.body) {
        // TR elementinde data-component-id var mı?
        if (currentElement.dataset && currentElement.dataset.componentId) {
            return currentElement.dataset.componentId;
        }
        
        // Assessment subsection içinde mi?
        if (currentElement.classList && currentElement.classList.contains('assessment-subsection')) {
            // Başlık elementini bul ve component ID'sini çıkar
            const header = currentElement.querySelector('h5');
            if (header && header.textContent) {
                // "Ara Sınav" gibi başlıktan component ID'sini bulmaya çalış
                const allActivities = [...(APP_STATE.courseData?.ara || []), ...(APP_STATE.courseData?.final || [])];
                const activity = allActivities.find(act => act.name === header.textContent.trim());
                if (activity) {
                    return activity.id;
                }
            }
        }
        
        currentElement = currentElement.parentElement;
    }
    
    console.warn("Component ID bulunamadı, selectElement'in parent elementleri kontrol ediliyor...");
    return null;
}

/**
 * Bileşen için grup seçenekleri oluşturma
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} componentId - Bileşen ID'si
 * @returns {string} - HTML option elemanları
 */
function createGroupOptions(studentId, componentId) {
    // Bu bileşenin gruplarını al
    const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
    const groups = component?.gruplar || ['A'];
    
    // Öğrencinin bu bileşendeki mevcut grubunu al
    const studentCurrentGroup = getStudentGroupForComponent(studentId, componentId);
    
    // Grup seçeneklerini oluştur
    return groups.map(groupId => 
        `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
    ).join('');
}

/**
 * Öğrenci bazlı not girişindeki ana grup seçici için - tüm bileşenler için grup günceller
 */
function updateStudentGroupForAllComponents(selectElement) {
    const studentId = selectElement.dataset.studentId;
    const groupId = selectElement.value;
    
    console.log(`🔄 updateStudentGroupForAllComponents çağrıldı:`);
    console.log(`  - studentId: ${studentId}`);
    console.log(`  - groupId: ${groupId}`);
    
    // Öğrencinin genel grubunu güncelle
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    if (student) {
        student.grup = groupId;
    }
    
    // Tüm bileşenler için grup güncelle
    if (APP_STATE.courseData?.grupHaritalari) {
        Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
            setStudentGroupForComponent(studentId, groupId, componentId);
        });
    }
    
    // Öğrenci görünümünü yeniden oluştur
    showStudentGrades(studentId);
    
    // Toast mesajı
    const studentName = student ? `${student.name} ${student.surname}` : studentId;
    showModernToast(`${studentName} öğrencisi tüm bileşenlerde ${groupId} grubuna atandı`, "success");
}

/**
 * DOM event için wrapper fonksiyon
 */
function updateStudentGroupForComponent(selectElement) {
    const studentId = selectElement.dataset.studentId;
    const groupId = selectElement.value;
    const componentId = selectElement.dataset.componentId;
    
    console.log(`🔄 updateStudentGroupForComponent (DOM wrapper) çağrıldı:`);
    console.log(`  - studentId: ${studentId}`);
    console.log(`  - groupId: ${groupId}`);
    console.log(`  - componentId: ${componentId}`);
    
    if (!componentId) {
        console.error("❌ Component ID bulunamadı!");
        return;
    }
    
    // Öğrenci verilerini güncelle (sadece bu etkinlik için)
    setStudentGroupForComponent(studentId, groupId, componentId);
    
    // SENKRONIZASYON: Tüm sistemi güncelle
    synchronizeStudentGroupChanges(studentId, groupId, componentId);
    
    // Toast mesajı
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    const studentName = student ? `${student.name} ${student.surname}` : studentId;
    showModernToast(`${studentName} öğrencisi ${getComponentDisplayName(componentId)} etkinliğinde ${groupId} grubuna atandı - Tüm sistem senkronize edildi`, "success");
}

/**
 * Öğrenci grup değişikliğini tüm sisteme senkronize et
 */
function synchronizeStudentGroupChanges(studentId, groupId, componentId) {
    console.log(`🔄 synchronizeStudentGroupChanges başlatıldı:`);
    console.log(`  - studentId: ${studentId}`);
    console.log(`  - groupId: ${groupId}`);
    console.log(`  - componentId: ${componentId}`);
    
    // 1. Bu etkinlikteki aynı öğrencinin diğer satırlarını güncelle
    updateComponentGroupSelectors(studentId, groupId, componentId);
    
    // 2. Bu etkinlikteki soru bilgilerini güncelle
    updateQuestionInfoForComponent(studentId, groupId, componentId);
    
    // 3. Değerlendirme tablosundaki genel soru puanlarını güncelle
    updateQuestionPointsInAssessmentTable(studentId);
    
    // 4. Öğrenci Listesi sekmesindeki grup bilgilerini güncelle
    updateStudentListGroupInfo();
    
    // 5. Tüm sekmelerdeki grup seçicilerini güncelle
    updateAllTabGroupSelectors(studentId, groupId, componentId);
    
    // 6. Grup bazlı not yükleme
    loadGroupBasedGrades(studentId, groupId);
    
    // 7. Notlar sekmesini güncelle (eğer açıksa)
    if (document.querySelector('#grades-content.active')) {
        updateGradesView();
    }
    
    // 8. Değerlendirme görünümünü yenile (grup değişikliği sonrası)
    setTimeout(() => {
        refreshAssessmentViewForStudent(studentId, componentId);
    }, 100);
    
    console.log(`✅ Sistem senkronizasyonu tamamlandı`);
}

/**
 * Öğrenci Listesi sekmesindeki grup bilgilerini güncelle
 */
function updateStudentListGroupInfo() {
    console.log(`📋 Öğrenci Listesi grup bilgileri güncelleniyor...`);
    
    // Öğrenci grup bilgileri kartını güncelle
    const groupInfoCard = document.getElementById('studentGroupInfoCard');
    const groupInfoContainer = document.getElementById('studentGroupInfoContainer');
    
    if (!groupInfoCard || !groupInfoContainer) {
        console.log(`⚠️ Öğrenci grup bilgi bileşenleri bulunamadı`);
        return;
    }
    
    // Grup bilgilerini yeniden oluştur
    const hasGroupData = APP_STATE.studentComponentGroups && Object.keys(APP_STATE.studentComponentGroups).length > 0;
    
    if (!hasGroupData) {
        groupInfoCard.style.display = 'none';
        return;
    }
    
    groupInfoCard.style.display = 'block';
    
    // Grup bilgilerini düzenle
    let groupInfoHTML = '';
    const students = APP_STATE.studentData || [];
    const components = getAllComponents();
    
    if (students.length === 0 || components.length === 0) {
        groupInfoHTML = '<p class="empty-message">Öğrenci veya etkinlik verisi bulunmuyor.</p>';
    } else {
        // Etkinlik bazında grup bilgilerini göster
        components.forEach(component => {
            const componentGroups = {};
            
            students.forEach(student => {
                const studentGroup = getStudentGroupForComponent(student.studentId, component.id);
                if (studentGroup && studentGroup !== 'A') { // Varsayılan A grubunu gösterme
                    if (!componentGroups[studentGroup]) {
                        componentGroups[studentGroup] = [];
                    }
                    componentGroups[studentGroup].push(student);
                }
            });
            
            if (Object.keys(componentGroups).length > 0) {
                groupInfoHTML += `
                    <div class="component-group-info">
                        <h4 class="component-title">${getComponentDisplayName(component.id)}</h4>
                        <div class="groups-container">
                `;
                
                Object.keys(componentGroups).sort().forEach(groupId => {
                    const groupStudents = componentGroups[groupId];
                    groupInfoHTML += `
                        <div class="group-info">
                            <div class="group-header">
                                <span class="group-badge">${groupId} Grubu</span>
                                <span class="student-count">${groupStudents.length} öğrenci</span>
                            </div>
                            <div class="group-students">
                                ${groupStudents.map(student => 
                                    `<span class="student-tag">${student.studentId} - ${student.name} ${student.surname}</span>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                });
                
                groupInfoHTML += `
                        </div>
                    </div>
                `;
            }
        });
        
        if (!groupInfoHTML) {
            groupInfoHTML = '<p class="empty-message">Henüz grup ataması yapılmamış.</p>';
        }
    }
    
    groupInfoContainer.innerHTML = groupInfoHTML;
    console.log(`✅ Öğrenci Listesi grup bilgileri güncellendi`);
}

/**
 * Tüm sekmelerdeki grup seçicilerini güncelle
 */
function updateAllTabGroupSelectors(studentId, groupId, componentId) {
    console.log(`🔄 Tüm sekmelerdeki grup seçicileri güncelleniyor...`);
    
    // Değerlendirme Girişi sekmesindeki grup seçicilerini güncelle
    const assessmentSelectors = document.querySelectorAll(`#assessment-content select[data-student-id="${studentId}"][data-component-id="${componentId}"]`);
    assessmentSelectors.forEach(selector => {
        if (selector.value !== groupId) {
            selector.value = groupId;
            console.log(`✅ Assessment sekmesi grup seçicisi güncellendi: ${groupId}`);
        }
    });
    
    // Diğer sekmelerdeki benzer seçicileri de güncelle (gelecekte eklenebilir)
    console.log(`✅ Tüm sekmelerdeki grup seçicileri güncellendi`);
}

/**
 * Belirli öğrenci için değerlendirme görünümünü yenile
 */
function refreshAssessmentViewForStudent(studentId, componentId) {
    console.log(`🔄 Öğrenci ${studentId} için değerlendirme görünümü yenileniyor...`);
    
    // Sadece bu öğrencinin satırlarını yenile
    const studentRows = document.querySelectorAll(`#assessment-content tr[data-student-id="${studentId}"][data-component-id="${componentId}"]`);
    
    studentRows.forEach(row => {
        // Grup seçicisini kontrol et
        const groupSelector = row.querySelector('select[data-student-id]');
        if (groupSelector) {
            const currentGroup = getStudentGroupForComponent(studentId, componentId);
            if (groupSelector.value !== currentGroup) {
                groupSelector.value = currentGroup;
            }
        }
        
        // Soru bilgilerini güncelle
        const paperOrder = row.dataset.paperOrder;
        if (paperOrder) {
            const questionId = getQuestionIdByPaperOrder(studentId, parseInt(paperOrder), componentId);
            const question = findNodeById(questionId);
            
            // Puan bilgisini güncelle
            const pointsCell = row.querySelector('.question-points-cell');
            if (pointsCell && question) {
                pointsCell.textContent = question.points;
                pointsCell.dataset.activityId = questionId;
            }
            
            // Input alanını güncelle
            const input = row.querySelector('input[data-student-id]');
            if (input && question) {
                input.max = question.points;
                input.placeholder = `0-${question.points}`;
                input.dataset.activityId = questionId;
                
                // Max puan bilgisini güncelle
                let maxInfoSpan = input.parentElement.querySelector('.max-points-info');
                if (maxInfoSpan) {
                    maxInfoSpan.textContent = `(max: ${question.points})`;
                }
            }
        }
    });
    
    console.log(`✅ Öğrenci ${studentId} değerlendirme görünümü yenilendi`);
}

/**
 * Tüm bileşenleri (etkinlikleri) al
 */
function getAllComponents() {
    const components = [];
    
    if (!APP_STATE.courseData || !APP_STATE.courseData.children) {
        return components;
    }
    
    function collectComponents(nodes) {
        nodes.forEach(node => {
            if (node.type === 'activity') {
                components.push(node);
            }
            if (node.children && node.children.length > 0) {
                collectComponents(node.children);
            }
        });
    }
    
    collectComponents(APP_STATE.courseData.children);
    return components;
}

/**
 * Notlar sekmesini güncelle
 */
function updateGradesView() {
    console.log(`📊 Notlar sekmesi güncelleniyor...`);
    
    // Notları yeniden hesapla
    if (typeof calculateGrades === 'function') {
        calculateGrades();
    }
    
    console.log(`✅ Notlar sekmesi güncellendi`);
}

/**
 * Belirli bir etkinlik için öğrenci grubunu güncelle (veri işleme)
 */
function setStudentGroupForComponent(studentId, groupId, componentId) {
    // Etkinlik bazlı grup verilerini sakla
    if (!APP_STATE.studentComponentGroups) {
        APP_STATE.studentComponentGroups = {};
    }
    
    if (!APP_STATE.studentComponentGroups[studentId]) {
        APP_STATE.studentComponentGroups[studentId] = {};
    }
    
    APP_STATE.studentComponentGroups[studentId][componentId] = groupId;
    
    // v5 formatındaki grup bilgilerini de güncelle (en yüksek öncelikli)
    if (!APP_STATE.gradesData) {
        APP_STATE.gradesData = {};
    }
    
    if (!APP_STATE.gradesData[studentId]) {
        APP_STATE.gradesData[studentId] = {};
    }
    
    if (!APP_STATE.gradesData[studentId].grupBilgileri) {
        APP_STATE.gradesData[studentId].grupBilgileri = {};
    }
    
    APP_STATE.gradesData[studentId].grupBilgileri[componentId] = groupId;
    
    // EKLEME: courseData içindeki ogrenciNotlari yapısını da güncelle (v5 format için kritik!)
    if (APP_STATE.courseData && APP_STATE.courseData.ogrenciNotlari && APP_STATE.courseData.ogrenciNotlari[studentId]) {
        if (!APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri) {
            APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri = {};
        }
        APP_STATE.courseData.ogrenciNotlari[studentId].grupBilgileri[componentId] = groupId;
        console.log(`📝 courseData v5 formatında grup bilgisi güncellendi: ${studentId} -> ${componentId} -> ${groupId}`);
    }
    
    console.log(`📝 Öğrenci ${studentId} için ${componentId} etkinliğinde grup ${groupId} olarak güncellendi`);
    console.log(`  - Güncel componentGroups:`, APP_STATE.studentComponentGroups[studentId]);
    console.log(`  - Güncel v5 grupBilgileri:`, APP_STATE.gradesData[studentId].grupBilgileri);
}

/**
 * Belirli bir etkinlikteki grup seçicilerini güncelle
 */
function updateComponentGroupSelectors(studentId, groupId, componentId) {
    // Sadece değerlendirme girişindeki grup seçicilerini bul (öğrenci bazlı not girişi kaldırıldı)
    const assessmentRows = document.querySelectorAll(`#assessment-content tr[data-student-id="${studentId}"][data-component-id="${componentId}"]`);
    const componentRows = [...assessmentRows];
    
    console.log(`🔄 ${componentId} etkinliğinde ${studentId} öğrencisi için ${componentRows.length} satır bulundu (Assessment: ${assessmentRows.length})`);
    
    componentRows.forEach((row, index) => {
        const groupSelector = row.querySelector(`select[data-student-id="${studentId}"]`);
        if (groupSelector && groupSelector.value !== groupId) {
            console.log(`  - Satır ${index + 1} grup seçicisi güncellendi: ${groupSelector.value} → ${groupId}`);
            groupSelector.value = groupId;
        }
    });
}

/**
 * Belirli bir etkinlik için soru bilgilerini güncelle
 */
function updateQuestionInfoForComponent(studentId, groupId, componentId) {
    console.log(`🔄 updateQuestionInfoForComponent çağrıldı:`);
    console.log(`  - studentId: ${studentId}`);
    console.log(`  - groupId: ${groupId}`);
    console.log(`  - componentId: ${componentId}`);
    
    // Sadece değerlendirme girişindeki satırları bul (öğrenci bazlı not girişi kaldırıldı)
    const assessmentRows = document.querySelectorAll(`#assessment-content tr[data-student-id="${studentId}"][data-component-id="${componentId}"]`);
    const componentRows = [...assessmentRows];
    console.log(`📋 ${componentId} etkinliğinde ${studentId} için ${componentRows.length} satır bulundu (Assessment: ${assessmentRows.length})`);
    
    if (componentRows.length === 0) {
        console.warn(`⚠️ ${studentId} öğrencisi için ${componentId} etkinliğinde hiç satır bulunamadı!`);
        return;
    }
    
    componentRows.forEach((row, index) => {
        const paperOrder = row.dataset.paperOrder;
        
        console.log(`📝 Satır ${index + 1} (paperOrder: ${paperOrder}):`);
        
        if (paperOrder) {
            // Kağıt sırasından gerçek soru ID'sini al (yeni grupla)
            const questionId = getQuestionIdByPaperOrder(studentId, parseInt(paperOrder), componentId);
            const answerKeyOrder = getAnswerKeyOrder(studentId, parseInt(paperOrder), componentId);
            const outcomes = getQuestionOutcomesForStudent(studentId, questionId, componentId);
            
            console.log(`🔍 Hesaplanan değerler:`);
            console.log(`  - questionId: ${questionId}`);
            console.log(`  - answerKeyOrder: ${answerKeyOrder}`);
            console.log(`  - outcomes:`, outcomes);
            
            // Etkinlik max puanını güncelle
            const pointsCell = row.querySelector('.question-points-cell');
            if (pointsCell && questionId) {
                // Points cell'in data-activity-id değerini güncelle
                if (pointsCell.dataset.activityId !== questionId) {
                    console.log(`🔄 Points cell data-activity-id güncellendi: ${pointsCell.dataset.activityId} → ${questionId}`);
                    pointsCell.dataset.activityId = questionId;
                }
                
                // Sorunun ID'si bulunduysa, doğrudan o sorunun puanını al
                const question = findNodeById(questionId);
                const newPoints = question ? question.points : 0;
                console.log(`  - Soru bulundu: ${!!question}, Yeni puan: ${newPoints}`);
                pointsCell.textContent = newPoints;
                
                // Input alanının max değerini güncelle
                const input = row.querySelector(`input[data-student-id="${studentId}"]`);
                if (input) {
                    // Input'un data-activity-id değerini güncelle (grup değiştiğinde soru ID'si değişebilir)
                    if (questionId && input.dataset.activityId !== questionId) {
                        console.log(`🔄 Input data-activity-id güncellendi: ${input.dataset.activityId} → ${questionId}`);
                        input.dataset.activityId = questionId;
                    }
                    
                    input.max = newPoints;
                    input.placeholder = `0-${newPoints}`;
                    
                    // Maksimum puan bilgisini title'da göster
                    const maxPointsInfo = `📊 Maksimum Puan: ${newPoints}`;
                    input.title = `${maxPointsInfo} - Bu öğrencinin grubundaki bu sorunun maksimum puanı`;
                    
                    // Input yanına maksimum puan bilgisi ekle
                    let maxInfoSpan = input.parentElement.querySelector('.max-points-info');
                    if (!maxInfoSpan) {
                        maxInfoSpan = document.createElement('span');
                        maxInfoSpan.className = 'max-points-info';
                        maxInfoSpan.style.cssText = 'font-size: 10px; color: #666; margin-left: 5px; font-weight: bold;';
                        input.parentElement.appendChild(maxInfoSpan);
                    }
                    maxInfoSpan.textContent = `(max: ${newPoints})`;
                    
                    // Eğer mevcut değer yeni maksimumdan büyükse, uyarı ver ve düzelt
                    const currentValue = parseFloat(input.value);
                    if (currentValue > newPoints) {
                        const oldValue = currentValue;
                        input.value = newPoints; // Otomatik düzelt
                        input.style.borderColor = '#ff6b6b';
                        input.style.backgroundColor = '#fff5f5';
                        
                        // Düzeltilmiş değeri kaydet
                        if (questionId) {
                            // Grup bazlı not saklama sistemi
                            if (!APP_STATE.gradesData[studentId]) {
                                APP_STATE.gradesData[studentId] = {};
                            }
                            if (!APP_STATE.gradesData[studentId].grupBazliNotlar) {
                                APP_STATE.gradesData[studentId].grupBazliNotlar = {};
                            }
                            
                            const studentGroup = getStudentGroupForComponent(studentId, componentId);
                            if (!APP_STATE.gradesData[studentId].grupBazliNotlar[studentGroup]) {
                                APP_STATE.gradesData[studentId].grupBazliNotlar[studentGroup] = {};
                            }
                            
                            APP_STATE.gradesData[studentId].grupBazliNotlar[studentGroup][questionId] = newPoints;
                            APP_STATE.gradesData[studentId][questionId] = newPoints;
                            
                            console.log(`🔧 Puan otomatik düzeltildi: ${oldValue} → ${newPoints}`);
                        }
                        
                        showModernToast(`${studentId} öğrencisinin kağıt sırası ${paperOrder} sorusundaki puanı otomatik olarak ${oldValue} → ${newPoints} düzeltildi!`, "warning");
                        
                        // Borderi 3 saniye sonra temizle
                        setTimeout(() => {
                            input.style.borderColor = '';
                            input.style.backgroundColor = '';
                        }, 3000);
                    } else {
                        input.style.borderColor = '';
                        input.style.backgroundColor = '';
                    }
                    
                    // GRUP BAZLI NOT YÜKLEME: Yeni gruba geçince o grubun notunu yükle
                    const studentGroup = getStudentGroupForComponent(studentId, componentId);
                    if (APP_STATE.gradesData[studentId]?.grupBazliNotlar?.[studentGroup]?.[questionId] !== undefined) {
                        const savedGrade = APP_STATE.gradesData[studentId].grupBazliNotlar[studentGroup][questionId];
                        if (input.value !== savedGrade.toString()) {
                            input.value = savedGrade;
                            console.log(`📚 Grup bazlı not yüklendi: ${studentId} (${studentGroup} grubu) → Soru ${questionId} = ${savedGrade} puan`);
                        }
                    }
                }
            }
            
            // Cevap anahtarı sırasını güncelle
            const answerKeyBadge = row.querySelector('.answer-key-badge');
            if (answerKeyBadge) {
                const oldValue = answerKeyBadge.textContent;
                answerKeyBadge.textContent = answerKeyOrder || '?';
                console.log(`  - Cevap anahtarı sırası güncellendi: ${oldValue} → ${answerKeyOrder || '?'}`);
            }
            
            // Etkinlik adını güncelle - Gerçek etkinlik adını göster
            const questionNameBadge = row.querySelector('.question-name-badge');
            if (questionNameBadge) {
                const question = findNodeById(questionId);
                const realQuestionName = question?.name || `Soru ${answerKeyOrder || paperOrder}`;
                const oldName = questionNameBadge.textContent;
                questionNameBadge.textContent = realQuestionName;
                questionNameBadge.title = `${realQuestionName} (Cevap anahtarı sırası: ${answerKeyOrder})`;
                console.log(`  - Etkinlik adı güncellendi: "${oldName}" → "${realQuestionName}"`);
            }
            
            // Soru açıklamasını güncelle
            const questionDescBadge = row.querySelector('.question-desc-badge');
            if (questionDescBadge && questionId) {
                const question = findNodeById(questionId);
                const description = question ? (question.description || question.name || '-') : 'Soru bulunamadı';
                const oldValue = questionDescBadge.textContent;
                questionDescBadge.textContent = description;
                questionDescBadge.title = description;
                console.log(`  - Soru açıklaması güncellendi: "${oldValue}" → "${description}"`);
            }
            
            // ÖÇ değerini güncelle
            const outcomesBadge = row.querySelector('.outcomes-badge');
            if (outcomesBadge) {
                const oldValue = outcomesBadge.textContent;
                if (outcomes && outcomes.length > 0) {
                    outcomesBadge.textContent = outcomes.join(', ');
                    outcomesBadge.title = `Öğrenme Çıktıları: ${outcomes.join(', ')}`;
                    console.log(`  - ÖÇ güncellendi: "${oldValue}" → "${outcomes.join(', ')}"`);
                } else {
                    outcomesBadge.textContent = '';
                    outcomesBadge.title = 'Öğrenme çıktısı tanımlanmamış';
                    console.log(`  - ÖÇ temizlendi: "${oldValue}" → ""`);
                }
            }
            
            // Her satır için toplam puanı güncelle
            const totalPointsCell = row.querySelector('.total-points-cell');
            if (totalPointsCell) {
                const totalPoints = getStudentTotalEarnedPointsForComponent(studentId, componentId);
                totalPointsCell.textContent = totalPoints;
                
                // Badge içinde ise badge'i güncelle
                const totalPointsBadge = totalPointsCell.querySelector('.total-points-badge');
                if (totalPointsBadge) {
                    totalPointsBadge.textContent = totalPoints;
                }
                console.log(`  - Toplam puan güncellendi: ${totalPoints}`);
            }
            
            console.log(`✅ Satır ${index + 1} işlendi`);
        } else {
            // Basit etkinlik (paperOrder yok)
            console.log(`📝 Basit etkinlik satırı ${index + 1}:`);
            
            // Etkinlik max puanını güncelle
            const pointsCell = row.querySelector('.question-points-cell');
            if (pointsCell) {
                const activityId = pointsCell.dataset.activityId;
                if (activityId) {
                    const activity = findNodeById(activityId);
                    const newPoints = activity?.points || 0;
                    console.log(`  - Yeni puan: ${newPoints}`);
                    pointsCell.textContent = newPoints;
                    
                    // Input alanının max değerini güncelle
                    const input = row.querySelector(`input[data-student-id="${studentId}"]`);
                    if (input) {
                        input.max = newPoints;
                        input.placeholder = `0-${newPoints}`;
                        input.title = `Bu aktivitenin maksimum puanı: ${newPoints}`;
                        
                        // Input yanına maksimum puan bilgisi ekle (basit etkinlik için)
                        let maxInfoSpan = input.parentElement.querySelector('.max-points-info');
                        if (!maxInfoSpan) {
                            maxInfoSpan = document.createElement('span');
                            maxInfoSpan.className = 'max-points-info';
                            maxInfoSpan.style.cssText = 'font-size: 10px; color: #666; margin-left: 5px; font-weight: bold;';
                            input.parentElement.appendChild(maxInfoSpan);
                        }
                        maxInfoSpan.textContent = `(max: ${newPoints})`;
                    }
                }
            }
            
            // Her satır için toplam puanı güncelle
            const totalPointsCell = row.querySelector('.total-points-cell');
            if (totalPointsCell) {
                const totalPoints = getStudentTotalEarnedPointsForComponent(studentId, componentId);
                totalPointsCell.textContent = totalPoints;
                
                // Badge içinde ise badge'i güncelle
                const totalPointsBadge = totalPointsCell.querySelector('.total-points-badge');
                if (totalPointsBadge) {
                    totalPointsBadge.textContent = totalPoints;
                }
                console.log(`  - Toplam puan güncellendi: ${totalPoints}`);
            }
            
            console.log(`✅ Basit etkinlik satırı ${index + 1} işlendi`);
        }
    });
    
    console.log(`🏁 updateQuestionInfoForComponent tamamlandı`);
}

/**
 * Değerlendirme girişi sekmesindeki soru bilgilerini güncelleme (puan, açıklama, cevap anahtarı sırası, ÖÇ)
 */
function updateQuestionPointsInAssessmentTable(studentId) {
    console.log(`🔄 updateQuestionPointsInAssessmentTable çağrıldı - Öğrenci: ${studentId}`);
    
    // Bu öğrencinin tüm kağıt sırası satırlarını bul
    const paperOrderRows = document.querySelectorAll(`tr[data-student-id="${studentId}"]`);
    console.log(`📋 Bulunan satır sayısı: ${paperOrderRows.length}`);
    
    if (paperOrderRows.length === 0) {
        console.warn(`⚠️ ${studentId} öğrencisi için hiç satır bulunamadı!`);
        console.log(`🔍 Tüm tr elementleri:`, document.querySelectorAll('tr[data-student-id]'));
        return;
    }
    
    paperOrderRows.forEach((row, index) => {
        const paperOrder = row.dataset.paperOrder;
        const componentId = row.dataset.componentId;
        
        console.log(`📝 Satır ${index + 1}:`);
        console.log(`  - paperOrder: ${paperOrder}`);
        console.log(`  - componentId: ${componentId}`);
        console.log(`  - row.dataset:`, row.dataset);
        
        if (paperOrder && componentId) {
            // Öğrencinin grubunu al
            const studentGroup = getStudentGroupForComponent(studentId, componentId);
            console.log(`👥 Öğrenci grubu: ${studentGroup}`);
            
            // Kağıt sırasından gerçek soru ID'sini al
            const questionId = getQuestionIdByPaperOrder(studentId, parseInt(paperOrder), componentId);
            const answerKeyOrder = getAnswerKeyOrder(studentId, parseInt(paperOrder), componentId);
            const outcomes = getQuestionOutcomesForStudent(studentId, questionId, componentId);
            
            console.log(`🔍 Hesaplanan değerler:`);
            console.log(`  - questionId: ${questionId}`);
            console.log(`  - answerKeyOrder: ${answerKeyOrder}`);
            console.log(`  - outcomes:`, outcomes);
            
            // Etkinlik max puanını güncelle
            const pointsCell = row.querySelector('.question-points-cell');
            console.log(`💰 Points cell bulundu: ${!!pointsCell}`);
            
            if (pointsCell && questionId) {
                // Points cell'in data-activity-id değerini güncelle
                if (pointsCell.dataset.activityId !== questionId) {
                    console.log(`🔄 Points cell data-activity-id güncellendi: ${pointsCell.dataset.activityId} → ${questionId}`);
                    pointsCell.dataset.activityId = questionId;
                }
                
                // Sorunun ID'si bulunduysa, doğrudan o sorunun puanını al
                const question = findNodeById(questionId);
                const newPoints = question ? question.points : 0;
                console.log(`  - Soru bulundu: ${!!question}, Yeni puan: ${newPoints}`);
                pointsCell.textContent = newPoints;
                
                // Input alanının max değerini güncelle
                const input = row.querySelector(`input[data-student-id="${studentId}"]`);
                console.log(`  - Input bulundu: ${!!input}`);
                
                if (input) {
                    // Input'un data-activity-id değerini güncelle (grup değiştiğinde soru ID'si değişebilir)
                    if (questionId && input.dataset.activityId !== questionId) {
                        console.log(`🔄 Input data-activity-id güncellendi: ${input.dataset.activityId} → ${questionId}`);
                        input.dataset.activityId = questionId;
                    }
                    
                    input.max = newPoints;
                    input.placeholder = `0-${newPoints}`;
                    input.title = `Bu öğrencinin grubundaki bu sorunun maksimum puanı: ${newPoints}`;
                    
                    // Input yanına maksimum puan bilgisi ekle
                    let maxInfoSpan = input.parentElement.querySelector('.max-points-info');
                    if (!maxInfoSpan) {
                        maxInfoSpan = document.createElement('span');
                        maxInfoSpan.className = 'max-points-info';
                        maxInfoSpan.style.cssText = 'font-size: 10px; color: #666; margin-left: 5px; font-weight: bold;';
                        input.parentElement.appendChild(maxInfoSpan);
                    }
                    maxInfoSpan.textContent = `(max: ${newPoints})`;
                    
                    // Eğer mevcut değer yeni maksimumdan büyükse, uyarı ver
                    const currentValue = parseFloat(input.value);
                    if (currentValue > newPoints) {
                        input.style.borderColor = '#ff6b6b';
                        input.title += ` (Mevcut değer ${currentValue} maksimumdan büyük!)`;
                        showModernToast(`${studentId} öğrencisinin kağıt sırası ${paperOrder} sorusundaki puanı (${currentValue}) yeni maksimumdan (${newPoints}) büyük!`, "warning");
                    } else {
                        input.style.borderColor = '';
                    }
                }
            }
            
            // Cevap anahtarı sırasını güncelle
            const answerKeyCell = row.querySelector('.answer-key-order-cell');
            const answerKeyBadge = answerKeyCell?.querySelector('.answer-key-badge');
            console.log(`🔑 Answer key cell bulundu: ${!!answerKeyCell}, badge bulundu: ${!!answerKeyBadge}`);
            
            if (answerKeyBadge) {
                const oldValue = answerKeyBadge.textContent;
                answerKeyBadge.textContent = answerKeyOrder || '?';
                console.log(`  - Cevap anahtarı sırası güncellendi: ${oldValue} → ${answerKeyOrder || '?'}`);
            }
            
            // Soru açıklamasını güncelle
            const descriptionCell = row.querySelector('.question-description-cell');
            const questionDescBadge = descriptionCell?.querySelector('.question-desc-badge');
            console.log(`📝 Description cell bulundu: ${!!descriptionCell}, badge bulundu: ${!!questionDescBadge}`);
            
            if (questionDescBadge && questionId) {
                const question = findNodeById(questionId);
                const description = question ? question.description : 'Soru bulunamadı';
                const oldValue = questionDescBadge.textContent;
                questionDescBadge.textContent = description;
                questionDescBadge.title = description; // Full text tooltip
                console.log(`  - Soru açıklaması güncellendi: "${oldValue}" → "${description}"`);
            }
            
            // ÖÇ değerini güncelle
            const outcomesCell = row.querySelector('.outcomes-cell');
            const outcomesBadge = outcomesCell?.querySelector('.outcomes-badge');
            console.log(`🎯 Outcomes cell bulundu: ${!!outcomesCell}, badge bulundu: ${!!outcomesBadge}`);
            
            if (outcomesBadge) {
                const oldValue = outcomesBadge.textContent;
                if (outcomes && outcomes.length > 0) {
                    outcomesBadge.textContent = outcomes.join(', ');
                    outcomesBadge.title = `Öğrenme Çıktıları: ${outcomes.join(', ')}`;
                    console.log(`  - ÖÇ güncellendi: "${oldValue}" → "${outcomes.join(', ')}"`);
                } else {
                    outcomesBadge.textContent = '';
                    outcomesBadge.title = 'Öğrenme çıktısı tanımlanmamış';
                    console.log(`  - ÖÇ temizlendi: "${oldValue}" → ""`);
                }
            }
            
            console.log(`✅ Satır ${index + 1} işlendi`);
        } else {
            console.warn(`⚠️ Satır ${index + 1} atlandı - paperOrder veya componentId eksik`);
        }
    });
    
    console.log(`🏁 updateQuestionPointsInAssessmentTable tamamlandı`);
}

/**
 * Soru bilgilerini güncelleme
 */
function updateQuestionInfoDisplay(studentId, groupId) {
    const infoElement = document.getElementById(`questionInfo-${studentId}`);
    if (!infoElement || !groupId) {
        if (infoElement) infoElement.textContent = '';
        return;
    }
    
    // Grup haritalamalarını kontrol et
    const mappings = APP_STATE.courseData?.grupHaritalari?.[groupId];
    if (mappings) {
        const info = [];
        // DÜZELTME: Veri yapısı {position: questionId} formatında
        Object.keys(mappings).forEach(position => {
            const questionId = mappings[position];
            info.push(`S${position}→${questionId}`);
        });
        infoElement.textContent = `(${groupId} grubunda: ${info.join(', ')})`;
    }
}

/**
 * Tüm haritalama görüntüleri güncelleme
 */
function updateAllMappingDisplays() {
    // Öğrenci tablosundaki tüm grup bilgilerini güncelle
    APP_STATE.studentData.forEach(student => {
        if (student.grup) {
            updateQuestionInfoDisplay(student.studentId, student.grup);
        }
    });
    
    // Tree'deki haritalama kontrollerini güncelle
    updateTreeMappingControls();
}

/**
 * Tree'deki haritalama kontrollerini güncelleme
 */
function updateTreeMappingControls() {
    // Bu fonksiyon tree render edildiğinde çağrılacak
    // renderNode fonksiyonunda haritalama kontrolleri eklenecek
}

/**
 * Öğrenci grubunu alma (etkinlik bazlı)
 */
function getStudentGroup(studentId, componentId = null) {
    // Eğer componentId verilmişse, etkinlik bazlı grup al
    if (componentId && APP_STATE.studentComponentGroups && 
        APP_STATE.studentComponentGroups[studentId] && 
        APP_STATE.studentComponentGroups[studentId][componentId]) {
        return APP_STATE.studentComponentGroups[studentId][componentId];
    }
    
    // Yoksa genel grup bilgisini al
    const student = APP_STATE.studentData.find(s => s.studentId === studentId);
    return student?.grup || 'A'; // Varsayılan grup A
}

/**
 * Bileşen grup sayısını alma
 */
function getComponentGroupCount(componentId) {
    const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
    if (!component || !component.gruplar) {
        return 1; // En azından A grubu var
    }
    return component.gruplar.length;
}

/**
 * Bileşenin toplam puanını hesaplama (maksimum puan)
 */
function getComponentTotalPoints(componentId) {
    if (!componentId) return 0;
    
    try {
        const component = findNodeById(componentId);
        if (!component) return 0;
        
        // Eğer direkt points varsa kullan
        if (component.points) {
            return component.points;
        }
        
        // Alt öğelerin toplam puanını hesapla
        let totalPoints = 0;
        if (component.children && Array.isArray(component.children)) {
            component.children.forEach(child => {
                if (child.points) {
                    totalPoints += child.points;
                } else if (child.children) {
                    totalPoints += getComponentTotalPoints(child.id);
                }
            });
        }
        
        return totalPoints;
    } catch (error) {
        console.error(`getComponentTotalPoints hatası (${componentId}):`, error);
        return 0;
    }
}

/**
 * Öğrencinin belirli bir etkinlikten aldığı toplam puanı hesaplama (grup bazlı)
 */
function getStudentTotalEarnedPointsForComponent(studentId, componentId) {
    if (!studentId || !componentId) return 0;
    
    try {
        const component = findNodeById(componentId);
        if (!component) return 0;
        
        let totalEarnedPoints = 0;
        
        // Eğer basit etkinlik ise (alt öğe yok)
        if (!component.children || component.children.length === 0) {
            const grade = getStudentGrade(studentId, componentId) || 0;
            return grade;
        }
        
        // Alt öğelerin aldığı puanları topla
        component.children.forEach(child => {
            if (child.children && child.children.length > 0) {
                // Alt öğenin de çocukları varsa recursive çağır
                totalEarnedPoints += getStudentTotalEarnedPointsForComponent(studentId, child.id);
            } else {
                // Basit alt öğe - öğrencinin aldığı puanı al
                const grade = getStudentGrade(studentId, child.id) || 0;
                totalEarnedPoints += grade;
            }
        });
        
        return parseFloat(totalEarnedPoints.toFixed(2));
    } catch (error) {
        console.error(`getStudentTotalEarnedPointsForComponent hatası (${studentId}, ${componentId}):`, error);
        return 0;
    }
}

/**
 * Öğrencinin grubuna göre bileşen maksimum puanını hesaplama
 */
function getStudentTotalMaxPointsForComponent(studentId, componentId) {
    if (!studentId || !componentId) return 0;
    
    try {
        const component = findNodeById(componentId);
        if (!component) return 0;
        
        let totalMaxPoints = 0;
        
        // Eğer basit etkinlik ise (alt öğe yok)
        if (!component.children || component.children.length === 0) {
            return component.points || 0;
        }
        
        // Alt öğelerin maksimum puanlarını topla (grup bazlı)
        component.children.forEach(child => {
            if (child.children && child.children.length > 0) {
                // Alt öğenin de çocukları varsa recursive çağır
                totalMaxPoints += getStudentTotalMaxPointsForComponent(studentId, child.id);
            } else {
                // Basit alt öğe - öğrencinin grubuna göre maksimum puanı al
                const maxPoints = getQuestionPointsForStudentGroup(studentId, child.id, componentId);
                totalMaxPoints += maxPoints;
            }
        });
        
        return parseFloat(totalMaxPoints.toFixed(2));
    } catch (error) {
        console.error(`getStudentTotalMaxPointsForComponent hatası (${studentId}, ${componentId}):`, error);
        return 0;
    }
}

/**
 * Aktivitenin bağlı olduğu üst bileşeni bulma
 */
function getParentComponentId(activityId) {
    // A1.1 -> A1, F2.3 -> F2 gibi
    const parts = activityId.split('.');
    if (parts.length > 1) {
        return parts[0];
    }
    return activityId;
}

/**
 * Öğrencinin toplam puanlarını güncelleme
 */
function updateTotalPointsForStudent(studentId, activityId) {
    try {
        // Aktivitenin bağlı olduğu bileşeni bul
        const componentId = getParentComponentId(activityId) || activityId;
        
        // Bu öğrencinin bu bileşenle ilgili tüm satırlarını bul
        const relatedRows = document.querySelectorAll(`tr[data-student-id="${studentId}"][data-component-id="${componentId}"], tr[data-student-id="${studentId}"] .total-points-cell[data-student-id="${studentId}"][data-activity-id="${activityId}"]`);
        
        relatedRows.forEach(row => {
            const totalPointsCell = row.querySelector('.total-points-cell');
            if (totalPointsCell) {
                const totalPoints = getStudentTotalEarnedPointsForComponent(studentId, componentId);
                totalPointsCell.textContent = totalPoints;
                
                // Badge içinde ise badge'i güncelle
                const totalPointsBadge = totalPointsCell.querySelector('.total-points-badge');
                if (totalPointsBadge) {
                    totalPointsBadge.textContent = totalPoints;
                }
            }
        });
        
        // Öğrenci bazlı not girişi sekmesindeki badge'leri de güncelle
        const studentGradesBadges = document.querySelectorAll(`#studentGradesContainer .total-points-badge`);
        studentGradesBadges.forEach(badge => {
            const componentElement = badge.closest('[data-component-id]');
            if (componentElement && componentElement.dataset.componentId === componentId) {
                const totalPoints = getStudentTotalEarnedPointsForComponent(studentId, componentId);
                badge.textContent = totalPoints;
            }
        });
        
        console.log(`🔄 Toplam puanlar güncellendi - Öğrenci: ${studentId}, Bileşen: ${componentId}`);
        
    } catch (error) {
        console.error(`updateTotalPointsForStudent hatası:`, error);
    }
}

/**
 * Bileşendeki soru sayısını hesaplama
 */
function countQuestionsInComponent(componentId) {
    const node = findNodeById(componentId);
    if (!node || !node.children) {
        return 0;
    }
    
    let questionCount = 0;
    node.children.forEach(child => {
        if (isQuestionType(child.type) || isRubricType(child.type)) {
            questionCount++;
        }
    });
    
    return questionCount;
}

/**
 * Tüm bileşenlerin grup sayısını güncelleme
 */
function updateComponentGroupCounts() {
    document.querySelectorAll('.component-group-info').forEach(element => {
        const componentId = element.dataset.componentId;
        if (componentId) {
            const groupCount = getComponentGroupCount(componentId);
            const countElement = element.querySelector('.group-count');
            if (countElement) {
                countElement.textContent = `${groupCount} grup`;
            }
        }
    });
}

/**
 * Grup haritalama modal'ını gösterme
 */
function showGroupMappingModal(activityId) {
    const activity = findNodeById(activityId);
    if (!activity) return;
    
    APP_STATE.currentMappingNode = activity;
    mappingActivityName.textContent = activity.name;
    
    // Soru sayısı bilgisini göster
    let parentNode;
    if (activity && activity.id.includes('.')) {
        const parentId = activity.id.substring(0, activity.id.lastIndexOf('.'));
        parentNode = findNodeById(parentId);
    }
    
    const relatedQuestions = parentNode && parentNode.children ? parentNode.children.length : 1;
    const infoElement = document.querySelector('#groupMappingModal .info-message p');
    if (infoElement) {
        infoElement.textContent = `Bu sorunun hangi gruplarda hangi sırada yer alacağını belirleyin (Toplam ${relatedQuestions} soru):`;
    }
    
    // Mevcut haritalamları göster
    renderMappingRows(activityId);
    
    // Hızlı giriş alanını da güncelle
    updateBulkInputFromModalRows();
    
    // Hata mesajlarını temizle
    const errorContainer = document.getElementById('bulkErrorMessages');
    if (errorContainer) {
        errorContainer.innerHTML = '';
    }
    
    // Modal'ı göster
    openModernModal('groupMappingModal');
}

/**
 * Haritalama satırlarını render etme
 */
function renderMappingRows(activityId) {
    const mappingContainer = document.getElementById('mappingContainer');
    if (!mappingContainer) return;
    
    mappingContainer.innerHTML = '';
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(activityId);
    if (!parentComponentId) {
        mappingContainer.innerHTML = '<p class="error-message">Soru için bileşen bulunamadı</p>';
        return;
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component) {
        mappingContainer.innerHTML = '<p class="error-message">Bileşen grup verisi bulunamadı</p>';
        return;
    }
    
    const groups = component.gruplar || ['A'];
    const activity = findNodeById(activityId);
    
    // Sadece bu aktivitenin üst düğümündeki soruları al
    let parentNode;
    if (activity && activity.id.includes('.')) {
        const parentId = activity.id.substring(0, activity.id.lastIndexOf('.'));
        parentNode = findNodeById(parentId);
    }
    
    const relatedQuestions = parentNode && parentNode.children ? parentNode.children.length : 1;
    const maxPosition = relatedQuestions;
    
    groups.forEach(groupName => {
        // DÜZELTME: Veri yapısı {position: questionId} formatında
        const groupMappings = component.haritalar?.[groupName];
        const currentPosition = groupMappings ? Object.keys(groupMappings).find(pos => groupMappings[pos] === activityId) : null;
        
        const row = document.createElement('div');
        row.className = 'mapping-row-modal';
        row.innerHTML = `
            <select class="group-select" data-group="${groupName}">
                ${groups.map(g => `<option value="${g}" ${g === groupName ? 'selected' : ''}>Grup ${g}</option>`).join('')}
            </select>
            <select class="position-select" data-group="${groupName}">
                <option value="">Sıra Seç</option>
                ${Array.from({length: maxPosition}, (_, i) => {
                    const pos = i + 1;
                    const selected = currentPosition && currentPosition === pos.toString() ? 'selected' : '';
                    return `<option value="${pos}" ${selected}>${pos}. Soru</option>`;
                }).join('')}
            </select>
            <button class="remove-mapping-btn" onclick="removeMappingRow(this, '${groupName}', '${activityId}')">×</button>
        `;
        
        // Event listener'lar ekle - sadece görsel güncelleme için
        const groupSelect = row.querySelector('.group-select');
        const positionSelect = row.querySelector('.position-select');
        
        // Sadece hızlı giriş alanını güncelle, veriyi kaydetme
        groupSelect.addEventListener('change', () => {
            updateBulkInputFromModalRows();
        });
        
        positionSelect.addEventListener('change', () => {
            updateBulkInputFromModalRows();
        });
        
        mappingContainer.appendChild(row);
    });
}

/**
 * Haritalama satırı kaldırma (sadece modal'dan, veri kaydedilmez)
 */
function removeMappingRow(button, groupName, activityId) {
    // Sadece satırı kaldır, veriyi kaydetme
    button.closest('.mapping-row-modal').remove();
    
    // Hızlı giriş alanını güncelle
    updateBulkInputFromModalRows();
    
    showModernToast(`${groupName} grubundan haritalama kaldırıldı (geçici)`, "info");
}

/**
 * Haritalama kaydetme
 */
function saveGroupMapping() {
    if (!APP_STATE.currentMappingNode) return;
    
    const activityId = APP_STATE.currentMappingNode.id;
    const mappingContainer = document.getElementById('mappingContainer');
    
    // Validation: Duplicate ve hata kontrolü
    const newMappings = new Map(); // groupId -> position
    const usedPositions = new Map(); // groupId -> Set<position>
    let hasErrors = false;
    const errors = [];
    
    // Tüm grup seçicilerini kontrol et ve yeni haritalamayı topla
    mappingContainer.querySelectorAll('.mapping-row-modal').forEach(row => {
        const groupSelect = row.querySelector('.group-select');
        const positionSelect = row.querySelector('.position-select');
        
        const groupId = groupSelect.value;
        const position = parseInt(positionSelect.value);
        
        if (groupId && position) {
            // Aynı grup için duplicate position kontrolü
            if (!usedPositions.has(groupId)) {
                usedPositions.set(groupId, new Set());
            }
            
            if (usedPositions.get(groupId).has(position)) {
                hasErrors = true;
                errors.push(`Grup ${groupId}'da ${position}. sıra birden fazla kez atanmış`);
            } else {
                usedPositions.get(groupId).add(position);
                newMappings.set(groupId, position);
            }
        }
    });
    
    // Hata varsa kullanıcıyı bilgilendir
    if (hasErrors) {
        showModernToast(`Haritalama hataları:<br>${errors.join('<br>')}`, "error", 6000);
        return;
    }
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(activityId);
    if (!parentComponentId) {
        showModernToast('Soru için bileşen bulunamadı', 'error');
        return;
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component || !component.haritalar) {
        showModernToast('Bileşen grup verisi bulunamadı', 'error');
        return;
    }
    
    // Önce bu sorunun mevcut haritalamalarını kontrol et ve sil
    const oldMappings = [];
    Object.keys(component.haritalar).forEach(existingGroupName => {
        if (component.haritalar[existingGroupName]) {
            const existingPosition = Object.keys(component.haritalar[existingGroupName]).find(pos => 
                component.haritalar[existingGroupName][pos] === activityId
            );
            if (existingPosition) {
                oldMappings.push(`Grup ${existingGroupName} (${existingPosition}. sıra)`);
                // Eski pozisyonu sil
                delete component.haritalar[existingGroupName][existingPosition];
            }
        }
    });
    
    // Yeni haritalamayı uygula
    // DÜZELTME: Veri yapısı {position: questionId} formatında
    newMappings.forEach((position, groupName) => {
        if (!component.haritalar[groupName]) {
            component.haritalar[groupName] = {};
        }
        
        component.haritalar[groupName][position.toString()] = activityId;
    });
    
    // Kullanıcıya bilgi ver
    const activity = findNodeById(activityId);
    const activityName = activity ? activity.name : activityId;
    
    let message = `📝 "${activityName}" sorusu haritalama kaydedildi:`;
    if (oldMappings.length > 0) {
        message += `\n🗑️ Eski haritalamalar silindi: ${oldMappings.join(', ')}`;
    }
    if (newMappings.size > 0) {
        const newMappingList = Array.from(newMappings.entries()).map(([group, pos]) => `Grup ${group} (${pos}. sıra)`);
        message += `\n✅ Yeni haritalamalar: ${newMappingList.join(', ')}`;
    }
    
    showModernToast(message, "success", 4000);
    
    // Modal'ı kapat
    closeModernModal('groupMappingModal');
    
    // Görüntüleri güncelle
    updateAllMappingDisplays();
    updateTreeMappingControls();
    
    // Ağaçtaki buton renklerini güncelle
    updateGroupMappingColors();
    
    // Ana ekran grup girişlerini güncelle
    updateAllInlineGroupInputs();
    
    APP_STATE.currentMappingNode = null;
}

/**
 * Yeni haritalama satırı ekleme
 */
async function addMappingRow() {
    if (!APP_STATE.currentMappingNode) return;
    
    const activityId = APP_STATE.currentMappingNode.id;
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(activityId);
    if (!parentComponentId) {
        showModernToast("Soru için bileşen bulunamadı", "error");
        return;
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component) {
        showModernToast("Bileşen grup verisi bulunamadı", "error");
        return;
    }
    
    const groups = component.gruplar || ['A'];
    const groupNames = ['B', 'C', 'D', 'E', 'F', 'G', 'H'];
    const newGroupName = groupNames.find(name => !groups.includes(name));
    
    if (!newGroupName) {
        showModernToast("Bu etkinlik için maksimum grup sayısına ulaşıldı (H grubuna kadar)", "warning");
        return;
    }
    
    // Modern confirm dialog ile onay al
    const confirmed = await showModernConfirm(
        'Etkinliğe Grup Ekleme Onayı',
        `${getComponentDisplayName(parentComponentId)} etkinliğine grup ${newGroupName} eklenecek.\n\nBu grup eklendikten sonra:\n• Haritalama modalında görünecek\n• Öğrenci gruplarında seçilebilir olacak\n• A grubunun kopyası olarak oluşturulacak`,
        {
            confirmText: 'Evet, Ekle',
            cancelText: 'İptal',
            headerClass: 'success-action',
            iconClass: 'success'
        }
    );
    
    if (!confirmed) {
        return;
    }
    
    // Yeni grubu listeye ekle
    component.gruplar.push(newGroupName);
    
    // A grubunun kopyası olarak mapping oluştur (derin kopya)
    const groupAMapping = component.haritalar.A || {};
    component.haritalar[newGroupName] = JSON.parse(JSON.stringify(groupAMapping));
    
    // Eğer A grubunda mapping yoksa, varsayılan 1:1 mapping oluştur
    if (Object.keys(groupAMapping).length === 0) {
        const componentNode = findNodeById(parentComponentId);
        if (componentNode && componentNode.children) {
            let questionIndex = 1;
            componentNode.children.forEach(childNode => {
                if (isQuestionType(childNode.type) || isRubricType(childNode.type)) {
                    // DÜZELTME: Veri yapısı {position: questionId} formatında
                    component.haritalar.A[questionIndex.toString()] = childNode.id;
                    component.haritalar[newGroupName][questionIndex.toString()] = childNode.id;
                    questionIndex++;
                }
            });
        }
    }
    
    // UI'ları güncelle
    updateGroupSelectors();
    updateStudentTable();
    updateAssessmentView();
    updateAllInlineGroupInputs();
    updateAllMappingDisplays();
    updateGroupMappingColors();
    
    // Grup sayısını güncelle
    updateComponentGroupCounts();
    
    // Modal içeriğini yeniden render et
    renderMappingRows(activityId);
    
    showModernToast(`${getComponentDisplayName(parentComponentId)} etkinliğine grup ${newGroupName} başarıyla eklendi`, "success");
}

// =====================================================
// EVENT LİSTENER'LAR
// =====================================================

// Grup butonları HTML'den kaldırıldı - artık bileşen bazlı grup yönetimi kullanılıyor

// Haritalama kaydetme butonu
if (saveMappingBtn) {
    saveMappingBtn.addEventListener('click', saveGroupMapping);
}

// Haritalama satırı ekleme butonu
if (addMappingRowBtn) {
    addMappingRowBtn.addEventListener('click', addMappingRow);
}

// Toplu grup haritalama butonu
const applyBulkMappingBtn = document.getElementById('applyBulkMapping');
if (applyBulkMappingBtn) {
    applyBulkMappingBtn.addEventListener('click', applyBulkMapping);
}

/**
 * Öğrenci tablosundaki grup görüntüsünü güncelleme
 */
function updateStudentTableGroupDisplay(studentId, groupId) {
    // Bu fonksiyon artık kullanılmıyor - öğrenci listesinde grup gösterimi yok
    // Grup bilgileri ayrı bir kartta gösteriliyor
}

/**
 * Değerlendirme girişi sekmesindeki grup görüntüsünü güncelleme
 */
function updateAssessmentGroupDisplay(studentId, groupId) {
    const assessmentContainer = document.getElementById('assessmentContainer');
    if (assessmentContainer) {
        // Tüm assessment containerındaki grup seçicileri güncelle
        assessmentContainer.querySelectorAll(`select[data-student-id="${studentId}"]`).forEach(select => {
            if (select.value !== groupId) {
                select.value = groupId;
            }
        });
        
        // Eğer assessment sekmesi aktif ise ve seçenekler arasında grup yoksa view'ı yenile
        const activeTab = document.querySelector('.nav-content.active');
        if (activeTab && activeTab.id === 'assessment-content') {
            const groupOption = assessmentContainer.querySelector(`select[data-student-id="${studentId}"] option[value="${groupId}"]`);
            if (!groupOption) {
                // Grup seçeneği yoksa assessment view'ını yenile
                updateAssessmentView();
            }
        }
    }
}

/**
 * Öğrenci bazlı not girişi sekmesindeki grup görüntüsünü güncelleme
 */
function updateStudentGradesGroupDisplay(studentId, groupId) {
    const studentGradesContainer = document.getElementById('studentGradesContainer');
    if (studentGradesContainer) {
        const groupSelector = studentGradesContainer.querySelector(`select[data-student-id="${studentId}"]`);
        if (groupSelector && groupSelector.value !== groupId) {
            groupSelector.value = groupId;
        }
    }
}



/**
 * Grup haritalama durumunu kontrol etme
 * @param {string} nodeId - Kontrol edilecek düğüm ID'si
 * @returns {Object} - Haritalama durumu bilgisi
 */
function checkGroupMappingStatus(nodeId) {
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(nodeId);
    if (!parentComponentId) {
        return { isComplete: true, missingGroups: [], duplicatePositions: {}, hasMapping: false };
    }
    
    // Bu bileşenin gruplarını al
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    const activeGroups = component?.gruplar || ['A'];
    const mappingStatus = {
        isComplete: true,
        missingGroups: [],
        duplicatePositions: {},
        hasMapping: false
    };
    
    if (activeGroups.length <= 1) {
        // Tek grup varsa haritalama gerekmez
        mappingStatus.isComplete = true;
        return mappingStatus;
    }
    
    // Her grup için kontrol et
    activeGroups.forEach(groupId => {
        const groupMappings = component?.haritalar?.[groupId];
        // DÜZELTME: Veri yapısı {position: questionId} formatında
        const hasMapping = groupMappings && Object.values(groupMappings).includes(nodeId);
        if (!hasMapping) {
            mappingStatus.missingGroups.push(groupId);
            mappingStatus.isComplete = false;
        } else {
            mappingStatus.hasMapping = true;
        }
    });
    
    // Aynı pozisyonda birden fazla soru var mı kontrol et
    const positionGroups = {};
    activeGroups.forEach(groupId => {
        const groupMappings = component?.haritalar?.[groupId];
        if (groupMappings) {
            // DÜZELTME: Veri yapısı {position: questionId} formatında
            const position = Object.keys(groupMappings).find(pos => groupMappings[pos] === nodeId);
            if (position) {
            if (!positionGroups[position]) {
                positionGroups[position] = [];
            }
            positionGroups[position].push(groupId);
            }
        }
    });
    
    // Duplicate pozisyonları tespit et
    Object.keys(positionGroups).forEach(position => {
        if (positionGroups[position].length > 1) {
            mappingStatus.duplicatePositions[position] = positionGroups[position];
            mappingStatus.isComplete = false;
        }
    });
    
    return mappingStatus;
}

/**
 * Grup haritalama durumuna göre CSS sınıfı döndürme
 * @param {string} nodeId - Düğüm ID'si
 * @returns {string} - CSS sınıf adı
 */
function getGroupMappingStatusClass(nodeId) {
    const status = checkGroupMappingStatus(nodeId);
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(nodeId);
    if (!parentComponentId) {
        return 'group-single';
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    const activeGroups = component?.gruplar || ['A'];
    
    if (activeGroups.length <= 1) {
        return 'group-single'; // Tek grup
    }
    
    if (!status.hasMapping) {
        return 'group-unmapped'; // Hiç haritalama yok
    }
    
    if (!status.isComplete) {
        if (status.missingGroups.length > 0) {
            return 'group-incomplete'; // Eksik gruplar var
        }
        if (Object.keys(status.duplicatePositions).length > 0) {
            return 'group-duplicate'; // Duplicate pozisyonlar var
        }
    }
    
    return 'group-complete'; // Tam haritalanmış
}

/**
 * Toplu grup haritalama için format ayrıştırma
 * @param {string} input - Giriş metni (örn: "A:1,B:2,C:3")
 * @param {string} nodeId - Düğüm ID'si
 * @returns {Object} - Ayrıştırılmış haritalama
 */
function parseBulkGroupMapping(input, nodeId) {
    const mappings = {};
    const errors = [];
    
    if (!input.trim()) {
        return { mappings, errors };
    }
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(nodeId);
    if (!parentComponentId) {
        errors.push('Soru için bileşen bulunamadı');
        return { mappings, errors };
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component) {
        errors.push('Bileşen grup verisi bulunamadı');
        return { mappings, errors };
    }
    
    const availableGroups = component.gruplar || ['A'];
    const parts = input.split(',').map(p => p.trim());
    
    parts.forEach(part => {
        const colonIndex = part.indexOf(':');
        if (colonIndex === -1) {
            errors.push(`Geçersiz format: "${part}". "Grup:Pozisyon" formatında olmalı.`);
            return;
        }
        
        const groupId = part.substring(0, colonIndex).trim().toUpperCase();
        const position = part.substring(colonIndex + 1).trim();
        
        if (!availableGroups.includes(groupId)) {
            errors.push(`Geçersiz grup: "${groupId}". Bu bileşende mevcut gruplar: ${availableGroups.join(', ')}`);
            return;
        }
        
        if (!/^\d+$/.test(position) || parseInt(position) < 1) {
            errors.push(`Geçersiz pozisyon: "${position}". Pozitif sayı olmalı.`);
            return;
        }
        
        mappings[groupId] = position;
    });
    
    return { mappings, errors };
}

/**
 * Toplu grup haritalama uygulama
 */
function applyBulkMapping() {
    try {
        const bulkInput = document.getElementById('bulkMappingInput');
        const errorContainer = document.getElementById('bulkErrorMessages');
        
        if (!bulkInput || !APP_STATE.currentMappingNode) {
            return;
        }
        
        const input = bulkInput.value.trim();
        const nodeId = APP_STATE.currentMappingNode.id;
        
        // Hata mesajlarını temizle
        errorContainer.innerHTML = '';
        
        // Giriş ayrıştırma
        const { mappings, errors } = parseBulkGroupMapping(input, nodeId);
        
        // Hata varsa göster
        if (errors.length > 0) {
            errors.forEach(error => {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'bulk-error-message';
                errorDiv.textContent = error;
                errorContainer.appendChild(errorDiv);
            });
            return;
        }
        
        // Başarılı giriş
        if (Object.keys(mappings).length > 0) {
            // Modal satırlarını güncelle (bu haritalamayı da CourseData'ya kaydeder)
            updateModalRowsFromBulkInput(mappings);
            
            // Başarı animasyonu
            bulkInput.classList.add('success');
            setTimeout(() => {
                bulkInput.classList.remove('success');
            }, 600);
            
            showModernToast('Toplu haritalama başarıyla uygulandı', 'success');
        }
        
    } catch (error) {
        console.error('Toplu haritalama hatası:', error);
        showModernToast('Toplu haritalama uygulanamadı!', 'error');
    }
}

/**
 * Grup haritalama modal'ını kapattığında ağaçtaki buton renklerini güncelle
 */
function updateGroupMappingColors() {
    document.querySelectorAll('.btn-group-mapping').forEach(button => {
        const nodeId = button.dataset.nodeId;
        if (nodeId) {
            // Eski sınıfları kaldır
            button.classList.remove('group-single', 'group-unmapped', 'group-incomplete', 'group-duplicate', 'group-complete');
            // Yeni sınıfı ekle
            button.classList.add(getGroupMappingStatusClass(nodeId));
        }
    });
}

/**
 * Modal satırlarından hızlı giriş alanını güncelleme
 */
function updateBulkInputFromModalRows() {
    if (!APP_STATE.currentMappingNode) return;
    
    const nodeId = APP_STATE.currentMappingNode.id;
    const bulkInput = document.getElementById('bulkMappingInput');
    
    if (!bulkInput) return;
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(nodeId);
    if (!parentComponentId) return;
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component || !component.haritalar) return;
    
    const mappingPairs = [];
    const groups = component.gruplar || ['A'];
    
    // Her grup için haritalama bilgisini topla
    // DÜZELTME: Veri yapısı {position: questionId} formatında
    groups.forEach(groupName => {
        const groupMappings = component.haritalar[groupName];
        if (groupMappings) {
            const position = Object.keys(groupMappings).find(pos => groupMappings[pos] === nodeId);
            if (position) {
                mappingPairs.push(`${groupName}:${position}`);
            }
        }
    });
    
    // Alfabetik sırala
    mappingPairs.sort();
    
    // Hızlı giriş alanını güncelle
    bulkInput.value = mappingPairs.join(',');
}

/**
 * Hızlı girişten modal satırlarını güncelleme
 */
function updateModalRowsFromBulkInput(mappings) {
    if (!APP_STATE.currentMappingNode) return;
    
    const nodeId = APP_STATE.currentMappingNode.id;
    
    // Bu sorunun hangi bileşene ait olduğunu bul
    const parentComponentId = getParentComponentId(nodeId);
    if (!parentComponentId) return;
    
    const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
    if (!component || !component.haritalar) return;
    
    // Haritalamayı CourseData'ya uygula
    // DÜZELTME: Veri yapısı {position: questionId} formatında
    Object.keys(mappings).forEach(groupName => {
        if (!component.haritalar[groupName]) {
            component.haritalar[groupName] = {};
        }
        const position = mappings[groupName];
        component.haritalar[groupName][position] = nodeId;
    });
    
    // Modal satırlarını yenile
    renderMappingRows(nodeId);
}

/**
 * Mevcut haritalama metnini getirme
 * @param {string} nodeId - Düğüm ID'si
 * @returns {string} - Haritalama metni (örn: "A:1,B:2,C:3")
 */
function getCurrentMappingText(nodeId) {
    try {
        // Önce bu sorunun hangi bileşene ait olduğunu bul
        const parentComponentId = getParentComponentId(nodeId);
        if (!parentComponentId) {
            return '';
        }
        
        const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
        if (!component || !component.haritalar) {
            return '';
        }
        
        const mappingPairs = [];
        const groups = component.gruplar || ['A'];
        
        groups.forEach(groupName => {
            const groupMapping = component.haritalar[groupName];
            if (groupMapping) {
                // DÜZELTME: Veri yapısı {position: questionId} formatında
                // Bu sorunun hangi pozisyonda olduğunu bul
                const position = Object.keys(groupMapping).find(pos => groupMapping[pos] === nodeId);
                if (position) {
                    mappingPairs.push(`${groupName}:${position}`);
                }
            }
        });
        
        // Duplicate'leri temizle
        const uniquePairs = [...new Set(mappingPairs)];
        uniquePairs.sort();
        const result = uniquePairs.join(',');
        
        console.log(`📋 getCurrentMappingText(${nodeId}): "${result}"`, {
            parentComponentId,
            component: component ? {
                gruplar: component.gruplar,
                mappingKeys: Object.keys(component.haritalar || {}),
                fullMappings: component.haritalar
            } : null,
            mappingPairs: uniquePairs,
            foundMappings: mappingPairs
        });
        
        return result;
    } catch (error) {
        console.error('getCurrentMappingText hatası:', error);
        return '';
    }
}

/**
 * Ana ekran hızlı grup haritalama uygulama
 * @param {string} nodeId - Düğüm ID'si
 */
function applyInlineGroupMapping(nodeId) {
    try {
        const inputElement = document.querySelector(`.nodeGroupMapping[data-node-id="${nodeId}"]`);
        const buttonElement = document.querySelector(`.btn-apply-group-mapping[data-node-id="${nodeId}"]`);
        
        if (!inputElement) return;
        
        const input = inputElement.value.trim();
        
        // Buton loading durumu
        if (buttonElement) {
            buttonElement.classList.add('loading');
        }
        
        // Input'u normal duruma getir
        inputElement.classList.remove('success', 'error');
        
        // Giriş ayrıştırma
        const { mappings, errors } = parseBulkGroupMapping(input, nodeId);
        
        // Hata varsa göster
        if (errors.length > 0) {
            inputElement.classList.add('error');
            showModernToast(errors.join('<br>'), 'error', 4000);
            
            if (buttonElement) {
                buttonElement.classList.remove('loading');
            }
            return;
        }
        
        // Başarılı giriş
        if (Object.keys(mappings).length > 0) {
            // Bu sorunun hangi bileşene ait olduğunu bul
            const parentComponentId = getParentComponentId(nodeId);
            if (!parentComponentId) {
                showModernToast('Soru için bileşen bulunamadı', 'error');
                return;
            }
            
            const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
            if (!component || !component.haritalar) {
                showModernToast('Bileşen grup verisi bulunamadı', 'error');
                return;
            }
            
            // Önce mevcut haritalamları kontrol et ve eski pozisyonları temizle
            const oldMappings = [];
            Object.keys(component.haritalar).forEach(existingGroupName => {
                if (component.haritalar[existingGroupName]) {
                    const existingPosition = Object.keys(component.haritalar[existingGroupName]).find(pos => 
                        component.haritalar[existingGroupName][pos] === nodeId
                    );
                    if (existingPosition) {
                        // Eğer yeni haritalamada bu grup yoksa, eski pozisyonu kaydet
                        if (!mappings[existingGroupName]) {
                            oldMappings.push(`Grup ${existingGroupName} (${existingPosition}. sıra)`);
                        }
                        // Eski pozisyonu sil
                        delete component.haritalar[existingGroupName][existingPosition];
                    }
                }
            });
            
            // Haritalamayı uygula
            // DÜZELTME: Veri yapısı {position: questionId} formatında
            Object.keys(mappings).forEach(groupName => {
                if (!component.haritalar[groupName]) {
                    component.haritalar[groupName] = {};
                }
                const position = mappings[groupName];
                component.haritalar[groupName][position] = nodeId;
            });
            
            // Başarı animasyonu
            inputElement.classList.add('success');
            setTimeout(() => {
                inputElement.classList.remove('success');
            }, 600);
            
            // Grup butonunun rengini güncelle
            updateGroupMappingColors();
            
            // Değerlendirme sekmesini güncelle
            setTimeout(() => {
                updateAssessmentView();
            }, 100);
            
            // Kullanıcıya bilgi ver
            const activity = findNodeById(nodeId);
            const activityName = activity ? activity.name : nodeId;
            const newMappingText = Object.keys(mappings).map(g => `Grup ${g} (${mappings[g]}. sıra)`).join(', ');
            
            if (oldMappings.length > 0) {
                showModernToast(
                    `📝 "${activityName}" sorusu:<br>` +
                    `🗑️ Şu gruplardan silindi: ${oldMappings.join(', ')}<br>` +
                    `✅ Yeni atama: ${newMappingText}`, 
                    'info', 
                    4000
                );
            } else {
                showModernToast(
                    `📝 "${activityName}" sorusu:<br>` +
                    `✅ Grup haritalama uygulandı: ${newMappingText}`, 
                    'success', 
                    3000
                );
            }
        } else {
            // Boş giriş - mevcut haritalamayı temizle
            const parentComponentId = getParentComponentId(nodeId);
            if (parentComponentId) {
                const component = APP_STATE.courseData?.grupHaritalari?.[parentComponentId];
                if (component && component.haritalar) {
                    // DÜZELTME: Veri yapısı {position: questionId} formatında
                    Object.keys(component.haritalar).forEach(groupName => {
                        if (component.haritalar[groupName]) {
                            // Bu sorunun pozisyonunu bul ve sil
                            const position = Object.keys(component.haritalar[groupName]).find(pos => 
                                component.haritalar[groupName][pos] === nodeId
                            );
                            if (position) {
                                delete component.haritalar[groupName][position];
                            }
                        }
                    });
                }
            }
            
            updateGroupMappingColors();
            showModernToast('Grup haritalama temizlendi', 'info', 2000);
        }
        
        // Loading durumunu kaldır
        if (buttonElement) {
            setTimeout(() => {
                buttonElement.classList.remove('loading');
            }, 300);
        }
        
    } catch (error) {
        console.error('Ana ekran grup haritalama hatası:', error);
        showModernToast('Grup haritalama uygulanamadı!', 'error');
        
        const buttonElement = document.querySelector(`.btn-apply-group-mapping[data-node-id="${nodeId}"]`);
        if (buttonElement) {
            buttonElement.classList.remove('loading');
        }
    }
}

/**
 * Silinen soru/rubrik için grup haritalamalarını temizle ve pozisyonları yeniden düzenle
 * @param {string} nodeId - Silinen düğüm ID'si
 */
function cleanupGroupMappingsForDeletedNode(nodeId) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari) return;
        
        console.log(`🧹 Silinen düğüm için grup haritalama temizliği ve yeniden düzenleme: ${nodeId}`);
        
        // Bu sorunun hangi bileşene ait olduğunu bul
        const parentComponentId = getParentComponentId(nodeId);
        if (!parentComponentId) {
            console.log(`⚠️ Parent component bulunamadı: ${nodeId}`);
            return;
        }
        
        const component = APP_STATE.courseData.grupHaritalari[parentComponentId];
        if (!component || !component.haritalar) {
            console.log(`⚠️ Component mapping bulunamadı: ${parentComponentId}`);
            return;
        }
        
        let cleanupCount = 0;
        
        // Her grup için haritalamayı temizle ve yeniden düzenle
        Object.keys(component.haritalar).forEach(groupName => {
            if (component.haritalar[groupName]) {
                const groupMapping = component.haritalar[groupName];
                
                console.log(`🔍 Grup ${groupName} - silme öncesi mapping:`, {...groupMapping});
                
                // 1. Silinen sorunun pozisyonunu bul
                let deletedPosition = null;
                Object.keys(groupMapping).forEach(position => {
                    if (groupMapping[position] === nodeId) {
                        deletedPosition = parseInt(position);
                        delete groupMapping[position];
                        cleanupCount++;
                        console.log(`🗑️ Silindi: Grup ${groupName}, Pozisyon ${position}, Soru ${nodeId}`);
                    }
                });
                
                // 2. Eğer silinen pozisyon varsa, sonraki pozisyonları kaydır
                if (deletedPosition !== null) {
                    console.log(`📐 Pozisyon kayması başlatılıyor: ${deletedPosition} pozisyonundan itibaren`);
                    
                    // Mevcut pozisyonları sırala
                    const sortedPositions = Object.keys(groupMapping)
                        .map(pos => parseInt(pos))
                        .filter(pos => !isNaN(pos))
                        .sort((a, b) => a - b);
                    
                    console.log(`📋 Sıralı pozisyonlar:`, sortedPositions);
                    
                    // Yeni mapping oluştur - pozisyonları sıkıştır
                    const newMapping = {};
                    let newPosition = 1;
                    
                    sortedPositions.forEach(oldPosition => {
                        const questionId = groupMapping[oldPosition.toString()];
                        if (questionId) {
                            newMapping[newPosition.toString()] = questionId;
                            console.log(`🔄 Pozisyon değişimi: ${questionId} => ${oldPosition} → ${newPosition}`);
                            newPosition++;
                        }
                    });
                    
                    // Eski mapping'i temizle ve yenisini ata
                    component.haritalar[groupName] = newMapping;
                    
                    console.log(`✅ Grup ${groupName} - yeniden düzenleme sonrası:`, {...newMapping});
                }
            }
        });
        
        if (cleanupCount > 0) {
            console.log(`✅ ${cleanupCount} grup haritalama temizlendi ve pozisyonlar yeniden düzenlendi`);
            
            // UI güncellemeleri
            updateGroupMappingColors();
            updateAllInlineGroupInputs();
            updateAllMappingDisplays();
            
            showModernToast(`Soru silindi ve grup pozisyonları güncellendi`, "success", 3000);
        } else {
            console.log(`ℹ️ ${nodeId} için temizlenecek grup haritalama bulunamadı`);
        }
        
    } catch (error) {
        console.error("Grup haritalama temizliği sırasında hata:", error);
        showModernToast("Grup haritalama temizliği başarısız!", "warning");
    }
}

/**
 * Soru/rubrik eklendikten sonra grup haritalamalarını güncelle
 * @param {string} parentComponentId - Ana bileşen ID'si
 */
function updateGroupMappingsAfterNodeAdd(parentComponentId) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari) return;
        
        console.log(`🔄 Soru ekleme sonrası grup haritalama güncelleniyor: ${parentComponentId}`);
        
        const component = APP_STATE.courseData.grupHaritalari[parentComponentId];
        if (!component) {
            console.log(`ℹ️ ${parentComponentId} için grup yapısı bulunamadı, varsayılan oluşturuluyor...`);
            createDefaultMappingForComponent(parentComponentId);
            return;
        }
        
        // Mevcut sorular ile haritalamayı senkronize et
        const parentNode = findNodeById(parentComponentId);
        if (parentNode && parentNode.children) {
            const questions = parentNode.children.filter(child => 
                isQuestionType(child.type) || isRubricType(child.type)
            );
            
            // Her grup için eksik haritalamları kontrol et ve otomatik ekle
            const groups = component.gruplar || ['A'];
            groups.forEach(groupName => {
                if (!component.haritalar[groupName]) {
                    component.haritalar[groupName] = {};
                }
                
                // Yeni eklenen sorular için otomatik haritalama oluştur
                questions.forEach((question, index) => {
                    const hasMapping = Object.values(component.haritalar[groupName]).includes(question.id);
                    if (!hasMapping) {
                        // Mevcut pozisyonları kontrol et ve sıralı olarak en sona ekle
                        const existingPositions = Object.keys(component.haritalar[groupName])
                            .map(pos => parseInt(pos))
                            .filter(pos => !isNaN(pos))
                            .sort((a, b) => a - b);
                        
                        // Sıralı pozisyon ata (boşluk varsa doldur, yoksa en sona ekle)
                        let nextPosition = 1;
                        for (let i = 0; i < existingPositions.length; i++) {
                            if (existingPositions[i] !== nextPosition) {
                                break; // Boşluk bulundu
                            }
                            nextPosition++;
                        }
                        
                        component.haritalar[groupName][nextPosition.toString()] = question.id;
                        console.log(`➕ Otomatik haritalama: Grup ${groupName}, Pozisyon ${nextPosition}, Soru ${question.id}`);
                    }
                });
            });
        }
        
        // UI güncellemeleri
        updateGroupMappingColors();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        
        console.log(`✅ Grup haritalama güncelleme tamamlandı: ${parentComponentId}`);
        
    } catch (error) {
        console.error("Grup haritalama güncelleme hatası:", error);
    }
}

/**
 * Grup haritalamalarında pozisyon değiştirme (sıralama değişikliği)
 * @param {string} componentId - Bileşen ID'si
 * @param {string} groupName - Grup adı
 * @param {string} questionId - Soru ID'si
 * @param {number} newPosition - Yeni pozisyon
 */
function changeQuestionPosition(componentId, groupName, questionId, newPosition) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari?.[componentId]?.haritalar?.[groupName]) {
            console.error(`Grup ${groupName} haritalama bulunamadı: ${componentId}`);
            return false;
        }
        
        const groupMapping = APP_STATE.courseData.grupHaritalari[componentId].haritalar[groupName];
        
        console.log(`🔄 Pozisyon değişikliği: ${questionId} → Pozisyon ${newPosition}`);
        console.log(`📋 Değişiklik öncesi mapping:`, {...groupMapping});
        
        // 1. Mevcut pozisyonu bul ve kaldır
        let oldPosition = null;
        Object.keys(groupMapping).forEach(pos => {
            if (groupMapping[pos] === questionId) {
                oldPosition = parseInt(pos);
                delete groupMapping[pos];
            }
        });
        
        if (oldPosition === null) {
            console.error(`Soru ${questionId} grup ${groupName} haritalamada bulunamadı`);
            return false;
        }
        
        // 2. Yeni pozisyonda başka soru varsa yer değiştir
        const existingQuestionAtNewPos = groupMapping[newPosition.toString()];
        if (existingQuestionAtNewPos) {
            // Yer değiştirme
            groupMapping[oldPosition.toString()] = existingQuestionAtNewPos;
            console.log(`🔄 Yer değişimi: ${existingQuestionAtNewPos} => ${newPosition} → ${oldPosition}`);
        }
        
        // 3. Soruyu yeni pozisyona yerleştir
        groupMapping[newPosition.toString()] = questionId;
        
        console.log(`✅ Pozisyon değişikliği tamamlandı:`, {...groupMapping});
        
        // UI güncellemeleri
        updateGroupMappingColors();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        updateAssessmentView();
        
        showModernToast(`Soru pozisyonu değiştirildi: ${oldPosition} → ${newPosition}`, "success");
        return true;
        
    } catch (error) {
        console.error("Pozisyon değişikliği hatası:", error);
        showModernToast("Pozisyon değiştirilemedi!", "error");
        return false;
    }
}

/**
 * Tüm ana ekran grup girişlerini güncelleme
 */
function updateAllInlineGroupInputs() {
    document.querySelectorAll('.nodeGroupMapping').forEach(input => {
        const nodeId = input.dataset.nodeId;
        if (nodeId) {
            const mappingText = getCurrentMappingText(nodeId);
            input.value = mappingText;
        }
    });
    
    // Bileşen grup bilgilerini de güncelle
    document.querySelectorAll('.componentGroupInfo').forEach(input => {
        const componentId = input.dataset.componentId;
        if (componentId) {
            updateComponentGroupInfo(componentId);
        }
    });
}

/**
 * Bileşen grup bilgisini güncelleme - v5 format uyumlu
 * @param {string} componentId - Bileşen ID'si
 */
function updateComponentGroupInfo(componentId) {
    // Alt öğeler (soru/rubrik) için textarea yoksa sessizce geç
    if (componentId.includes('.')) {
        return; // Alt öğeler için grup bilgisi textarea'sı yok, normal durum
    }
    
    const componentGroupTextarea = document.querySelector(`.componentGroupInfo[data-component-id="${componentId}"]`);
    if (!componentGroupTextarea) {
        console.log(`⚠️ updateComponentGroupInfo: ${componentId} için textarea bulunamadı`);
        return;
    }
    
    const component = APP_STATE.courseData?.grupHaritalari?.[componentId];
    if (!component) {
        console.log(`⚠️ updateComponentGroupInfo: ${componentId} için grup bilgisi bulunamadı`);
        componentGroupTextarea.value = 'A (Tek grup - Grup bilgisi yüklenemedi)';
        return;
    }
    
    const groups = component.gruplar || ['A'];
    console.log(`📊 updateComponentGroupInfo(${componentId}): Gruplar:`, groups);
    console.log(`📊 updateComponentGroupInfo(${componentId}): Mappings:`, component.haritalar);
    
    // v5 formatında detaylı grup bilgisi göster
    let groupInfo = `Gruplar: ${groups.join(', ')}`;
    
    // Mapping bilgisi varsa örnekle - v5 format uyumlu
    if (component.haritalar && Object.keys(component.haritalar).length > 0) {
        const sampleMappings = [];
        groups.slice(0, 2).forEach(groupName => { // İlk 2 grubu göster
            const groupMapping = component.haritalar[groupName];
            if (groupMapping && Object.keys(groupMapping).length > 0) {
                // v5 formatında pozisyon anahtarları string olabilir
                const positions = Object.keys(groupMapping).sort((a, b) => {
                    const numA = parseInt(a) || 0;
                    const numB = parseInt(b) || 0;
                    return numA - numB;
                });
                
                if (positions.length > 0) {
                    const samplePositions = positions.slice(0, 3); // İlk 3 pozisyonu göster
                    const positionInfo = samplePositions.map(pos => {
                        const soruId = groupMapping[pos];
                        // v5 formatında soruId uzun olabilir, kısalt
                        const shortSoruId = soruId.length > 10 ? soruId.substring(0, 10) + '...' : soruId;
                        return `${shortSoruId}:${pos}`;
                    }).join(',');
                    sampleMappings.push(`${groupName}(${positionInfo})`);
                }
            }
        });
        
        if (sampleMappings.length > 0) {
            groupInfo += `\nSoru Sıralaması: ${sampleMappings.join('; ')}`;
        } else {
            groupInfo += `\n(Henüz soru sıralaması atanmamış)`;
        }
    } else {
        groupInfo += `\n(Henüz grup mapping'i yapılmamış)`;
    }
    
    componentGroupTextarea.value = groupInfo;
    
    console.log(`✅ updateComponentGroupInfo(${componentId}): "${groupInfo}"`);
    
    // Auto-resize tetikle
    const event = new Event('input');
    componentGroupTextarea.dispatchEvent(event);
}

/**
 * Auto-resize textarea based on content - vertical expansion
 * @param {HTMLTextAreaElement} textarea - Textarea element to setup auto-resize
 */
function setupAutoResize(textarea) {
    if (!textarea) return;
    
    function adjustHeight() {
        // Reset height to auto to get the natural content height
        textarea.style.height = 'auto';
        
        // Calculate the scroll height
        const scrollHeight = textarea.scrollHeight;
        
        // Set minimum and maximum heights
        const minHeight = 32;
        const maxHeight = 150; // Maximum height before scroll
        
        // Set the new height
        const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight);
        textarea.style.height = newHeight + 'px';
        
        // Enable scroll if content exceeds max height
        if (scrollHeight > maxHeight) {
            textarea.style.overflowY = 'auto';
        } else {
            textarea.style.overflowY = 'hidden';
        }
    }
    
    // Add event listeners for height adjustment
    textarea.addEventListener('input', adjustHeight);
    textarea.addEventListener('change', adjustHeight);
    textarea.addEventListener('keyup', adjustHeight);
    textarea.addEventListener('focus', adjustHeight);
    textarea.addEventListener('paste', () => setTimeout(adjustHeight, 0));
    
    // Initial adjustment
    setTimeout(adjustHeight, 0);
}

/**
 * Default değerlendirme ağacı oluşturur
 */
function createDefaultAssessmentTree() {
    try {
        APP_STATE.assessmentTree = [
            {
                id: 'A1',
                name: 'Ara Sınav',
                type: 'Ara Sınav',
                weight: 40,
                points: 100,
                outcomes: getSmartOutcomes(3),
                description: 'Yarıyıl içi değerlendirme',
                expanded: true,
                children: [
                    {
                        id: 'A1.1',
                        name: 'Soru 1',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: getSmartOutcomes(1),
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'A1.2',
                        name: 'Soru 2',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: getSmartOutcomes(1),
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'A1.3',
                        name: 'Soru 3',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: getSmartOutcomes(1),
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'A1.4',
                        name: 'Soru 4',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: getSmartOutcomes(1),
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'A1.5',
                        name: 'Soru 5',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: getSmartOutcomes(1),
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    }
                ]
            },
            {
                id: 'F1',
                name: 'Final Sınavı',
                type: 'Final Sınavı',
                weight: 60,
                points: 100,
                outcomes: getSmartOutcomes(4),
                description: 'Yarıyıl sonu değerlendirme',
                expanded: true,
                children: [
                    {
                        id: 'F1.1',
                        name: 'Soru 1',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: [], // ÖÇ'leri boş bırak, kullanıcı manuel olarak atayacak
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'F1.2',
                        name: 'Soru 2',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: [], // ÖÇ'leri boş bırak, kullanıcı manuel olarak atayacak
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'F1.3',
                        name: 'Soru 3',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: [], // ÖÇ'leri boş bırak, kullanıcı manuel olarak atayacak
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'F1.4',
                        name: 'Soru 4',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: [], // ÖÇ'leri boş bırak, kullanıcı manuel olarak atayacak
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    },
                    {
                        id: 'F1.5',
                        name: 'Soru 5',
                        type: 'Soru',
                        weight: 20,
                        points: 20,
                        outcomes: [], // ÖÇ'leri boş bırak, kullanıcı manuel olarak atayacak
                        description: 'Değerlendirme sorusu',
                        expanded: false,
                        children: []
                    }
                ]
            }
        ];
        
        console.log('Default değerlendirme ağacı oluşturuldu');
    } catch (error) {
        console.error("Default değerlendirme ağacı oluşturulurken hata:", error);
    }
}

/**
 * Grup veri yapısını doğrulama ve tamamlama
 */
function validateAndCompleteGroupData() {
    try {
        if (!APP_STATE.courseData?.grupHaritalari) {
            console.log('Grup haritaları bulunamadı, yeniden oluşturuluyor...');
            createDefaultMapping();
            return;
        }
        
        const grupHaritalari = APP_STATE.courseData.grupHaritalari;
        let hasChanges = false;
        
        // Her değerlendirme bileşeni için doğrula
        APP_STATE.assessmentTree.forEach(mainComponent => {
            if (mainComponent.id.startsWith('A') || mainComponent.id.startsWith('F')) {
                const componentId = mainComponent.id;
                
                // Bileşen için grup verisi yoksa oluştur
                if (!grupHaritalari[componentId]) {
                    grupHaritalari[componentId] = {
                        gruplar: ['A'],
                        haritalar: { A: {} }
                    };
                    hasChanges = true;
                    console.log(`${componentId} için varsayılan grup verisi oluşturuldu`);
                }
                
                const component = grupHaritalari[componentId];
                
                // Groups dizisi yoksa veya boşsa
                if (!component.gruplar || !Array.isArray(component.gruplar) || component.gruplar.length === 0) {
                    component.gruplar = ['A'];
                    hasChanges = true;
                }
                
                // A grubu yoksa ekle
                if (!component.gruplar.includes('A')) {
                    component.gruplar.unshift('A');
                    hasChanges = true;
                }
                
                // Mappings objesi yoksa oluştur
                if (!component.haritalar || typeof component.haritalar !== 'object') {
                    component.haritalar = {};
                    hasChanges = true;
                }
                
                // Her grup için mapping yoksa oluştur
                component.gruplar.forEach(groupName => {
                    if (!component.haritalar[groupName]) {
                        // A grubunun kopyasını oluştur (eğer varsa)
                        if (groupName !== 'A' && component.haritalar.A && Object.keys(component.haritalar.A).length > 0) {
                            component.haritalar[groupName] = JSON.parse(JSON.stringify(component.haritalar.A));
                        } else {
                            component.haritalar[groupName] = {};
                        }
                        hasChanges = true;
                        console.log(`${componentId}: ${groupName} grubu için mapping oluşturuldu`);
                    } else if (groupName !== 'A' && Object.keys(component.haritalar[groupName]).length === 0 && 
                              component.haritalar.A && Object.keys(component.haritalar.A).length > 0) {
                        // Eğer grup mapping'i boşsa ve A grubunda veri varsa, A'dan kopyala
                        component.haritalar[groupName] = JSON.parse(JSON.stringify(component.haritalar.A));
                        hasChanges = true;
                        console.log(`${componentId}: ${groupName} grubu için boş mapping A grubundan kopyalandı`);
                    }
                });
            }
        });
        
        if (hasChanges) {
            console.log('Grup veri yapısı güncellendi:', grupHaritalari);
        }
        
    } catch (error) {
        console.error('Grup veri doğrulaması sırasında hata:', error);
        createDefaultMapping();
    }
}

/**
 * Öğrencilere default grup ataması yapar - HER ÖĞRENCİ MUTLAKA BİR GRUBA ATANMALI
 */
function assignDefaultGroups() {
    try {
        console.log(`🎯 assignDefaultGroups başlatıldı...`);
        
        if (!APP_STATE.studentData || !Array.isArray(APP_STATE.studentData)) {
            console.log(`⚠️ Öğrenci verisi yok, işlem atlanıyor`);
            return;
        }
        
        console.log(`👥 ${APP_STATE.studentData.length} öğrenci kontrol ediliyor...`);
        
        let hasChanges = false;
        let assignedToA = 0;
        let alreadyAssigned = 0;
        
        // Mevcut grupları kontrol et - A grubu her zaman geçerli
        const availableGroups = Object.keys(APP_STATE.courseData?.grupHaritalari || {});
        let validGroups = ['A']; // Her zaman A grubu geçerli
        
        if (availableGroups.length > 0) {
            // Tüm bileşenlerin gruplarını topla
            const allGroupsSet = new Set(['A']); // A grubu garantili
            
            availableGroups.forEach(componentId => {
                const component = APP_STATE.courseData.grupHaritalari[componentId];
                if (component && component.gruplar && Array.isArray(component.gruplar)) {
                    component.gruplar.forEach(group => {
                        if (group && typeof group === 'string' && group.length === 1) {
                            allGroupsSet.add(group);
                        }
                    });
                }
            });
            
            validGroups = Array.from(allGroupsSet).sort();
        }
        
        console.log(`📋 Geçerli gruplar:`, validGroups);
        
        // TÜM ÖĞRENCİLERİ KONTROL ET VE ATANMAMIŞ OLANLARI A GRUBUNA ATA
        APP_STATE.studentData.forEach((student, index) => {
            const studentInfo = `${student.name} ${student.surname} (${student.studentId})`;
            
            if (!student.grup || student.grup === '' || !validGroups.includes(student.grup)) {
                const oldGroup = student.grup || 'YOK';
                student.grup = 'A'; // Varsayılan grup A
                hasChanges = true;
                assignedToA++;
                
                console.log(`🔧 ${index + 1}. ${studentInfo}: ${oldGroup} → A`);
                
                // Bileşen bazlı grup atamalarını da güncelle
                if (!APP_STATE.studentComponentGroups) {
                    APP_STATE.studentComponentGroups = {};
                }
                if (!APP_STATE.studentComponentGroups[student.studentId]) {
                    APP_STATE.studentComponentGroups[student.studentId] = {};
                }
                
                // Her bileşen için A grubu ata
                availableGroups.forEach(componentId => {
                    APP_STATE.studentComponentGroups[student.studentId][componentId] = 'A';
                });
            } else {
                alreadyAssigned++;
                console.log(`✅ ${index + 1}. ${studentInfo}: Zaten ${student.grup} grubunda`);
            }
        });
        
        // DOĞRULAMA: Hiçbir öğrenci atanmamış kalmamalı
        const unassignedStudents = APP_STATE.studentData.filter(s => !s.grup || s.grup === '');
        if (unassignedStudents.length > 0) {
            console.error(`❌ HATA: ${unassignedStudents.length} öğrenci hala atanmamış!`);
            unassignedStudents.forEach(s => {
                console.error(`  - ${s.name} ${s.surname} (${s.studentId})`);
                s.grup = 'A'; // Güvenlik için A grubuna ata
            });
            hasChanges = true;
        }
        
        // RAPOR
        console.log(`\n📊 GRUP ATAMA RAPORU:`);
        console.log(`   ✅ Zaten atanmış: ${alreadyAssigned} öğrenci`);
        console.log(`   🔧 A grubuna atanan: ${assignedToA} öğrenci`);
        console.log(`   📋 Toplam: ${APP_STATE.studentData.length} öğrenci`);
        
        if (hasChanges) {
            // UI'ları güncelle
            updateStudentTable();
            updateGroupSelectors();
            updateAssessmentView();
            updateAllInlineGroupInputs();
            updateAllMappingDisplays();
            
            console.log(`✅ Grup atamaları tamamlandı, UI güncellemeleri yapıldı`);
            showModernToast(`${assignedToA} öğrenci A grubuna atandı. Tüm öğrenciler artık gruplarda.`, "success");
        } else {
            console.log(`✅ Tüm öğrenciler zaten uygun gruplarda, değişiklik gerekmedi`);
        }
        
    } catch (error) {
        console.error("❌ Default grup ataması yapılırken hata:", error);
        showModernToast("Grup ataması sırasında hata oluştu!", "error");
    }
}

/**
 * ÖÇ düzenleme modalını gösterme
 */
function showOutcomesEditModal(nodeId) {
    const node = findNodeById(nodeId);
    if (!node) {
        showModernToast("Düğüm bulunamadı!", "error");
        return;
    }
    
    // Modal elementlerini al
    const modal = document.getElementById('outcomesEditModal');
    const activityName = document.getElementById('outcomesActivityName');
    const outcomesTextarea = document.getElementById('outcomesTextarea');
    const outcomesList = document.getElementById('availableOutcomesList');
    
    if (!modal || !activityName || !outcomesTextarea || !outcomesList) {
        showModernToast("Modal elemanları bulunamadı!", "error");
        return;
    }
    
    // Modal başlığını güncelle
    activityName.textContent = `${node.id} - ${node.name}`;
    
    // Mevcut öğrenme çıktılarını textarea'ya yükle
    outcomesTextarea.value = (node.outcomes || []).join(', ');
    
    // Mevcut öğrenme çıktıları listesini oluştur
    renderAvailableOutcomes(outcomesList, node.outcomes || []);
    
    // Modal açma butonu event listener'larını kur
    setupOutcomesModalEvents(nodeId);
    
    // Modal'ı aç
    openModernModal('outcomesEditModal');
}

/**
 * Mevcut öğrenme çıktıları listesini render etme
 */
function renderAvailableOutcomes(container, selectedOutcomes = []) {
    container.innerHTML = '';
    
    // Tüm mevcut öğrenme çıktılarını bul (kod ve açıklama ile)
    const allOutcomes = new Map(); // kod -> {kod, açıklama}
    
    // Öncelikle APP_STATE.learningOutcomes'dan al (ana veri kaynağı)
    if (APP_STATE.learningOutcomes && APP_STATE.learningOutcomes.length > 0) {
        APP_STATE.learningOutcomes.forEach(outcome => {
            const outcomeCode = outcome.id || outcome.kod || outcome.kodu || outcome;
            const description = outcome.aciklama || outcome.açıklama || outcome.description || outcome.desc || '';
            
            allOutcomes.set(outcomeCode, { 
                kod: outcomeCode, 
                aciklama: description 
            });
        });
    } else {
        // Fallback: APP_STATE.courseData'dan öğrenme çıktılarını topla
        if (APP_STATE.courseData && APP_STATE.courseData.ogrenmeciktorilari) {
            APP_STATE.courseData.ogrenmeciktorilari.forEach(outcome => {
                const outcomeCode = outcome.kod || outcome.kodu || outcome.id || outcome;
                const description = outcome.aciklama || outcome.açıklama || outcome.description || outcome.desc || '';
                
                if (typeof outcome === 'string') {
                    // Eğer sadece string ise, kod olarak al
                    allOutcomes.set(outcome, { kod: outcome, aciklama: '' });
                } else {
                    // Object ise kod ve açıklamayı al
                    allOutcomes.set(outcomeCode, { kod: outcomeCode, aciklama: description });
                }
            });
        }
    }
    
    // Assessment tree'den öğrenme çıktılarını topla (sadece eksik olanlar için)
    function collectOutcomesFromTree(nodes) {
        nodes.forEach(node => {
            if (node.outcomes && Array.isArray(node.outcomes)) {
                node.outcomes.forEach(outcome => {
                    if (!allOutcomes.has(outcome)) {
                        // Tree'den gelen outcome'lar genelde sadece kod
                        allOutcomes.set(outcome, { kod: outcome, aciklama: '' });
                    }
                });
            }
            if (node.children) {
                collectOutcomesFromTree(node.children);
            }
        });
    }
    
    collectOutcomesFromTree(APP_STATE.assessmentTree);
    
    if (allOutcomes.size === 0) {
        container.innerHTML = '<div class="empty-outcomes-message">Henüz öğrenme çıktısı tanımlanmamış</div>';
        return;
    }
    
    // Öğrenme çıktılarını kod'a göre sırala
    const sortedOutcomes = Array.from(allOutcomes.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    
    // Badge'leri oluştur
    sortedOutcomes.forEach(([code, outcomeData]) => {
        const badge = document.createElement('div');
        badge.className = 'outcome-badge';
        badge.dataset.outcome = code;
        
        // Badge içeriğini oluştur
        const codeSpan = document.createElement('div');
        codeSpan.className = 'outcome-code';
        codeSpan.textContent = outcomeData.kod;
        
        const descSpan = document.createElement('div');
        descSpan.className = 'outcome-description';
        descSpan.textContent = outcomeData.aciklama || 'Açıklama yok';
        
        badge.appendChild(codeSpan);
        badge.appendChild(descSpan);
        
        // Eğer seçili ise işaretle
        if (selectedOutcomes.includes(code)) {
            badge.classList.add('selected');
        }
        
        // Click event listener
        badge.addEventListener('click', () => {
            badge.classList.toggle('selected');
            updateOutcomesTextarea();
        });
        
        container.appendChild(badge);
    });
}

/**
 * Seçili öğrenme çıktılarını textarea'ya yansıtma
 */
function updateOutcomesTextarea() {
    const selectedBadges = document.querySelectorAll('.outcome-badge.selected');
    const selectedOutcomes = Array.from(selectedBadges).map(badge => badge.dataset.outcome);
    const outcomesTextarea = document.getElementById('outcomesTextarea');
    
    if (outcomesTextarea) {
        outcomesTextarea.value = selectedOutcomes.join(', ');
    }
}

/**
 * ÖÇ modal event listener'larını kurma
 */
function setupOutcomesModalEvents(nodeId) {
    const selectAllBtn = document.getElementById('selectAllOutcomes');
    const clearAllBtn = document.getElementById('clearAllOutcomes');
    const randomSelectBtn = document.getElementById('randomSelectOutcomes');
    const saveBtn = document.getElementById('saveOutcomesBtn');
    const outcomesTextarea = document.getElementById('outcomesTextarea');
    
    // Önceki event listener'ları temizle
    const newSelectAllBtn = selectAllBtn.cloneNode(true);
    const newClearAllBtn = clearAllBtn.cloneNode(true);
    const newRandomSelectBtn = randomSelectBtn.cloneNode(true);
    const newSaveBtn = saveBtn.cloneNode(true);
    
    selectAllBtn.parentNode.replaceChild(newSelectAllBtn, selectAllBtn);
    clearAllBtn.parentNode.replaceChild(newClearAllBtn, clearAllBtn);
    randomSelectBtn.parentNode.replaceChild(newRandomSelectBtn, randomSelectBtn);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    
    // Tümünü seç
    newSelectAllBtn.addEventListener('click', () => {
        document.querySelectorAll('.outcome-badge').forEach(badge => {
            badge.classList.add('selected');
        });
        updateOutcomesTextarea();
    });
    
    // Temizle
    newClearAllBtn.addEventListener('click', () => {
        document.querySelectorAll('.outcome-badge').forEach(badge => {
            badge.classList.remove('selected');
        });
        updateOutcomesTextarea();
    });
    
    // Rastgele seç (2-3 tane)
    newRandomSelectBtn.addEventListener('click', () => {
        // Önce tümünü temizle
        document.querySelectorAll('.outcome-badge').forEach(badge => {
            badge.classList.remove('selected');
        });
        
        const allBadges = Array.from(document.querySelectorAll('.outcome-badge'));
        const randomCount = Math.floor(Math.random() * 2) + 2; // 2-3 tane
        const selectedIndices = [];
        
        while (selectedIndices.length < Math.min(randomCount, allBadges.length)) {
            const randomIndex = Math.floor(Math.random() * allBadges.length);
            if (!selectedIndices.includes(randomIndex)) {
                selectedIndices.push(randomIndex);
                allBadges[randomIndex].classList.add('selected');
            }
        }
        
        updateOutcomesTextarea();
    });
    
    // Textarea değişikliklerini badge'lere yansıt
    outcomesTextarea.addEventListener('input', () => {
        const textValue = outcomesTextarea.value;
        const outcomes = textValue.split(',').map(o => o.trim()).filter(o => o.length > 0);
        
        // Tüm badge'leri temizle
        document.querySelectorAll('.outcome-badge').forEach(badge => {
            badge.classList.remove('selected');
        });
        
        // Matching badge'leri seç
        outcomes.forEach(outcome => {
            const badge = document.querySelector(`.outcome-badge[data-outcome="${outcome}"]`);
            if (badge) {
                badge.classList.add('selected');
            }
        });
    });
    
    // Kaydet
    newSaveBtn.addEventListener('click', () => {
        const textValue = outcomesTextarea.value;
        const outcomes = textValue.split(',').map(o => o.trim()).filter(o => o.length > 0);
        
        const node = findNodeById(nodeId);
        if (node) {
            node.outcomes = outcomes;
            
            // Ana ekrandaki textarea'yı güncelle
            const nodeTextarea = document.querySelector(`.tree-node[data-id="${nodeId}"] .nodeOutcomes`);
            if (nodeTextarea) {
                nodeTextarea.value = outcomes.join(',');
            }
            
            // Değerlendirme görünümünü güncelle
            updateAssessmentView();
            
            showModernToast("Öğrenme çıktıları başarıyla güncellendi!", "success");
            closeModernModal('outcomesEditModal');
        }
    });
}

// =====================================================
// COLLAPSE/EXPAND FONKSİYONLARI
// =====================================================

/**
 * Bölümü collapse/expand yapma
 * @param {string} sectionId - Bölüm ID'si
 */
function toggleCollapse(sectionId) {
    const collapseElement = document.getElementById(sectionId + 'Collapse');
    const header = collapseElement.parentElement.querySelector('.collapsible-header');
    
    if (collapseElement.classList.contains('collapsed')) {
        // Expand - dinamik yükseklik hesapla
        collapseElement.style.maxHeight = 'none'; // Önce sınırsız yaparak ölç
        const fullHeight = collapseElement.scrollHeight;
        collapseElement.style.maxHeight = '0px'; // Sonra sıfıra döndür
        
        // Animasyon için kısa bir gecikme sonra gerçek yüksekliği ver
        setTimeout(() => {
            collapseElement.style.maxHeight = fullHeight + 'px';
            collapseElement.classList.remove('collapsed');
            header.classList.remove('collapsed');
        }, 10);
    } else {
        // Collapse
        collapseElement.style.maxHeight = '0px';
        collapseElement.classList.add('collapsed');
        header.classList.add('collapsed');
    }
}

/**
 * Tüm bölümleri expand yapma
 */
function expandAllSections() {
    const collapsibleSections = document.querySelectorAll('.collapsible-content');
    const headers = document.querySelectorAll('.collapsible-header');
    
    collapsibleSections.forEach(section => {
        // Dinamik yükseklik hesapla
        section.style.maxHeight = 'none';
        const fullHeight = section.scrollHeight;
        section.style.maxHeight = fullHeight + 'px';
        section.classList.remove('collapsed');
    });
    
    headers.forEach(header => {
        header.classList.remove('collapsed');
    });
}

/**
 * Tüm bölümleri collapse yapma
 */
function collapseAllSections() {
    const collapsibleSections = document.querySelectorAll('.collapsible-content');
    const headers = document.querySelectorAll('.collapsible-header');
    
    collapsibleSections.forEach(section => {
        section.style.maxHeight = '0px';
        section.classList.add('collapsed');
    });
    
    headers.forEach(header => {
        header.classList.add('collapsed');
    });
}

// Mevcut fonksiyonları global hale getir
window.updateStudentGroup = updateStudentGroup;
window.showGroupMappingModal = showGroupMappingModal;
window.removeMappingRow = removeMappingRow;
window.applyBulkMapping = applyBulkMapping;
window.applyInlineGroupMapping = applyInlineGroupMapping;
window.showOutcomesEditModal = showOutcomesEditModal;
/**
 * Sayfa yüklendiğinde doğru yükseklikleri ayarlama
 */
function initializeCollapsibleSections() {
    const collapsibleSections = document.querySelectorAll('.collapsible-content:not(.collapsed)');
    
    collapsibleSections.forEach(section => {
        // Açık olan bölümlerin doğru yüksekliğini ayarla
        const fullHeight = section.scrollHeight;
        section.style.maxHeight = fullHeight + 'px';
    });
}

// Sayfa yüklendiğinde ve içerik değiştiğinde çalıştır
document.addEventListener('DOMContentLoaded', initializeCollapsibleSections);

// ResizeObserver ile içerik değişikliklerini izle
if (window.ResizeObserver) {
    const resizeObserver = new ResizeObserver(() => {
        // Açık olan bölümlerin yüksekliğini yeniden hesapla
        const openSections = document.querySelectorAll('.collapsible-content:not(.collapsed)');
        openSections.forEach(section => {
            const fullHeight = section.scrollHeight;
            section.style.maxHeight = fullHeight + 'px';
        });
    });

    // Tüm collapsible section'ları izle
    setTimeout(() => {
        document.querySelectorAll('.collapsible-content').forEach(section => {
            resizeObserver.observe(section);
        });
    }, 100);
}

window.toggleCollapse = toggleCollapse;
window.expandAllSections = expandAllSections;
window.collapseAllSections = collapseAllSections;
window.initializeCollapsibleSections = initializeCollapsibleSections;

// ============================================================================
// SİSTEM TEST İŞLEMLERİ
// ============================================================================

/**
 * Rastgele değerlendirme bileşeni ekleme
 */
function generateRandomAssessment() {
    try {
        console.log('🎲 Rastgele değerlendirme oluşturuluyor...');
        
        // Yarıyıl içi mi yarıyıl sonu mu belirle (gerçekçi dağılım)
        const isTermActivity = Math.random() > 0.25; // %75 yarıyıl içi, %25 yarıyıl sonu
        
        // Gerçekçi değerlendirme türleri
        const realisticTypes = {
            term: [
                { name: 'Ara Sınav', weight: [25, 35], points: 100, hasSubItems: true, subTypes: ['Soru', 'Test'] },
                { name: 'Quiz', weight: [5, 15], points: 100, hasSubItems: false },
                { name: 'Ev Ödevi', weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Soru', 'Rubrik'] },
                { name: 'Laboratuvar', weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik', 'Soru'] },
                { name: 'Proje', weight: [20, 30], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
                { name: 'Sunum', weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
                { name: 'Rapor', weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik'] }
            ],
            final: [
                { name: 'Final Sınavı', weight: [80, 100], points: 100, hasSubItems: true, subTypes: ['Soru', 'Test'] },
                { name: 'Bütünleme Sınavı', weight: [80, 100], points: 100, hasSubItems: true, subTypes: ['Soru', 'Test'] },
                { name: 'Final Projesi', weight: [70, 90], points: 100, hasSubItems: true, subTypes: ['Rubrik'] }
            ]
        };
        
        const availableTypes = isTermActivity ? realisticTypes.term : realisticTypes.final;
        const randomTypeInfo = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        
        // Mevcut aktiviteleri say ve doğru ID formatını oluştur
        const existingActivities = APP_STATE.assessmentTree.filter(node => 
            isTermActivity ? node.id.startsWith('A') : node.id.startsWith('F')
        );
        const nextNumber = existingActivities.length + 1;
        const newId = isTermActivity ? `A${nextNumber}` : `F${nextNumber}`;
        
        // Mevcut öğrenme çıktılarını kullan (varsa)
        let selectedOutcomes = [];
        if (APP_STATE.learningOutcomes && APP_STATE.learningOutcomes.length > 0) {
            const numOutcomes = Math.floor(Math.random() * 3) + 1; // 1-3 arası
            const shuffledOutcomes = [...APP_STATE.learningOutcomes].sort(() => Math.random() - 0.5);
            selectedOutcomes = shuffledOutcomes.slice(0, numOutcomes).map(outcome => outcome.id);
        } else {
            // Varsayılan öğrenme çıktıları (gerçekçi)
            const defaultOutcomes = ['ÖÇ.1', 'ÖÇ.2', 'ÖÇ.3', 'ÖÇ.4', 'ÖÇ.5', 'ÖÇ.6'];
            const numOutcomes = Math.floor(Math.random() * 3) + 2; // 2-4 arası
            const shuffledOutcomes = [...defaultOutcomes].sort(() => Math.random() - 0.5);
            selectedOutcomes = shuffledOutcomes.slice(0, numOutcomes);
        }
        
        // Gerçekçi ağırlık ve puan hesaplama
        const weightRange = randomTypeInfo.weight;
        const weight = Math.floor(Math.random() * (weightRange[1] - weightRange[0] + 1)) + weightRange[0];
        
        let points;
        if (Array.isArray(randomTypeInfo.points)) {
            points = Math.floor(Math.random() * (randomTypeInfo.points[1] - randomTypeInfo.points[0] + 1)) + randomTypeInfo.points[0];
        } else {
            points = randomTypeInfo.points;
        }
        
        console.log(`  📋 ${randomTypeInfo.name} oluşturuluyor - Ağırlık: ${weight}%, Puan: ${points}`);
        
        // Yeni aktivite oluştur - mevcut sistem formatında
        const newActivity = {
            id: newId,
            name: randomTypeInfo.name,
            type: randomTypeInfo.name,
            weight: weight,
            points: points,
            outcomes: selectedOutcomes,
            description: isTermActivity ? 
                `Yarıyıl içi ${randomTypeInfo.name.toLowerCase()} değerlendirmesi` : 
                `Yarıyıl sonu ${randomTypeInfo.name.toLowerCase()} değerlendirmesi`,
            expanded: true,
            children: []
        };
        
        // Alt bileşenler ekle (gerçekçi yaklaşım)
        if (randomTypeInfo.hasSubItems) {
            let numSubItems;
            let subTypes = randomTypeInfo.subTypes;
            
            // Değerlendirme türüne göre alt bileşen sayısı
            if (randomTypeInfo.name.includes('Sınav')) {
                numSubItems = Math.floor(Math.random() * 4) + 3; // 3-6 soru/test
            } else if (randomTypeInfo.name === 'Quiz') {
                numSubItems = Math.floor(Math.random() * 3) + 2; // 2-4 soru
            } else if (randomTypeInfo.name.includes('Proje')) {
                numSubItems = Math.floor(Math.random() * 3) + 2; // 2-4 rubrik
            } else {
                numSubItems = Math.floor(Math.random() * 3) + 2; // 2-4 bileşen
            }
            
            console.log(`    🔹 ${numSubItems} alt bileşen ekleniyor...`);
            
            for (let i = 0; i < numSubItems; i++) {
                // Alt bileşen türünü gerçekçi şekilde seç
                const subType = subTypes[Math.floor(Math.random() * subTypes.length)];
                
                // Gerçekçi alt bileşen isimleri
                let subName;
                if (subType === 'Soru') {
                    const questionTypes = ['Çoktan Seçmeli', 'Açık Uçlu', 'Kısa Cevaplı', 'Problem', 'Analiz'];
                    subName = `${questionTypes[Math.floor(Math.random() * questionTypes.length)]} Soru ${i + 1}`;
                } else if (subType === 'Test') {
                    subName = `Test Bölümü ${i + 1}`;
                } else if (subType === 'Rubrik') {
                    const rubricTypes = ['Değerlendirme', 'Analiz', 'Sunum', 'Rapor', 'Kod Kalitesi'];
                    subName = `${rubricTypes[Math.floor(Math.random() * rubricTypes.length)]} Rubriği`;
                } else {
                    subName = `${subType} ${i + 1}`;
                }
                
                const subItem = {
                    id: `${newId}.${i + 1}`,
                    name: subName,
                    type: subType,
                    weight: Math.floor(100 / numSubItems), // Eşit ağırlık dağılımı
                    points: Math.floor(points / numSubItems),
                    outcomes: selectedOutcomes.length > 0 ? 
                        [selectedOutcomes[Math.floor(Math.random() * selectedOutcomes.length)]] : [],
                    description: `${subName} için değerlendirme kriteri`,
                    expanded: false,
                    children: []
                };
                
                // Test için gerçekçi detaylar ekle
                if (subType === 'Test') {
                    const questionCount = Math.floor(Math.random() * 20) + 10; // 10-30 soru
                    subItem.testDetails = {
                        totalQuestions: questionCount,
                        correctWeight: Math.floor(Math.random() * 3) + 3, // 3-5 puan
                        wrongPenalty: -(Math.floor(Math.random() * 2) + 1) // -1 veya -2 puan
                    };
                    console.log(`      🧪 Test: ${questionCount} soru, +${subItem.testDetails.correctWeight}/${subItem.testDetails.wrongPenalty} puan`);
                }
                
                newActivity.children.push(subItem);
                console.log(`      ✅ ${subName} (${subItem.points} puan)`);
            }
            
            // Alt bileşenlerin ağırlıklarını normalize et
            const totalWeight = newActivity.children.reduce((sum, child) => sum + child.weight, 0);
            if (totalWeight !== 100) {
                newActivity.children.forEach(child => {
                    child.weight = Math.round((child.weight / totalWeight) * 100);
                });
            }
        }
        
        // Assessment tree'ye doğru sırada ekle
        if (isTermActivity) {
            // Yarıyıl içi etkinlikleri başa ekle
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            termActivities.push(newActivity);
            APP_STATE.assessmentTree = [...termActivities, ...finalActivities];
        } else {
            // Yarıyıl sonu etkinlikleri sona ekle
            APP_STATE.assessmentTree.push(newActivity);
        }
        
        // Seçili düğümü yeni aktivite yap
        selectNode(newActivity);
        
        // Yeni eklenen soruları tüm gruplara farklı sıralarda ata
        if (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari) {
            const activeGroups = Object.keys(APP_STATE.courseData.grupHaritalari);
            if (activeGroups.length > 0 && newActivity.children && newActivity.children.length > 0) {
                // Yeni aktivitedeki soruları topla
                const newQuestions = newActivity.children.filter(child => child.type === 'Soru');
                
                if (newQuestions.length > 0) {
                    // Her grup için tüm soruları farklı sıralarda ata
                    activeGroups.forEach((groupName, groupIndex) => {
                        console.log(`\nYeni sorular Grup ${groupName} için sıralanıyor:`);
                        
                        // Yeni soruları kopyala ve karıştır
                        const shuffledQuestions = [...newQuestions];
                        
                        // Her grup için farklı karıştırma
                        for (let i = 0; i < groupIndex + 1; i++) {
                            for (let j = shuffledQuestions.length - 1; j > 0; j--) {
                                const k = Math.floor(Math.random() * (j + 1));
                                [shuffledQuestions[j], shuffledQuestions[k]] = [shuffledQuestions[k], shuffledQuestions[j]];
                            }
                        }
                        
                        // Grup haritasını güncelle
                        if (!APP_STATE.courseData.grupHaritalari[groupName][newId]) {
                            APP_STATE.courseData.grupHaritalari[groupName][newId] = [];
                        }
                        
                        // Tüm yeni soruları bu gruba ata (karıştırılmış sırada)
                        shuffledQuestions.forEach((question, index) => {
                            APP_STATE.courseData.grupHaritalari[groupName][newId].push(question.id);
                            console.log(`  ${index + 1}. ${question.name} (${question.id})`);
                        });
                    });
                }
            }
        }
        
        // UI'ları güncelle
        renderTree();
        updateAssessmentView();
        updateCategoryWeights();
        updateTreeMappingControls();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        
        // Öğrenci grup bilgilerini güncelle
        updateStudentGroupInfoDisplay();
        
        console.log('✅ Rastgele değerlendirme başarıyla eklendi:', newActivity);
        showModernToast(`📝 ${randomTypeInfo.name} değerlendirmesi eklendi! (${newId})`, "success");
        
    } catch (error) {
        console.error("❌ Rastgele değerlendirme oluşturulurken hata:", error);
        showModernToast("Rastgele değerlendirme oluşturulamadı!", "error");
    }
}

/**
 * 🧹 Değerlendirmeleri Temizle
 */
function clearAssessments() {
    console.log("🔍 clearAssessments fonksiyonu çağrıldı");
    try {
        // Önce silinecek veri var mı kontrol et
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            console.log("ℹ️ Silinecek değerlendirme bileşeni bulunmuyor");
            showModernToast("ℹ️ Silinecek değerlendirme bileşeni bulunmuyor.", "info");
            return;
        }
        
        console.log("📋 showModernConfirm çağrılıyor...");
        showModernConfirm(
            "Değerlendirme Bileşenlerini Sil",
            "Tüm değerlendirme bileşenleri silinecek. Bu işlem geri alınamaz. Emin misiniz?",
            function() {
                console.log("✅ Onay verildi, performClearAssessments çağrılıyor");
                // Onay verildiğinde çalışacak kod
                performClearAssessments();
            }
        );
    } catch (error) {
        console.error("❌ Değerlendirmeler temizlenirken hata:", error);
        showModernToast("Değerlendirmeler temizlenemedi!", "error");
    }
}

function performClearAssessments() {
    try {
        console.log("🔧 performClearAssessments başlatıldı");
        
        // 1. Değerlendirme ağacını temizle
        APP_STATE.assessmentTree = [];
        APP_STATE.selectedNode = null;
        
        // 2. İLGİLİ PUANLARI DA TEMİZLE (Bağımlılık çözümü)
        console.log("🔗 Değerlendirmelerle ilgili puanlar da temizleniyor...");
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        
        // 3. Grup haritalamalarını temizle (değerlendirme yok ise grup da anlamsız)
        if (APP_STATE.courseData) {
            APP_STATE.courseData.grupHaritalari = {};
        }
        
        // 4. UI'ları güncelle
        renderTree();
        updateAssessmentView();
        updateCategoryWeights();
        
        // 5. Güvenli UI güncellemeleri
        if (typeof updateTreeMappingControls === 'function') {
        updateTreeMappingControls();
        }
        if (typeof updateAllInlineGroupInputs === 'function') {
        updateAllInlineGroupInputs();
        }
        
        // 6. Not tablolarını temizle
        const gradesTableContainer = document.getElementById('gradesTableContainer');
        if (gradesTableContainer) {
            gradesTableContainer.innerHTML = '<p class="empty-message">Henüz not hesaplanmadı.</p>';
        }
        
        // 7. Öğrenci grup bilgilerini güncelle
        updateStudentGroupInfoDisplay();
        
        showModernToast("🗑️ Tüm değerlendirme bileşenleri ve ilgili puanlar temizlendi!", "success");
        
    } catch (error) {
        console.error("❌ Değerlendirmeler temizlenirken hata:", error);
        showModernToast("Değerlendirmeler temizlenemedi!", "error");
    }
}

/**
 * 🧹 Grupları Temizle
 */
function clearGroups() {
    try {
        // Önce silinecek veri var mı kontrol et
        if (!APP_STATE.courseData || !APP_STATE.courseData.grupHaritalari || Object.keys(APP_STATE.courseData.grupHaritalari).length === 0) {
            showModernToast("ℹ️ Silinecek grup verisi bulunmuyor.", "info");
            return;
        }
        
        showModernConfirm(
            "Grup Verilerini Sil",
            "Tüm grup haritalama verileri silinecek. Bu işlem geri alınamaz. Emin misiniz?",
            function() {
                // Onay verildiğinde çalışacak kod
                performClearGroups();
            }
        );
    } catch (error) {
        console.error("Gruplar temizlenirken hata:", error);
        showModernToast("Gruplar temizlenemedi!", "error");
    }
}

function performClearGroups() {
    try {
        console.log("🔧 performClearGroups başlatıldı");
        
        // 1. Grup haritalamalarını temizle
        if (APP_STATE.courseData) {
            APP_STATE.courseData.grupHaritalari = {};
        }
        
        // 2. Öğrencilerin gruplarını varsayılan gruba ata
        if (APP_STATE.studentData) {
            APP_STATE.studentData.forEach(student => {
                student.grup = 'A';
            });
        }
        
        // 3. GRUP DEĞİŞİKLİĞİ PUANLARI ETKİLEYEBİLİR - Uyarı ver
        const hasGrades = (APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0) ||
                         (APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0);
        
        if (hasGrades) {
            console.log("⚠️ Grup değişikliği mevcut puanları etkileyebilir");
            showModernToast("⚠️ Grup haritalama temizlendi. Mevcut puanlar grup değişikliğinden etkilenebilir!", "warning", 6000);
        }
        
        // 4. UI'ları güvenli şekilde güncelle
        if (typeof updateGroupSelectors === 'function') {
        updateGroupSelectors();
        }
        updateStudentTable();
        if (typeof updateTreeMappingControls === 'function') {
        updateTreeMappingControls();
        }
        if (typeof updateAllInlineGroupInputs === 'function') {
        updateAllInlineGroupInputs();
        }
        if (typeof updateAllMappingDisplays === 'function') {
        updateAllMappingDisplays();
        }
        updateAssessmentView();
        
        showModernToast("🗑️ Tüm grup haritalama verileri temizlendi!", "success");
        
    } catch (error) {
        console.error("❌ Gruplar temizlenirken hata:", error);
        showModernToast("Gruplar temizlenemedi!", "error");
    }
}

/**
 * 🧹 Puanları Temizle
 */
function clearScores() {
    try {
        // Önce silinecek veri var mı kontrol et
        const hasGrades = APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0;
        const hasTestScores = APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0;
        
        if (!hasGrades && !hasTestScores) {
            showModernToast("ℹ️ Silinecek puan verisi bulunmuyor.", "info");
            return;
        }
        
        showModernConfirm(
            "Öğrenci Puanlarını Sil",
            "Tüm öğrenci puanları silinecek. Bu işlem geri alınamaz. Emin misiniz?",
            function() {
                // Onay verildiğinde çalışacak kod
                performClearScores();
            }
        );
    } catch (error) {
        console.error("Puanlar temizlenirken hata:", error);
        showModernToast("Puanlar temizlenemedi!", "error");
    }
}

function performClearScores() {
    try {
        console.log("🔧 performClearScores başlatıldı");
        
        // 1. Puanları temizle
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        
        // 2. UI'ları GÜVENLİ ŞEKİLDE güncelle
        updateAssessmentView();
        
        // 3. Öğrenci bazlı not girişi sekmesini temizle
        const studentGradesContainer = document.getElementById('studentGradesContainer');
        if (studentGradesContainer) {
            studentGradesContainer.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
        }
        
        // 4. Not tablosunu GÜVENLİ ŞEKİLDE temizle
        const gradesTableContainer = document.getElementById('gradesTableContainer');
        if (gradesTableContainer) {
            gradesTableContainer.innerHTML = '<p class="empty-message">Henüz not hesaplanmadı.</p>';
        }
        
        // 5. Not tablosunu güvenli güncelleme
        try {
            // Boş final grades ile tabloyu güncelle
            updateGradesTable([]);
        } catch (tableError) {
            console.warn("⚠️ Not tablosu güncellenirken hata (görmezden gelindi):", tableError);
            // Hata olursa manuel temizle
            const gradesTable = document.getElementById('gradesTable');
            if (gradesTable) {
                const tbody = gradesTable.querySelector('tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="8" class="empty-message">Not girişi yapılmadı</td></tr>';
                }
            }
        }
        
        showModernToast("🗑️ Tüm öğrenci puanları temizlendi!", "success");
        
    } catch (error) {
        console.error("❌ Puanlar temizlenirken hata:", error);
        showModernToast("Puanlar temizlenemedi!", "error");
    }
}

/**
 * 🧹 Öğrencileri Temizle
 */
function clearStudentsOnly() {
    try {
        showModernConfirm(
            "Öğrenci Listesini Sil",
            "Tüm öğrenci listesi silinecek. Bu işlem geri alınamaz. Emin misiniz?",
            function() {
                // Onay verildiğinde çalışacak kod
                performClearStudentsOnly();
            }
        );
    } catch (error) {
        console.error("Öğrenciler temizlenirken hata:", error);
        showModernToast("Öğrenciler temizlenemedi!", "error");
    }
}

function performClearStudentsOnly() {
    try {
        
        APP_STATE.studentData = [];
        APP_STATE.selectedStudentId = null;
        
        // Öğrenci verilerine bağlı puanları da temizle
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        
        // UI'ları güncelle
        updateStudentTable();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        updateAssessmentView();
        
        // Öğrenci bazlı not girişi sekmesini temizle
        const studentGradesContainer = document.getElementById('studentGradesContainer');
        if (studentGradesContainer) {
            studentGradesContainer.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
        }
        
        showModernToast("🗑️ Tüm öğrenci listesi temizlendi!", "success");
        
    } catch (error) {
        console.error("Öğrenciler temizlenirken hata:", error);
        showModernToast("Öğrenciler temizlenemedi!", "error");
    }
}

/**
 * 🔄 Sistemi Resetle
 */
function resetSystem() {
    try {
        showModernConfirm(
            "⚠️ SİSTEMİ TAMAMEN RESETLE",
            "TÜM VERİLER SİLİNECEK! Bu işlem geri alınamaz. Sistem tamamen sıfırlanacak. Devam etmek istediğinizden emin misiniz?",
            function() {
                // Onay verildiğinde çalışacak kod
                performResetSystem();
            }
        );
    } catch (error) {
        console.error("Sistem resetlenirken hata:", error);
        showModernToast("Sistem resetlenemedi!", "error");
    }
}

function performResetSystem() {
    try {
        
        // Tüm verileri sıfırla
        APP_STATE.studentData = [];
        APP_STATE.assessmentTree = [];
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        APP_STATE.courseData = {
            grupHaritalari: {}
        };
        APP_STATE.selectedNode = null;
        APP_STATE.selectedStudentId = null;
        APP_STATE.learningOutcomes = [];
        APP_STATE.programOutcomes = [];
        
        // UI'ları tamamen yenile
        updateStudentTable();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        renderTree();
        updateGroupSelectors();
        updateAssessmentView();
        updateCategoryWeights();
        updateTreeMappingControls();
        updateAllInlineGroupInputs();
        updateAllMappingDisplays();
        
        // Tüm containers'ı temizle
        const containers = [
            'studentGradesContainer',
            'assessmentContainer',
            'gradesTableContainer',
            'courseDetailsContainer',
            'outcomesContainer',
            'programOutcomesContainer',
            'outcomeMatrixContainer'
        ];
        
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) {
                if (containerId === 'courseDetailsContainer') {
                    container.innerHTML = '<div class="details-empty-message">Ders detayları için JSON yükleyin.</div>';
                } else if (containerId === 'outcomesContainer') {
                    container.innerHTML = '<div class="outcomes-empty-message">Henüz öğrenme çıktısı eklenmedi.</div>';
                } else if (containerId === 'programOutcomesContainer') {
                    container.innerHTML = '<div class="outcomes-empty-message">Henüz program çıktısı eklenmedi.</div>';
                } else if (containerId === 'outcomeMatrixContainer') {
                    container.innerHTML = '<div class="matrix-empty-message">Henüz ilişki matrisi oluşturulmadı.</div>';
                } else {
                    container.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
                }
            }
        });
        
        // Tree container'ı özel mesajla
        const treeContainer = document.getElementById('treeContainer');
        if (treeContainer) {
            treeContainer.innerHTML = '<div class="tree-empty-message">Henüz değerlendirme bileşeni eklenmedi. Ders JSON yükleyin veya yeni bileşenler ekleyin.</div>';
        }
        
        showModernToast("🔄 Sistem tamamen sıfırlandı! Temiz bir başlangıç yapabilirsiniz.", "success", 5000);
        
    } catch (error) {
        console.error("Sistem resetlenirken hata:", error);
        showModernToast("Sistem resetlenemedi!", "error");
    }
}

/**
 * Rastgele gruplar oluşturma ve soru-grup eşleştirmesi
 */
/**
 * Rastgele grup oluşturma (Onay ile)
 */
function generateRandomGroups() {
    console.log('🚀 generateRandomGroups() fonksiyonu başlatıldı');
    console.log('📊 DEBUG: APP_STATE kontrolü yapılıyor...');
    
    // Mevcut grup verilerini kontrol et
    const hasExistingGroups = APP_STATE.courseData && APP_STATE.courseData.grupHaritalari && 
        Object.keys(APP_STATE.courseData.grupHaritalari).length > 0;
    const hasExistingAssessments = APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0;
    const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
    
    console.log('📊 DEBUG: Durum Kontrolü:');
    console.log('  - APP_STATE.courseData:', !!APP_STATE.courseData);
    console.log('  - APP_STATE.courseData.grupHaritalari:', !!APP_STATE.courseData?.grupHaritalari);
    console.log('  - hasExistingGroups:', hasExistingGroups);
    console.log('  - APP_STATE.assessmentTree length:', APP_STATE.assessmentTree?.length || 0);
    console.log('  - hasExistingAssessments:', hasExistingAssessments);
    console.log('  - APP_STATE.studentData length:', APP_STATE.studentData?.length || 0);
    console.log('  - studentCount:', studentCount);
    
    const minSlider = document.getElementById('groupMinSlider');
    const maxSlider = document.getElementById('groupMaxSlider');
    const minGroups = minSlider ? parseInt(minSlider.value) : 1;
    const maxGroups = maxSlider ? parseInt(maxSlider.value) : 2;
    
    console.log('🎚️ DEBUG: Slider Değerleri:');
    console.log('  - minSlider element:', !!minSlider);
    console.log('  - maxSlider element:', !!maxSlider);
    console.log('  - minGroups:', minGroups);
    console.log('  - maxGroups:', maxGroups);
    
    let warningMessage = '';
    
    if (!hasExistingAssessments) {
        console.log('❌ DEBUG: Değerlendirme bileşeni bulunamadı!');
        console.log('   - APP_STATE.assessmentTree:', APP_STATE.assessmentTree);
        warningMessage = 'Henüz değerlendirme bileşeni bulunmuyor. Önce yarıyıl içi veya yarıyıl sonu etkinlikleri oluşturun.';
        showModernToast(warningMessage, 'warning');
        return;
    }
    
    if (studentCount === 0) {
        warningMessage = `${minGroups}-${maxGroups} arasında rastgele grup oluşturulacak (öğrenci verisi yok, sadece yapı oluşturulacak).\n\nDevam etmek istediğinizden emin misiniz?`;
    } else if (hasExistingGroups) {
        const existingGroupCount = Object.keys(APP_STATE.courseData.grupHaritalari).length;
        warningMessage = `Mevcut ${existingGroupCount} değerlendirme bileşeninin grup haritaları değişecek. ${studentCount} öğrenci için ${minGroups}-${maxGroups} arasında yeni grup düzeni oluşturulacak.\n\nMevcut grup haritalama verileri kaybolacak. Devam etmek istediğinizden emin misiniz?`;
    } else {
        warningMessage = `${studentCount} öğrenci için ${minGroups}-${maxGroups} arasında rastgele grup oluşturulacak.\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    }
    
    showModernConfirm(
        '🎲 Rastgele Öğrenci Grupları Oluştur',
        warningMessage,
        {
            confirmText: 'Evet, Oluştur',
            cancelText: 'İptal',
            confirmClass: 'btn-modern-primary',
            cancelClass: 'btn-modern-secondary',
            headerClass: 'warning-action',
            iconClass: 'warning'
        }
    ).then((result) => {
        console.log('🔍 Modal sonucu:', result);
        if (result) {
            console.log('✅ Kullanıcı onayladı, executeGenerateRandomGroups çağrılıyor...');
            executeGenerateRandomGroups();
        } else {
            console.log('❌ Kullanıcı iptal etti');
        }
    });
}

/**
 * Rastgele grup oluşturma (Gerçek işlem)
 */
function executeGenerateRandomGroups() {
    console.log('🎯 executeGenerateRandomGroups() fonksiyonu başlatıldı');
    console.log('📊 DEBUG: Ana işlem başlıyor, tüm kontroller yapılacak...');
    
    try {
        // Dual range slider'dan min ve max grup sayılarını al
        const minSlider = document.getElementById('groupMinSlider');
        const maxSlider = document.getElementById('groupMaxSlider');
        let minGroups = minSlider ? parseInt(minSlider.value) : 1;
        let maxGroups = maxSlider ? parseInt(maxSlider.value) : 2;
        
        console.log('🎚️ DEBUG: executeGenerateRandomGroups - Slider Değerleri:');
        console.log('  - minSlider element:', !!minSlider, minSlider?.value);
        console.log('  - maxSlider element:', !!maxSlider, maxSlider?.value);
        console.log('  - minGroups (parsed):', minGroups);
        console.log('  - maxGroups (parsed):', maxGroups);
        
        // Öğrenci sayısını kontrol et
        const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
        
        console.log('👥 DEBUG: Öğrenci Verileri:');
        console.log('  - APP_STATE.studentData:', !!APP_STATE.studentData);
        console.log('  - studentCount:', studentCount);
        if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
            console.log('  - İlk öğrenci örneği:', APP_STATE.studentData[0]);
        }
        
        // UYARI: Öğrenci sayısından fazla grup oluşturma kontrolü
        if (minGroups > studentCount && studentCount > 0) {
            showModernToast(`⚠️ Uyarı: Minimum grup sayısı (${minGroups}) öğrenci sayısından (${studentCount}) fazla! Maksimum ${studentCount} grup oluşturulabilir.`, "warning");
            return;
        }
        
        if (maxGroups > studentCount && studentCount > 0) {
            showModernToast(`⚠️ Uyarı: Maksimum grup sayısı (${maxGroups}) öğrenci sayısından (${studentCount}) fazla! En fazla ${studentCount} grup oluşturulabilir.`, "warning");
            // Maksimum grup sayısını öğrenci sayısı ile sınırla
            maxGroups = Math.min(maxGroups, studentCount);
            maxSlider.value = maxGroups;
            document.getElementById('groupMaxValue').textContent = maxGroups;
        }
        
        // Aralıktan rastgele bir grup sayısı seç (öğrenci sayısı ile sınırlı)
        const effectiveMaxGroups = Math.min(maxGroups, studentCount || 20); // Öğrenci yoksa 20 ile sınırla
        const requestedGroupCount = Math.floor(Math.random() * (effectiveMaxGroups - minGroups + 1)) + minGroups;
        
        const groupNames = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'];
        
        // Mevcut grup haritalarını temizle ama her zaman A grubu olacak
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = {};
        }
        APP_STATE.courseData.grupHaritalari = {};
        
        console.log('🔍 DEBUG: Ana değerlendirme bileşenlerini bulma işlemi başlatıldı');
        console.log('  - APP_STATE.assessmentTree:', APP_STATE.assessmentTree);
        console.log('  - assessmentTree length:', APP_STATE.assessmentTree?.length || 0);
        
        // Ana değerlendirme bileşenlerini bul (A1, A2, F1 vb.)
        const mainComponents = APP_STATE.assessmentTree.filter(node => 
            node.id.startsWith('A') || node.id.startsWith('F')
        );
        
        console.log('🔍 DEBUG: Ana bileşen filtreleme sonucu:');
        console.log('  - mainComponents length:', mainComponents.length);
        console.log('  - mainComponents:', mainComponents);
        if (mainComponents.length > 0) {
            mainComponents.forEach((comp, index) => {
                console.log(`    ${index + 1}. ${comp.id} - ${comp.name} (${comp.type})`);
                console.log(`       children length: ${comp.children?.length || 0}`);
            });
        }
        
        if (mainComponents.length === 0) {
            console.log('❌ DEBUG: Ana bileşen bulunamadı!');
            showModernToast("Önce değerlendirme bileşenleri oluşturun!", "warning");
            return;
        }
        
        console.log(`📊 DEBUG: Ana bileşenler:`, mainComponents.map(c => c.id));
        console.log(`👥 DEBUG: Öğrenci sayısı: ${studentCount}`);
        const rangeText = minGroups === maxGroups ? `${minGroups}` : `${minGroups}-${effectiveMaxGroups}`;
        console.log(`🎯 DEBUG: Grup aralığı: ${rangeText}, Seçilen grup sayısı: ${requestedGroupCount}`);
        
        // Tüm grupları toplamak için - her zaman A grubu dahil
        const allGroupsSet = new Set(['A']); // A grubu her zaman var
        const componentGroupData = {};
        if (studentCount === 0) {
            // Öğrenci yoksa sadece A grubu ile devam et
            console.log("⚠️ Öğrenci verisi yok, sadece A grubu oluşturuluyor");
            mainComponents.forEach(component => {
                APP_STATE.courseData.grupHaritalari[component.id] = {
                    gruplar: ['A'],
                    haritalar: { 'A': {} }
                };
            });
            
            // Varsayılan haritalamayı oluştur
            ensureDefaultGroupExists();
            createDefaultMapping();
            
            // UI güncellemeleri
            updateGroupSelectors();
            updateTreeMappingControls();
            updateAllInlineGroupInputs();
            updateAllMappingDisplays();
            renderTree();
            updateAssessmentView();
            
            showModernToast("Sadece A grubu oluşturuldu (öğrenci verisi yok)", "info");
            return;
        }
        
        // Grup sayısını öğrenci sayısı ve istenen sayı ile sınırla
        const maxPossibleGroups = Math.min(requestedGroupCount, studentCount, groupNames.length);
        const finalGroupCount = Math.max(1, maxPossibleGroups); // En az 1 grup (A grubu)
        
        console.log(`👥 Öğrenci sayısı: ${studentCount}`);
        console.log(`🎯 İstenen grup sayısı: ${requestedGroupCount}`);
        console.log(`📊 Maksimum mümkün grup sayısı: ${maxPossibleGroups}`);
        console.log(`✅ Final grup sayısı: ${finalGroupCount}`);
        
        // Her ana bileşen için uygun grup sayısı oluştur - ÖĞRENCİ SAYISINI AŞMAYACAK
        mainComponents.forEach(component => {
            let numGroups, componentGroups;
            
            // Belirlenen grup sayısını kullan
            numGroups = finalGroupCount;
            componentGroups = groupNames.slice(0, numGroups);
            
            console.log(`📊 ${component.id} için grup bilgileri:`);
            console.log(`   - Öğrenci sayısı: ${studentCount}`);
            console.log(`   - İstenen grup sayısı: ${requestedGroupCount}`);
            console.log(`   - Kullanılan grup sayısı: ${numGroups}`);
            
            console.log(`\n=== ${component.id} bileşeni için ${numGroups} grup oluşturuluyor: ${componentGroups.join(', ')} ===`);
            
            // Bu bileşenin gruplarını global grup setine ekle
            componentGroups.forEach(group => allGroupsSet.add(group));
            
            // Bileşen grup verisini sakla
            componentGroupData[component.id] = {
                gruplar: [...componentGroups],
                numGroups: numGroups
            };
            
            // Bu bileşenin grup yapısını oluştur
            APP_STATE.courseData.grupHaritalari[component.id] = {
                gruplar: [...componentGroups], // Bu bileşen için grup listesi
                haritalar: {}
            };
            
            // Her grup için mapping objesi oluştur
            componentGroups.forEach(groupName => {
                APP_STATE.courseData.grupHaritalari[component.id].haritalar[groupName] = {};
            });
            
            // Bu bileşenin alt sorularını topla
            const componentQuestions = [];
            
            function collectComponentQuestions(nodes) {
                nodes.forEach(node => {
                    if (isQuestionType(node.type) || isRubricType(node.type)) {
                        componentQuestions.push({
                            id: node.id,
                            name: node.name || node.type,
                            questionNumber: getQuestionNumberFromActivity(node.id)
                        });
                    }
                    if (node.children && node.children.length > 0) {
                        collectComponentQuestions(node.children);
                    }
                });
            }
            
            if (component.children && component.children.length > 0) {
                collectComponentQuestions(component.children);
            }
            
            console.log(`  ${component.id} soruları:`, componentQuestions.map(q => q.id));
            
            // HER GRUP İÇİN GARANTİLİ SORU DAĞILIMI - TÜM SORULAR HER GRUPTA OLMALI
            if (componentQuestions.length > 0) {
                console.log(`📝 ${componentQuestions.length} soru ${componentGroups.length} gruba dağıtılıyor...`);
                
                componentGroups.forEach((groupName, groupIndex) => {
                    console.log(`\n🎯 Grup ${groupName} (${groupIndex + 1}/${componentGroups.length}) için sıralama:`);
                    
                    // TÜM SORULARI KOPYALA - Hiçbir soru eksik kalmamalı
                    const shuffledQuestions = [...componentQuestions];
                    
                    // HER GRUP İÇİN FARKLI KARIŞTIRILMIŞ SIRALAMA
                    // Grup indeksine göre farklı seed ile karıştırma
                    for (let shuffleRound = 0; shuffleRound <= groupIndex; shuffleRound++) {
                        for (let i = shuffledQuestions.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [shuffledQuestions[i], shuffledQuestions[j]] = [shuffledQuestions[j], shuffledQuestions[i]];
                        }
                    }
                    
                    // DOĞRULAMA: Tüm sorular mevcut mu?
                    const originalQuestionIds = componentQuestions.map(q => q.id).sort();
                    const shuffledQuestionIds = shuffledQuestions.map(q => q.id).sort();
                    
                    if (originalQuestionIds.length !== shuffledQuestionIds.length) {
                        console.error(`❌ HATA: Grup ${groupName} için soru sayısı uyuşmuyor!`);
                        console.error(`   Orijinal: ${originalQuestionIds.length}, Karıştırılmış: ${shuffledQuestionIds.length}`);
                    }
                    
                    // Eksik soruları kontrol et
                    const missingQuestions = originalQuestionIds.filter(id => !shuffledQuestionIds.includes(id));
                    const extraQuestions = shuffledQuestionIds.filter(id => !originalQuestionIds.includes(id));
                    
                    if (missingQuestions.length > 0) {
                        console.error(`❌ EKSIK SORULAR (Grup ${groupName}):`, missingQuestions);
                    }
                    if (extraQuestions.length > 0) {
                        console.error(`❌ FAZLA SORULAR (Grup ${groupName}):`, extraQuestions);
                    }
                    
                    // SORU HARITASINI OLUŞTUR - Her soruya kağıt sırası ata
                    // DÜZELTME: Veri yapısı {position: questionId} formatında
                    shuffledQuestions.forEach((question, index) => {
                        const paperOrderNumber = (index + 1).toString();
                        APP_STATE.courseData.grupHaritalari[component.id].haritalar[groupName][paperOrderNumber] = question.id;
                        
                        console.log(`      📄 Kağıt sırası ${paperOrderNumber}: ${question.id} (${question.name})`);
                    });
                    
                    console.log(`✅ Grup ${groupName}: ${shuffledQuestions.length} soru başarıyla haritalandı`);
                });
                
                // ÇAPRAZ DOĞRULAMA: Tüm gruplarda aynı sorular var mı?
                console.log(`\n🔍 ÇAPRAZ DOĞRULAMA - Tüm gruplarda aynı sorular var mı?`);
                // DÜZELTME: Veri yapısı {position: questionId} formatında, values'ları karşılaştırmalıyız
                const baseGroupQuestions = Object.values(APP_STATE.courseData.grupHaritalari[component.id].haritalar[componentGroups[0]] || {}).sort();
                
                let allGroupsValid = true;
                componentGroups.forEach(groupName => {
                    const groupQuestions = Object.values(APP_STATE.courseData.grupHaritalari[component.id].haritalar[groupName] || {}).sort();
                    
                    if (JSON.stringify(baseGroupQuestions) !== JSON.stringify(groupQuestions)) {
                        console.error(`❌ HATA: Grup ${groupName} farklı sorulara sahip!`);
                        console.error(`   Beklenen: ${baseGroupQuestions}`);
                        console.error(`   Mevcut: ${groupQuestions}`);
                        allGroupsValid = false;
                    } else {
                        console.log(`✅ Grup ${groupName}: Tüm sorular mevcut (${groupQuestions.length} soru)`);
                    }
                });
                
                if (allGroupsValid) {
                    console.log(`🎉 ${component.id} bileşeni: Tüm gruplarda aynı sorular mevcut!`);
                } else {
                    console.error(`❌ ${component.id} bileşeni: Grup soru dağılımında hata var!`);
                }
            } else {
                console.log(`ℹ️ ${component.id} bileşeninde soru yok (Laboratuvar tipi)`);
            }
        });
        
        // Tüm grupları birleştir (A, B, C, D, E... şeklinde)
        const allGroups = Array.from(allGroupsSet).sort();
        console.log(`\n=== Toplam ${allGroups.length} farklı grup oluşturuldu: ${allGroups.join(', ')} ===`);
        
        // AKILLI ÖĞRENCI GRUP ATAMALARI - HER ÖĞRENCİ MUTLAKA BİR GRUBA ATANACAK
        if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
            console.log(`\n=== ${APP_STATE.studentData.length} öğrenci akıllı şekilde gruplara atanıyor ===`);
            
            // Tüm öğrencileri kopyala ve karıştır
            const students = [...APP_STATE.studentData];
            
            // Fisher-Yates karıştırma algoritması ile öğrencileri tamamen rastgele sırala
            for (let i = students.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [students[i], students[j]] = [students[j], students[i]];
            }
            
            // Grup atama sayaçları
            const groupAssignments = {};
            allGroups.forEach(group => {
                groupAssignments[group] = [];
            });
            
            // ROUND-ROBIN ATAMA: Her öğrenci sırayla gruplara atanır
            console.log(`🔄 Round-robin atama başlatılıyor...`);
            students.forEach((student, index) => {
                const groupIndex = index % allGroups.length;
                const assignedGroup = allGroups[groupIndex];
                
                // Öğrencinin ana grup bilgisini güncelle
                student.grup = assignedGroup;
                groupAssignments[assignedGroup].push(student);
                
                console.log(`  ${index + 1}. ${student.name} ${student.surname} (${student.studentId}) → Grup ${assignedGroup}`);
                
                // Bileşen bazlı grup atamalarını başlat
                if (!APP_STATE.studentComponentGroups) {
                    APP_STATE.studentComponentGroups = {};
                }
                if (!APP_STATE.studentComponentGroups[student.studentId]) {
                    APP_STATE.studentComponentGroups[student.studentId] = {};
                }
                
                // Her bileşen için aynı grubu ata (başlangıç değeri olarak)
                mainComponents.forEach(component => {
                    APP_STATE.studentComponentGroups[student.studentId][component.id] = assignedGroup;
                });
            });
            
            // GRUP DAĞILIMI KONTROLÜ VE RAPORU
            console.log(`\n=== 📊 DETAYLI GRUP DAĞILIMI RAPORU ===`);
            let totalAssigned = 0;
            let emptyGroups = [];
            
            allGroups.forEach(group => {
                const studentsInGroup = groupAssignments[group];
                const studentCount = studentsInGroup.length;
                totalAssigned += studentCount;
                
                if (studentCount === 0) {
                    emptyGroups.push(group);
                    console.log(`❌ Grup ${group}: BOŞ GRUP!`);
                } else {
                    console.log(`✅ Grup ${group}: ${studentCount} öğrenci`);
                    studentsInGroup.forEach((s, idx) => {
                        console.log(`     ${idx + 1}. ${s.name} ${s.surname} (${s.studentId})`);
                    });
                }
            });
            
            // DOĞRULAMA KONTROLLERI
            console.log(`\n=== 🔍 DOĞRULAMA KONTROLLERI ===`);
            console.log(`📋 Toplam öğrenci sayısı: ${students.length}`);
            console.log(`📋 Atanan öğrenci sayısı: ${totalAssigned}`);
            console.log(`📋 Grup sayısı: ${allGroups.length}`);
            console.log(`📋 Boş grup sayısı: ${emptyGroups.length}`);
            
            // Hata kontrolü
            if (totalAssigned !== students.length) {
                console.error(`❌ HATA: Atanan öğrenci sayısı toplam öğrenci sayısına eşit değil!`);
                showModernToast("Grup atama hatası: Bazı öğrenciler atanmadı!", "error");
                return;
            }
            
            if (emptyGroups.length > 0) {
                console.warn(`⚠️ UYARI: ${emptyGroups.length} boş grup var: ${emptyGroups.join(', ')}`);
            }
            
            // Atanmayan öğrenci kontrolü
            const unassignedStudents = students.filter(s => !s.grup || s.grup === '');
            if (unassignedStudents.length > 0) {
                console.error(`❌ HATA: ${unassignedStudents.length} öğrenci atanmadı!`);
                unassignedStudents.forEach(s => {
                    console.error(`  - ${s.name} ${s.surname} (${s.studentId})`);
                    s.grup = 'A'; // Güvenlik için A grubuna ata
                });
            }
            
            console.log(`✅ Tüm öğrenciler başarıyla gruplara atandı!`);
            
            // UI güncellemeleri
            updateStudentTable();
            updateStudentGroupInfoDisplay();
        }
        
        // Grup sistemini yeniden başlat
        initializeGroupSystem();
        
        // UI güncellemeleri - sıra önemli!
        updateGroupSelectors();
        updateTreeMappingControls();
        updateAllInlineGroupInputs(); // Grup haritalama textarea'larını güncelle
        updateAllMappingDisplays();
        
        // Tree'yi yeniden render et (grup bilgileri ile)
        renderTree();
        
        // Grup eşleştirme renklerini güncelle
        updateGroupMappingColors();
        
        // Değerlendirme bileşenlerini en son güncelle (grup alanları için)
        updateAssessmentView();
        
        // Değerlendirme bileşenlerindeki grup dropdown'larını manuel güncelle
        setTimeout(() => {
            updateAssessmentGroupSelectors();
            // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
            console.log('Grup dropdown\'ları güncellendi');
        }, 200); // updateAssessmentView'ın tamamlanmasını bekle
        
        // Bileşen başına grup sayısını ve toplam soru sayısını hesapla
        const componentSummary = mainComponents.map(comp => {
            const componentGroups = componentGroupData[comp.id];
            const questions = [];
            function countQuestions(nodes) {
                nodes.forEach(node => {
                    if (isQuestionType(node.type) || isRubricType(node.type)) {
                        questions.push(node.id);
                    }
                    if (node.children && node.children.length > 0) {
                        countQuestions(node.children);
                    }
                });
            }
            if (comp.children) countQuestions(comp.children);
            return {
                componentId: comp.id,
                groupCount: componentGroups.numGroups,
                questionCount: questions.length
            };
        });
        
        const totalQuestions = componentSummary.reduce((sum, comp) => sum + comp.questionCount, 0);
        const totalUniqueGroups = allGroups.length;
        
        // Detaylı bilgi için
        const componentDetails = componentSummary.map(comp => 
            `${comp.componentId}: ${comp.groupCount} grup (${comp.questionCount} soru)`
        ).join(', ');
        
        console.log(`\n=== RASTGELE GRUP OLUŞTURMA TAMAMLANDI ===`);
        console.log(`Toplam ${totalUniqueGroups} farklı grup: ${allGroups.join(', ')}`);
        console.log(`Bileşen detayları: ${componentDetails}`);
        console.log(`Toplam ${APP_STATE.studentData?.length || 0} öğrenci rastgele gruplara atandı`);
        console.log(`🎯 GRUP ATAMALARI TAMAMLANDI`);
        console.log(`APP_STATE.studentComponentGroups:`, APP_STATE.studentComponentGroups);
        
        // Grup dağılım özetini hazırla
        const groupDistribution = allGroups.map(group => {
            const studentsInGroup = APP_STATE.studentData.filter(s => s.grup === group);
            return `${group}(${studentsInGroup.length})`;
        }).join(', ');
        
        showModernToast(
            `🎲 Rastgele grup dağılımı tamamlandı! (${finalGroupCount} grup)\n` +
            `📊 ${totalUniqueGroups} grup: ${groupDistribution}\n` +
            `📝 ${mainComponents.length} bileşende toplam ${totalQuestions} soru eşleştirildi\n` +
            `👥 ${APP_STATE.studentData?.length || 0} öğrenci dengeli dağıtıldı`, 
            "success", 6000
        );
        
        // Öğrenci grup bilgilerini güncelle
        updateStudentGroupInfoDisplay();
        
        // Grup istatistiklerini güncelle
        updateGroupStatistics();
        
        // İstatistikleri güncelle
        updatePassFailCounts();
        
        // Grup slider'larının sınırlarını güncelle
        updateGroupSliderLimits();
        
    } catch (error) {
        console.error("❌ FATAL ERROR: Rastgele gruplar oluşturulurken hata:", error);
        console.error("❌ ERROR STACK:", error.stack);
        console.error("❌ ERROR MESSAGE:", error.message);
        console.error("❌ ERROR NAME:", error.name);
        console.error("❌ CURRENT APP_STATE:", {
            courseData: APP_STATE.courseData,
            assessmentTree: APP_STATE.assessmentTree,
            studentData: APP_STATE.studentData,
            studentComponentGroups: APP_STATE.studentComponentGroups
        });
        showModernToast("Rastgele gruplar oluşturulamadı! Detay için console'u kontrol edin.", "error");
    }
}

/**
 * Rastgele puanlama yapma (Onay ile)
 */
function generateRandomScores() {
    // Mevcut verileri kontrol et
    const hasStudents = APP_STATE.studentData && APP_STATE.studentData.length > 0;
    const hasAssessments = APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0;
    const hasExistingScores = (APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0) ||
                              (APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0);
    
    let warningMessage = '';
    
    if (!hasStudents) {
        warningMessage = 'Önce öğrenci listesi yükleyin!';
        showModernToast(warningMessage, 'warning');
        return;
    }
    
    if (!hasAssessments) {
        warningMessage = 'Önce değerlendirme bileşenleri oluşturun!';
        showModernToast(warningMessage, 'warning');
        return;
    }
    
    const passRateSlider = document.getElementById('passRateSlider');
    const passRate = passRateSlider ? parseInt(passRateSlider.value) : 70;
    const studentCount = APP_STATE.studentData.length;
    const assessmentCount = APP_STATE.assessmentTree.length;
    
    if (hasExistingScores) {
        const existingScoreCount = Object.keys(APP_STATE.gradesData || {}).length + Object.keys(APP_STATE.testScores || {}).length;
        warningMessage = `Mevcut not verileri silinecek ve yeniden oluşturulacak!\n\n${studentCount} öğrenci için ${assessmentCount} değerlendirme bileşeninde %${passRate} geçme oranına göre akıllı puanlama yapılacak.\n\nMevcut ${existingScoreCount} not verisi kaybolacak. Bu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    } else {
        warningMessage = `${studentCount} öğrenci için ${assessmentCount} değerlendirme bileşeninde %${passRate} geçme oranına göre akıllı puanlama yapılacak.\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    }
    
    showModernConfirm(
        '🧠 Akıllı Puanlama Sistemi Uygula',
        warningMessage,
        () => {
            executeGenerateRandomScores();
        }
    );
}

/**
 * Rastgele puanlama yapma (Gerçek işlem)
 */
function executeGenerateRandomScores() {
    try {
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            showModernToast("Önce öğrenci listesi yükleyin!", "warning");
            return;
        }
        
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            showModernToast("Önce değerlendirme bileşenleri oluşturun!", "warning");
            return;
        }
        
        // APP_STATE.gradesData'yı başlat
        if (!APP_STATE.gradesData) {
            APP_STATE.gradesData = {};
        }
        
        // Geçen öğrenci oranını al
        const passRateSlider = document.getElementById('passRateSlider');
        const passRate = passRateSlider ? parseInt(passRateSlider.value) : 70; // Varsayılan %70
        
        console.log("🎯 Akıllı rastgele puan oluşturma başlatıldı:");
        console.log("📊 Geçen öğrenci oranı:", passRate + '%');
        console.log("👥 Öğrenci sayısı:", APP_STATE.studentData.length);
        console.log("📋 Değerlendirme ağacı:", APP_STATE.assessmentTree.length);
        
        let scoreCount = 0;
        const totalStudents = APP_STATE.studentData.length;
        
        // Akıllı not dağılımı - geçen öğrenci oranına göre
        const passingStudents = Math.round(totalStudents * passRate / 100);
        const failingStudents = totalStudents - passingStudents;
        
        console.log(`✅ Geçecek öğrenci: ${passingStudents} (${passRate}%)`);
        console.log(`❌ Kalacak öğrenci: ${failingStudents} (${100-passRate}%)`);
        
        // Geçen öğrenciler için not aralıkları (60-100) - daha gerçekçi dağılım
        const passingGrades = [
            { min: 90, max: 100, grade: 'AA', ratio: 0.10 },  // %10 AA
            { min: 85, max: 89, grade: 'BA', ratio: 0.15 },   // %15 BA
            { min: 80, max: 84, grade: 'BB', ratio: 0.25 },   // %25 BB
            { min: 75, max: 79, grade: 'CB', ratio: 0.25 },   // %25 CB
            { min: 70, max: 74, grade: 'CC', ratio: 0.20 },   // %20 CC
            { min: 60, max: 69, grade: 'DC', ratio: 0.05 }    // %5 DC
        ];
        
        // Kalan öğrenciler için not aralıkları (0-59)
        const failingGrades = [
            { min: 50, max: 59, grade: 'DD', ratio: 0.70 },   // %70 DD (50-59)
            { min: 40, max: 49, grade: 'FD', ratio: 0.25 },   // %25 FD (40-49)
            { min: 0, max: 39, grade: 'FF', ratio: 0.05 }     // %5 FF (0-39)
        ];
        
        // Öğrencileri karıştır
        const shuffledStudents = [...APP_STATE.studentData].sort(() => Math.random() - 0.5);
        
        // Her öğrenci için hedef not aralığını belirle
        const studentGradeTargets = {};
        let studentIndex = 0;
        
        // Geçen öğrencileri dağıt
        for (const gradeInfo of passingGrades) {
            const studentsForThisGrade = Math.round(passingStudents * gradeInfo.ratio);
            for (let i = 0; i < studentsForThisGrade && studentIndex < totalStudents; i++) {
                if (studentIndex < shuffledStudents.length) {
                    studentGradeTargets[shuffledStudents[studentIndex].studentId] = gradeInfo;
                    studentIndex++;
                }
            }
        }
        
        // Kalan geçen öğrencileri CC'ye ata
        while (studentIndex < passingStudents && studentIndex < totalStudents) {
            studentGradeTargets[shuffledStudents[studentIndex].studentId] = passingGrades[4]; // CC
            studentIndex++;
        }
        
        // Kalan öğrencileri (kalanlar) dağıt
        for (const gradeInfo of failingGrades) {
            const studentsForThisGrade = Math.round(failingStudents * gradeInfo.ratio);
            for (let i = 0; i < studentsForThisGrade && studentIndex < totalStudents; i++) {
                if (studentIndex < shuffledStudents.length) {
                    studentGradeTargets[shuffledStudents[studentIndex].studentId] = gradeInfo;
                    studentIndex++;
                }
            }
        }
        
        // Kalan öğrencileri DD'ye ata
        while (studentIndex < totalStudents) {
            studentGradeTargets[shuffledStudents[studentIndex].studentId] = failingGrades[0]; // DD
            studentIndex++;
        }
        
        // Her öğrenci için hedef nota uygun puanlar oluştur
        console.log("🎯 Hedef not dağılımı örnekleri:", Object.entries(studentGradeTargets).slice(0, 5).map(([id, grade]) => `${id}: ${grade.grade} (${grade.min}-${grade.max})`));
        
        APP_STATE.studentData.forEach(student => {
            const targetGrade = studentGradeTargets[student.studentId];
            
            APP_STATE.assessmentTree.forEach(activity => {
                if (activity.children && activity.children.length > 0) {
                    // Alt bileşenler varsa onlara puan ver
                    activity.children.forEach(subItem => {
                        if (subItem.type === 'Test' && subItem.testDetails) {
                            // Test için doğru/yanlış sayısı - hedef nota göre ayarla
                            const totalQuestions = subItem.testDetails.totalQuestions;
                            const targetPercentage = (targetGrade.min + Math.random() * (targetGrade.max - targetGrade.min)) / 100;
                            const correct = Math.floor(totalQuestions * targetPercentage);
                            const remaining = totalQuestions - correct;
                            const wrong = Math.floor(Math.random() * remaining);
                            
                            if (!APP_STATE.testScores) APP_STATE.testScores = {};
                            if (!APP_STATE.testScores[student.studentId]) APP_STATE.testScores[student.studentId] = {};
                            
                            APP_STATE.testScores[student.studentId][subItem.id] = {
                                correct: correct,
                                wrong: wrong,
                                empty: totalQuestions - correct - wrong
                            };
                        } else {
                            // Normal puan - hedef nota göre ayarla
                            const maxPoints = subItem.points || 100;
                            const targetScore = targetGrade.min + Math.random() * (targetGrade.max - targetGrade.min);
                            const score = Math.round((targetScore / 100) * maxPoints);
                            
                            if (!APP_STATE.gradesData[student.studentId]) {
                                APP_STATE.gradesData[student.studentId] = {};
                            }
                            APP_STATE.gradesData[student.studentId][subItem.id] = Math.max(0, Math.min(maxPoints, score));
                        }
                        scoreCount++;
                    });
                } else {
                    // Ana aktiviteye direkt puan ver - hedef nota göre ayarla
                    const maxPoints = activity.points || 100;
                    const targetScore = targetGrade.min + Math.random() * (targetGrade.max - targetGrade.min);
                    const score = Math.round((targetScore / 100) * maxPoints);
                    
                    if (!APP_STATE.gradesData[student.studentId]) {
                        APP_STATE.gradesData[student.studentId] = {};
                    }
                    APP_STATE.gradesData[student.studentId][activity.id] = Math.max(0, Math.min(maxPoints, score));
                    scoreCount++;
                }
            });
        });
        
        // Notları hesapla
        calculateFinalGrades();
        
        // Tüm görünümleri güncelle
        updateAssessmentView();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        
        // Eğer öğrenci bazlı not girişi açıksa, seçili öğrenciyi yenile
        if (APP_STATE.selectedStudentId) {
            const container = document.getElementById('studentGradesContainer');
            if (container && container.innerHTML !== '<p class="empty-message">Veri bulunamadı.</p>') {
                showStudentGrades(APP_STATE.selectedStudentId);
            }
        }
        
        // Harf notu dağılımını hesapla ve göster
        console.log("Final notları hesaplanıyor...");
        calculateFinalGrades(); // Notları hesapla
        console.log("Final notları hesaplandı.");
        
        const gradeDistribution = {};
        
        // APP_STATE.gradesData'dan harf notlarını al
        APP_STATE.studentData.forEach(student => {
            const studentGrades = APP_STATE.gradesData[student.studentId];
            if (studentGrades && studentGrades.harfNotu) {
                const letterGrade = studentGrades.harfNotu;
                gradeDistribution[letterGrade] = (gradeDistribution[letterGrade] || 0) + 1;
            }
        });
        
        const distributionText = Object.entries(gradeDistribution)
            .sort(([a], [b]) => {
                const gradeOrder = ['AA', 'BA', 'BB', 'CB', 'CC', 'DC', 'DD', 'FD', 'FF'];
                return gradeOrder.indexOf(a) - gradeOrder.indexOf(b);
            })
            .map(([grade, count]) => `${grade}: ${count}`)
            .join(', ');
        
        // Geçme/kalma analizi
        const actualPassing = Object.values(gradeDistribution).slice(0, 6).reduce((sum, count) => sum + count, 0); // AA-DC arası
        const actualFailing = Object.values(gradeDistribution).slice(6).reduce((sum, count) => sum + count, 0); // DD-FF arası
        const actualPassRate = Math.round((actualPassing / totalStudents) * 100);
        
        console.log(`📊 Gerçekleşen dağılım: Geçen ${actualPassing} (${actualPassRate}%), Kalan ${actualFailing} (${100-actualPassRate}%)`);
        
        showModernToast(`🎯 ${scoreCount} akıllı puan oluşturuldu! Hedef: %${passRate} geçen → Gerçek: %${actualPassRate} geçen\n📊 ${distributionText}`, "success", 5000);
        
        // Pass rate göstergelerini güncelle
        updatePassRateIndicators();
        
        // İstatistikleri güncelle
        updatePassFailCounts();
        
    } catch (error) {
        console.error("Rastgele puanlama yapılırken hata:", error);
        showModernToast("Rastgele puanlama yapılamadı!", "error");
    }
}

/**
 * Test öğrencileri oluşturma (Onay ile)
 */
function generateTestStudents() {
    // Mevcut öğrenci verilerini kontrol et
    const hasExistingStudents = APP_STATE.studentData && APP_STATE.studentData.length > 0;
    const currentStudentCount = hasExistingStudents ? APP_STATE.studentData.length : 0;
    
    const warningMessage = hasExistingStudents 
        ? `Sistemde zaten ${currentStudentCount} öğrenci mevcut. Bu işlem mevcut öğrencilerin üzerine yazacak ve tüm not verilerini sıfırlayacak.\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`
        : `10-24 arası rastgele test öğrencisi oluşturulacak. Bu işlem geri alınamaz.\n\nDevam etmek istediğinizden emin misiniz?`;
    
    showModernConfirm('👥 Rastgele Test Öğrencileri Oluştur', warningMessage, {
            confirmText: 'Evet, Oluştur',
            cancelText: 'İptal',
        confirmClass: 'btn-modern-primary',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
        executeGenerateTestStudents();
    });
}

/**
 * Test öğrencileri oluşturma (Gerçek işlem - Tam Dosya Format uyumlu)
 */
function executeGenerateTestStudents() {
    try {
        const firstNames = ['Ahmet', 'Mehmet', 'Ayşe', 'Fatma', 'Ali', 'Veli', 'Zeynep', 'Elif', 'Mustafa', 'Hatice', 'İbrahim', 'Emine', 'Hüseyin', 'Meryem', 'Ömer', 'Selin', 'Burak', 'Deniz', 'Can', 'Seda'];
        const lastNames = ['Yılmaz', 'Kaya', 'Demir', 'Çelik', 'Şahin', 'Yıldız', 'Yıldırım', 'Öztürk', 'Aydin', 'Özdemir', 'Arslan', 'Doğan', 'Kılıç', 'Aslan', 'Çetin', 'Koç', 'Kurt', 'Özkan', 'Erdoğan', 'Güneş'];
        
        const numStudents = Math.floor(Math.random() * 15) + 10; // 10-24 öğrenci
        const testStudents = [];
        
        console.log(`👥 ${numStudents} test öğrencisi oluşturuluyor...`);
        
        for (let i = 0; i < numStudents; i++) {
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            const studentId = `2114010${String(i + 50).padStart(2, '0')}`;
            
            // updateStudentTable() ile uyumlu format
            testStudents.push({
                studentId: studentId,
                name: firstName,
                surname: lastName,
                status: Math.random() > 0.9 ? 'İlişiği Kesilmiş' : 'Aktif', // %10 ilişiği kesilmiş
                email: `${firstName.toLowerCase()}_${lastName.toLowerCase()}@erdogan.edu.tr`,
                tcKimlik: `${Math.floor(Math.random() * 90000000000) + 10000000000}`,
                telefon: `05${Math.floor(Math.random() * 900000000) + 100000000}`,
                // Tam dosya formatı için alias'lar
                ogrenciNo: studentId,
                ad: firstName,
                soyad: lastName,
                durum: Math.random() > 0.9 ? 'İlişiği Kesilmiş' : 'Aktif'
            });
        }
        
        // Tam dosya formatına uygun olarak courseData.ogrenciler'e kaydet
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = {};
        }
        
        // Hem eski sistem hem tam dosya uyumluluğu için
        APP_STATE.studentData = testStudents;
        APP_STATE.courseData.ogrenciler = testStudents;
        
        // Öğrenci tablosunu güncelle
        updateStudentTable();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        
        // Değerlendirme görünümünü güncelle
        updateAssessmentView();
        
        // Akıllı puanlama öğrenci sayılarını güncelle
        const passRateSlider = document.getElementById('passRateSlider');
        if (passRateSlider) {
            const passRate = parseInt(passRateSlider.value);
            updateStudentCounts(passRate);
        }
        
        // İstatistikleri güncelle
        updatePassFailCounts();
        
        // Dual range slider uyarısını güncelle
        const minSlider = document.getElementById('groupMinSlider');
        const maxSlider = document.getElementById('groupMaxSlider');
        if (minSlider && maxSlider) {
            updateDualRangeWarning(parseInt(minSlider.value), parseInt(maxSlider.value));
        }
        
        // Grup istatistiklerini güncelle
        updateGroupStatistics();
        
        // Grup slider'larının sınırlarını güncelle
        updateGroupSliderLimits();
        
        showModernToast(`✅ Tam dosya formatında ${numStudents} test öğrencisi oluşturuldu!`, "success");
        
    } catch (error) {
        console.error("Test öğrencileri oluşturulurken hata:", error);
        showModernToast("Test öğrencileri oluşturulamadı!", "error");
    }
}

/**
 * Tam test verisi oluşturma (hepsini birden)
 */
function generateFullTestData() {
    try {
        showModernToast("🚀 Kapsamlı test verisi oluşturuluyor...", "info", 3000);
        
        console.log("🎯 TAM TEST VERİSİ OLUŞTURMA BAŞLADI");
        
        // 1. Test öğrencileri oluştur
        console.log("👥 1/5 - Test öğrencileri oluşturuluyor...");
        generateTestStudents();
        
        // 2. Çeşitli değerlendirme bileşenleri ekle (gerçekçi sayıda)
        setTimeout(() => {
            console.log("📝 2/5 - Değerlendirme bileşenleri oluşturuluyor...");
            const assessmentCount = Math.floor(Math.random() * 3) + 4; // 4-6 değerlendirme
            
            for (let i = 0; i < assessmentCount; i++) {
                generateRandomAssessment();
            }
            
            // 3. Rastgele gruplar oluştur (değerlendirmeler oluşturulduktan sonra)
            setTimeout(() => {
                console.log("🎲 3/5 - Grup sistemleri oluşturuluyor...");
                generateRandomGroups();
                
                // 4. Rastgele puanlar ver
                setTimeout(() => {
                    console.log("📊 4/5 - Rastgele puanlar oluşturuluyor...");
                    generateRandomScores();
                    
                    // 5. Tüm görünümleri güncelle ve finalize et
                    setTimeout(() => {
                        console.log("🔄 5/5 - UI güncellemeleri yapılıyor...");
                        
                        // Kapsamlı UI güncellemeleri
                        updateAssessmentView();
                        updateCategoryWeights();
                        renderTree();
                        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
                        updateGroupSelectors();
                        updateTreeMappingControls();
                        updateAllInlineGroupInputs();
                        updateAllMappingDisplays();
                        
                        // Eğer farklı sekmeler açıksa onları da güncelle
                        const activeTab = document.querySelector('.nav-tab.active');
                        if (activeTab) {
                            const tabId = activeTab.getAttribute('data-tab');
                            if (tabId === 'assessment') {
                                updateAssessmentView();
                                                         // Öğrenci bazlı not girişi sekmesi kaldırıldı
                            }
                        }
                        
                        // Özet bilgileri
                        const studentCount = APP_STATE.studentData?.length || 0;
                        const assessmentCount = APP_STATE.assessmentTree?.length || 0;
                        const groupCount = Object.keys(APP_STATE.courseData?.grupHaritalari || {}).length;
                        
                        console.log("✅ TAM TEST VERİSİ OLUŞTURMA TAMAMLANDI");
                        console.log(`📊 Özet: ${studentCount} öğrenci, ${assessmentCount} değerlendirme, ${groupCount} grup sistemi`);
                        
                        showModernToast(
                            `🎉 Tam test verisi başarıyla oluşturuldu!\n` +
                            `👥 ${studentCount} öğrenci\n` +
                            `📝 ${assessmentCount} değerlendirme bileşeni\n` +
                            `🎲 ${groupCount} grup sistemi\n` +
                            `📊 Rastgele puanlar atandı`, 
                            "success", 6000
                        );
                        
                    }, 800);
                }, 1200);
            }, 800);
        }, 600);
        
    } catch (error) {
        console.error("❌ Tam test verisi oluşturulurken hata:", error);
        showModernToast("Tam test verisi oluşturulamadı!", "error");
    }
}

/**
 * Tüm test verilerini temizleme
 */
function clearAllTestData() {
    try {
        console.log("🔧 clearAllTestData başlatıldı");
        
        // Önce silinecek veri var mı kontrol et
        const hasData = (APP_STATE.studentData && APP_STATE.studentData.length > 0) ||
                       (APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0) ||
                       (APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0) ||
                       (APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0);
        
        if (!hasData) {
            showModernToast("ℹ️ Silinecek test verisi bulunmuyor.", "info");
            return;
        }
        
        // Modern onay modalı kullan
        showModernConfirm('🧪 Tüm Test Verilerini Sil', 'Tüm test verileri silinecek (öğrenciler, değerlendirmeler, notlar, gruplar). Bu işlem geri alınamaz! Emin misiniz?', {
            confirmText: 'Evet, Sil',
            cancelText: 'İptal',
            confirmClass: 'btn-modern-danger',
            cancelClass: 'btn-modern-secondary'
        }).then(() => {
                console.log("✅ clearAllTestData onaylandı, temizleme başlıyor...");
        
                // 1. Tüm verileri koordineli şekilde temizle
        APP_STATE.studentData = [];
        APP_STATE.assessmentTree = [];
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        APP_STATE.courseData = {
            grupHaritalari: { A: {} }
        };
        APP_STATE.selectedStudentId = null;
                APP_STATE.selectedNode = null;
        
                // 2. UI'ları güvenli şekilde güncelle
        updateStudentTable();
        renderTree();
                if (typeof updateGroupSelectors === 'function') {
        updateGroupSelectors();
                }
        updateAssessmentView();
        updateCategoryWeights();
                if (typeof updateTreeMappingControls === 'function') {
        updateTreeMappingControls();
                }
        
                // 3. Containers'ı temizle
        const containers = [
            'studentGradesContainer',
            'assessmentContainer',
            'gradesTableContainer'
        ];
        
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
            }
        });
        
                // 4. Not tablosunu güvenli şekilde temizle
                try {
                    updateGradesTable([]);
                } catch (tableError) {
                    console.warn("⚠️ Not tablosu güncellenirken hata (görmezden gelindi):", tableError);
                    const gradesTable = document.getElementById('gradesTable');
                    if (gradesTable) {
                        const tbody = gradesTable.querySelector('tbody');
                        if (tbody) {
                            tbody.innerHTML = '<tr><td colspan="8" class="empty-message">Not girişi yapılmadı</td></tr>';
                        }
                    }
        }
        
                // 5. Grup slider'larının sınırlarını sıfırla
                if (typeof updateGroupSliderLimits === 'function') {
        updateGroupSliderLimits();
                }
        
                // 6. Akıllı puanlama sayılarını sıfırla (öğrenci kalmadığı için)
        const passRateSlider = document.getElementById('passRateSlider');
        if (passRateSlider) {
            const passRate = parseInt(passRateSlider.value);
                    if (typeof updateStudentCounts === 'function') {
            updateStudentCounts(passRate);
                    }
        }
        
                // 7. Dual range slider uyarısını güncelle (öğrenci kalmadığı için)
        const minSlider = document.getElementById('groupMinSlider');
        const maxSlider = document.getElementById('groupMaxSlider');
                if (minSlider && maxSlider && typeof updateDualRangeWarning === 'function') {
            updateDualRangeWarning(parseInt(minSlider.value), parseInt(maxSlider.value));
        }
        
                showModernToast("🧪 Tüm test verileri koordineli şekilde temizlendi!", "success");
        });
        
    } catch (error) {
        console.error("❌ Test verileri temizlenirken hata:", error);
        showModernToast("Test verileri temizlenemedi!", "error");
    }
}

/**
 * Test ders datası oluşturma (data-input örneklerine benzer)
 */
/**
 * Test ders verisi oluşturma (Onay ile)
 */
function generateTestCourseData() {
    // Mevcut verileri kontrol et
    const hasExistingData = APP_STATE.courseData && (
        (APP_STATE.courseData.ogrenciler && APP_STATE.courseData.ogrenciler.length > 0) ||
        (APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0)
    );
    
    const warningMessage = hasExistingData 
        ? `Bu işlem mevcut tüm ders verilerini (öğrenciler, değerlendirmeler, notlar) tamamen değiştirecek ve kapsamlı MUDEK uyumlu test verisi oluşturacak.\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`
        : `Kapsamlı MUDEK uyumlu test ders verisi oluşturulacak (öğrenciler, değerlendirmeler, haftalık içerikler, öğrenme çıktıları).\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    
        showModernConfirm('📚 Test Ders Verisi Oluştur', warningMessage, {
                confirmText: 'Evet, Oluştur',
                cancelText: 'İptal',
            confirmClass: 'btn-modern-primary',
            cancelClass: 'btn-modern-secondary'
        }).then(() => {
            executeGenerateTestCourseData();
        });
}

/**
 * Test ders verisi oluşturma (Gerçek işlem)
 */
function executeGenerateTestCourseData() {
    try {
        showModernToast("🎓 Tam dosya formatında tam MUDEK uyumlu test ders verisi oluşturuluyor...", "info", 4000);
        
        // Test öğrencileri oluştur (kişisel veriler değiştirilecek)
        const testStudents = [];
        const turkishNames = [
            'Ahmet', 'Mehmet', 'Ali', 'Mustafa', 'Hasan', 'Hüseyin', 'İbrahim', 'Osman', 'Yusuf', 'Murat',
            'Fatma', 'Ayşe', 'Emine', 'Hatice', 'Zeynep', 'Elif', 'Merve', 'Büşra', 'Seda', 'Özge',
            'Emre', 'Burak', 'Cem', 'Deniz', 'Ege', 'Furkan', 'Gökhan', 'Halil', 'İsmail', 'Kemal',
            'Selin', 'Tuğba', 'Ülkü', 'Vildan', 'Wanda', 'Ximena', 'Yasemin', 'Zara', 'Aslı', 'Berna'
        ];
        const turkishSurnames = [
            'Yılmaz', 'Kaya', 'Demir', 'Şahin', 'Çelik', 'Yıldız', 'Yıldırım', 'Öztürk', 'Aydin', 'Özdemir',
            'Arslan', 'Doğan', 'Kılıç', 'Aslan', 'Çetin', 'Kara', 'Koç', 'Kurt', 'Özkan', 'Şimşek',
            'Polat', 'Güler', 'Türk', 'Acar', 'Bulut', 'Erdoğan', 'Keskin', 'Taş', 'Akın', 'Bayram'
        ];
        
        // 15-25 arası öğrenci oluştur
        const numStudents = Math.floor(Math.random() * 11) + 15;
        
        for (let i = 0; i < numStudents; i++) {
            const firstName = turkishNames[Math.floor(Math.random() * turkishNames.length)];
            const lastName = turkishSurnames[Math.floor(Math.random() * turkishSurnames.length)];
            const studentNo = `2114010${String(i + 50).padStart(2, '0')}`;
            const tcKimlik = String(Math.floor(Math.random() * 90000000000) + 10000000000);
            const phone = `05${Math.floor(Math.random() * 900000000) + 100000000}`;
            
            testStudents.push({
                ogrenciNo: studentNo,
                ad: firstName,
                soyad: lastName,
                durum: Math.random() > 0.85 ? 'İlişiği Kesilmiş' : 'Aktif',
                email: `${firstName.toLowerCase()}_${lastName.toLowerCase()}21@erdogan.edu.tr`,
                tcKimlik: tcKimlik,
                telefon: phone
            });
        }
        
        // Gerçek MUDEK dosyasından test ders datası oluştur (sadece kişisel veriler değiştirilir)
        const testCourseData = {
            "disaAktarmaTarihi": new Date().toISOString(),
            "dersBilgisi": {
                "dersKodu": "CE100",
                "dersAdi": "Algorithms And Programming II",
                "akademikYil": "2024-2025",
                "donem": "Bahar Dönemi",
                "ogretimUyesi": "DOKTOR ÖĞRETİM ÜYESİ TEST HOCASI"
            },
            "ogrenciler": testStudents,
            "dersDegerlendirme": {
                "yariyilIciEtkinlikleri": [
                    {
                        "etkinlik": "Ara Sınav",
                        "sayi": 1,
                        "katkiYuzdesi": 50
                    },
                    {
                        "etkinlik": "Ev Ödevi",
                        "sayi": 4,
                        "katkiYuzdesi": 33
                    },
                    {
                        "etkinlik": "Laboratuvar",
                        "sayi": 15,
                        "katkiYuzdesi": 17
                    }
                ],
                "yariyilIciToplam": 100,
                "yariyilSonuEtkinlikleri": [
                    {
                        "etkinlik": "Final Sınavı",
                        "sayi": 1,
                        "katkiYuzdesi": 100
                    }
                ],
                "yariyilSonuToplam": 100,
                "genelDegerlendirme": [
                    {
                        "degerlendirme": "Yarıyıl (Yıl) Sonu Etkinlikleri",
                        "katkiYuzdesi": 60
                    },
                    {
                        "degerlendirme": "Yarıyıl (Yıl) İçi Etkinlikleri",
                        "katkiYuzdesi": 40
                    }
                ],
                "genelDegerlendirmeToplam": 100
            },
            "ogrenciNotlari": {},
            "dersGenel": {
                "dersTuru": "Zorunlu",
                "dersinSeviyesi": "Lisans",
                "haftalikDersSaatiKuramsal": 3,
                "haftalikUygulamaSaati": 0,
                "haftalikLaboratuarSaati": 2,
                "dersinVerildigiYariyil": 2,
                "ogretimSistemi": "Birinci Öğretim",
                "egitimDili": "İngilizce",
                "universite": "Recep Tayyip Erdoğan Üniversitesi",
                "ulke": "Türkiye",
                "il": "Rize",
                "ilce": "Merkez",
                "mahalle": "Fener Mah",
                "fakulte": "Mühendislik Ve Mimarlık Fakültesi",
                "bolum": "Bilgisayar Mühendisliği",
                "dersKodu": "CE100",
                "dersAdi": "Algorithms and Programming II",
                "ogretimYiliDonemi": "Bahar",
                "dersAKTSKredisi": 5,
                "dilSecimi": "İngilizce",
                "mufredatOlusturulmaYili": "2020",
                "akademikYil": "2024-2025 Bahar",
                "dersKredisi": 4
            },
            "dersIcerik": {
                "dersinAmaci": "Bu ders Algoritmalar ve Programlama I dersinin devamı niteliğindedir. Bu derste Algoritmalar ve Programlama I dersinde öğrenilen programlama becerileri, ortak problemler ve çözüm algoritmaları ile bütünleşir. Bu ders, algoritmaların yaygın sorunlar için nasıl çalıştığını analiz etmek ve anlamakla ilgilidir. Sınıf, uzmanlık paylaşımına dayalı olacak ve öğrencilerin algoritma ve programlama konuları için öğrenme yöntemleri ve uygulamaları bulmalarına rehberlik edilecektir. Derslerde programlama uygulamaları ve projeleri yapılacaktır. Teoriden çok uygulama yapılarak öğrenme süreci güçlendirilecektir.",
                "dersinOnKosuluOlanDersler": "CE103 (Algorithms and Programming-I)",
                "dersinIcerigi": "Algoritma Temelleri, Sözde Kodlama, Zaman Karmaşıklığı ve Asimptotik Gösterim için Algoritma Analizi, Sıralama Sorunları (Ekleme ve Birleştirme Sıralamaları), Özyinelemeli Algoritmalar, Böl ve Fethet Analizi (Birleştirme Sıralama, İkili Arama), Matris Çarpma Problemi, Hızlı Sıralama Analizi, Yığınlar, Yığın Sıralama ve Öncelik Kuyrukları, Bağlantılı Listeler, Radix Sıralaması ve Sayma Sıralaması, Dışbükey Gövde (Convex Hull), Dinamik Programlama, Açgözlü Algoritmalar, Grafikler ve Grafikler Arama Algoritmaları (Genişlik-İlk Arama, Derinlik-İlk Arama ve Topolojik Sıralama), Grafik Yapısı Algoritmaları (Güçlü Bağlantılı Bileşenler, Minimum Yayılma Ağacı), Ayrık Küme İşlemleri, Tek Kaynaklı En Kısa Yol Algoritması, Q-Learning En Kısa Yol Uygulaması, Ağ Akışı ve Uygulamaları, Veri Özetleme ve Şifreleme.",
                "dersinIcinOnerilenHususlar": "Öğrencilerin Algoritmalar ve Programlama I dersindeki temel programlama bilgisine sahip olması, derslere düzenli katılımı ve laboratuvar çalışmalarını/ödevleri zamanında yapması beklenmektedir. Teorik konuların pratik uygulamalarla pekiştirilmesi önemlidir.",
                "ogretimTuru": "Birinci Öğretim",
                "stajDurumu": "Mevcut Değil",
                "dersinKitabiMalzemesiOnerilenKaynaklar": "1. Paul Deitel ve Harvey Deitel. 2012. C How to Program (7. baskı). Prentice Hall Press, USA.\n2. Intro to Java Programming, Comprehensive Version (10th Edition) 10th Edition by Y. Daniel Liang\n3. Introduction to Algorithms, Third Edition By Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein\n4. Problem Solving and Program Design in C, J.R. Hanly, and E.B. Koffman, 6th Edition.\n5. Robert Sedgewick and Kevin Wayne. 2011. Algorithms (4th. ed.). Addison-Wesley Professional.\n6. Harvey M. Deitel and Paul J. Deitel. 2001. Java How to Program (4th. ed.). Prentice-Hall PTR, USA.\n7. Paul Deitel ve Harvey Deitel. 2016. Visual C# How to Program (6th. ed.). Pearson.",
                "dersiVerenOgretimUyesiOgretimGorevlisi": "Dr. Öğr. Üyesi TEST HOCASI",
                "hazirlanmaTarihi": new Date().toLocaleDateString('tr-TR'),
                "email": "test.hoca@erdogan.edu.tr",
                "avesisProfile": "https://avesis.erdogan.edu.tr/test.hoca",
                "avesisId": "test.hoca"
            },
            "dersOgrenmeÇiktilari": [
                {
                    "id": "ÖÇ.1",
                    "aciklama": "Verilen bir hesaplama problemi için uygun algoritmayı seçer, çözümünü tasarlar ve seçilen bir programlama dilinde (C/C++, Java, C#) uygular."
                },
                {
                    "id": "ÖÇ.2",
                    "aciklama": "Algoritmaların zaman ve bellek karmaşıklığını asimptotik gösterim (Büyük O, Omega, Teta) kullanarak analiz eder."
                },
                {
                    "id": "ÖÇ.3",
                    "aciklama": "Özyinelemeli (recursive) algoritmaları tasarlar ve yineleme bağıntılarını (örn. Master Teoremi) kullanarak karmaşıklıklarını analiz eder."
                },
                {
                    "id": "ÖÇ.4",
                    "aciklama": "Böl ve fethet, dinamik programlama ve açgözlü (greedy) algoritma tasarım paradigmalarını anlar ve ilgili problemlere uygular (örn. sıralama, matris çarpımı, en uzun ortak alt dizi, aktivite seçimi)."
                },
                {
                    "id": "ÖÇ.5",
                    "aciklama": "Graf veri yapısını ve temel graf algoritmalarını (BFS, DFS, topolojik sıralama, minimum yayılan ağaç, en kısa yol) anlar ve uygular."
                },
                {
                    "id": "ÖÇ.6",
                    "aciklama": "Hashing, simetrik/asimetrik şifreleme ve dijital imza gibi temel kriptografik kavramları ve algoritmaları anlar; güvenlik ve bütünlük sağlamadaki rollerini açıklar."
                },
                {
                    "id": "ÖÇ.7",
                    "aciklama": "Farklı veri yapıları (örn. yığın, bağlı liste, graf) ve algoritmaların (örn. sıralama, arama, graf algoritmaları) performans özelliklerini karşılaştırır ve problem gereksinimlerine göre en uygun olanı seçer."
                }
            ],
            "haftalikDersIcerikleri": [
                {
                    "hafta": 1,
                    "icerik": "Ders Planı ve İletişim Not Sistemi, Ödevler ve Sınavlar. Algoritma Temelleri, Sözde Kod, RAM Modeli, Algoritma Maliyet Hesaplaması. Asimptotik Notasyon. Sıralama Problemi.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.2, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Temel algoritma ve programlama bilgisi (CE103)",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 2,
                    "icerik": "Yinelemeleri Çözme (Yineleme Ağacı, Ana Yöntem ve Geri Yerine Koyma). Böl ve Fethet Analizi.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.3, ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Asimptotik notasyon",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 3,
                    "icerik": "Matris Çarpma, Quicksort, Heapsort, Radix Sort, Counting Sort.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Böl ve Fethet",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı (Ara Sınav Ödevi-1 Gönderilecek)"
                },
                {
                    "hafta": 4,
                    "icerik": "Arasınav Ödevi-1 Kontroller ve Özetle Tekrar",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Bilgisayar Laboratuvarı",
                    "onHazirlik": "Ödev-1",
                    "ogretimYontemleri": "Soru-Cevap, Değerlendirme",
                    "aracVeGerecler": "Bilgisayar, IDE",
                    "kaynakVeMateryal": "Ödevler",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "-"
                },
                {
                    "hafta": 5,
                    "icerik": "Konveks Gövde (Convex Hull). Dinamik Programlama (Fibonacci, Matris Zinciri Çarpımı).",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Temel algoritmalar",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 6,
                    "icerik": "Dinamik Programlama (LCS). Açgözlü Algoritmalar (Aktivite Seçimi, Sırt Çantası).",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Dinamik Programlama temelleri",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı (Ara Sınav Ödevi-2 Gönderilecek)"
                },
                {
                    "hafta": 7,
                    "icerik": "Arasınav Ödevi-2 Kontroller ve Özetle Tekrar",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Bilgisayar Laboratuvarı",
                    "onHazirlik": "Ödev-2",
                    "ogretimYontemleri": "Soru-Cevap, Değerlendirme",
                    "aracVeGerecler": "Bilgisayar, IDE",
                    "kaynakVeMateryal": "Ödevler",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "-"
                },
                {
                    "hafta": 8,
                    "icerik": "Vize",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı",
                    "onHazirlik": "1-7 hafta konuları",
                    "ogretimYontemleri": "Ölçme Değerlendirme",
                    "aracVeGerecler": "-",
                    "kaynakVeMateryal": "-",
                    "degerlendirmeYontemleri": "Yazılı Sınav/Proje",
                    "odevVeCalisma": "-"
                },
                {
                    "hafta": 9,
                    "icerik": "Yığın Veri Yapısı, Yığın Sıralama, Huffman Kodlama.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.4, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Temel veri yapıları",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 10,
                    "icerik": "Grafiklere Giriş, Gösterim, BFS, DFS, Topolojik Sıra, SCC, MST, Prim, Kruskal, Tek Kaynak En Kısa Yol.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.5, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Temel veri yapıları",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 11,
                    "icerik": "Q-Learning En Kısa Yol, Max-Flow Min-Cut. Kriptografi: Hashing ve Bütünlük Kontrolü.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.5, ÖÇ.6, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Graf algoritmaları",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE",
                    "kaynakVeMateryal": "Ders Notları, Kaynak Kitaplar",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı (Son Ödev-1 Gönderilecek)"
                },
                {
                    "hafta": 12,
                    "icerik": "Son Ödev-1 Kontrolleri ve Özetle İnceleme",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.5, ÖÇ.6, ÖÇ.7",
                    "ogretimOrtami": "Bilgisayar Laboratuvarı",
                    "onHazirlik": "Ödev-1",
                    "ogretimYontemleri": "Soru-Cevap, Değerlendirme",
                    "aracVeGerecler": "Bilgisayar, IDE",
                    "kaynakVeMateryal": "Ödevler",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "-"
                },
                {
                    "hafta": 13,
                    "icerik": "Kriptografi: Simetrik Şifreleme, Asimetrik Şifreleme, Dijital İmza.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.6",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Temel kriptografi kavramları",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE, Crypto++",
                    "kaynakVeMateryal": "Ders Notları, Kriptografi Kaynakları",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı"
                },
                {
                    "hafta": 14,
                    "icerik": "Kriptografi: OTP Hesaplama, Dosya Şifreleme/Şifre Çözme.",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.6",
                    "ogretimOrtami": "Sınıf Ortamı, Bilgisayar Laboratuvarı",
                    "onHazirlik": "Şifreleme algoritmaları",
                    "ogretimYontemleri": "Anlatım, Problem Çözme, Uygulama",
                    "aracVeGerecler": "Bilgisayar, Projeksiyon, IDE, Crypto++",
                    "kaynakVeMateryal": "Ders Notları, Kriptografi Kaynakları",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "Programlama Çalıştayı (Son Ödev-2 Gönderilecek)"
                },
                {
                    "hafta": 15,
                    "icerik": "Son Ödev-2 Kontrolleri ve Özetle İnceleme",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.5, ÖÇ.6, ÖÇ.7",
                    "ogretimOrtami": "Bilgisayar Laboratuvarı",
                    "onHazirlik": "Ödev-2",
                    "ogretimYontemleri": "Soru-Cevap, Değerlendirme",
                    "aracVeGerecler": "Bilgisayar, IDE",
                    "kaynakVeMateryal": "Ödevler",
                    "degerlendirmeYontemleri": "-",
                    "odevVeCalisma": "-"
                },
                {
                    "hafta": 16,
                    "icerik": "Final",
                    "iliskiliOgrenmeÇiktisi": "ÖÇ.1, ÖÇ.2, ÖÇ.3, ÖÇ.4, ÖÇ.5, ÖÇ.6, ÖÇ.7",
                    "ogretimOrtami": "Sınıf Ortamı",
                    "onHazirlik": "Tüm konular",
                    "ogretimYontemleri": "Ölçme Değerlendirme",
                    "aracVeGerecler": "-",
                    "kaynakVeMateryal": "-",
                    "degerlendirmeYontemleri": "Yazılı Sınav/Proje",
                    "odevVeCalisma": "-"
                }
            ],
            "dersIsYuku": {
                "etkinlikler": [
                    {
                        "etkinlik": "Derse Katılım",
                        "sayi": 14,
                        "sure": 3,
                        "toplamIsYuku": 42
                    },
                    {
                        "etkinlik": "Laboratuvar",
                        "sayi": 14,
                        "sure": 2,
                        "toplamIsYuku": 28
                    },
                    {
                        "etkinlik": "Bireysel Çalışma",
                        "sayi": 14,
                        "sure": 1.8571428571428572,
                        "toplamIsYuku": 26
                    },
                    {
                        "etkinlik": "Ara Sınav",
                        "sayi": 1,
                        "sure": 1,
                        "toplamIsYuku": 1
                    },
                    {
                        "etkinlik": "Ara Sınav İçin Bireysel Çalışma",
                        "sayi": 1,
                        "sure": 6,
                        "toplamIsYuku": 6
                    },
                    {
                        "etkinlik": "Ev Ödevi",
                        "sayi": 4,
                        "sure": 1,
                        "toplamIsYuku": 4
                    },
                    {
                        "etkinlik": "Bireysel Çalışma",
                        "sayi": 4,
                        "sure": 2,
                        "toplamIsYuku": 8
                    },
                    {
                        "etkinlik": "Final Sınavı",
                        "sayi": 1,
                        "sure": 2,
                        "toplamIsYuku": 2
                    },
                    {
                        "etkinlik": "Final Sınavı İçin Bireysel Çalışma",
                        "sayi": 1,
                        "sure": 8,
                        "toplamIsYuku": 8
                    }
                ],
                "toplamIsYuku": 125,
                "dersAKTSKredisi": 5,
                "hesaplama": "Dersin AKTS Kredisi = Toplam İş Yükü (Saat) / 25 = 5",
                "aktsHesaplama": "Toplam İş Yükü / 25"
            },
            "programCiktilari": [
                {
                    "id": "PÇ.1",
                    "kategori": "BİLGİ - Kuramsal Olgusal",
                    "aciklama": "TEMEL BİLGİ: Matematik, Fen Bilimleri ve Bilgisayar Mühendisliği konularında yeterli bilgi sahibidir; bu alanlardaki kuramsal ve uygulamalı bilgileri, karmaşık mühendislik problemlerinde kullanır."
                },
                {
                    "id": "PÇ.2",
                    "kategori": "BECERİLER - Bilişsel Uygulamalı",
                    "aciklama": "PROBLEM ÇÖZME: Karmaşık Bilgisayar Mühendisliği problemlerini saptar, tanımlar, formüle eder ve çözer; bu amaca uygun analiz ve modelleme yöntemlerini seçer ve uygular."
                },
                {
                    "id": "PÇ.3",
                    "kategori": "BECERİLER - Bilişsel Uygulamalı",
                    "aciklama": "TASARIM: Karmaşık bir sistemi, süreci, cihazı veya ürünü gerçekçi kısıtlar ve koşullar altında, belirli gereksinimleri karşılayacak şekilde tasarlar; bu amaçla modern tasarım yöntemlerini uygular."
                },
                {
                    "id": "PÇ.4",
                    "kategori": "BECERİLER - Bilişsel Uygulamalı",
                    "aciklama": "TEKNOLOJİ: Bilgisayar Mühendisliği uygulamalarında karşılaşılan karmaşık problemlerin analizi ve çözümü için gerekli olan modern teknik ve araçları geliştirir, seçer ve kullanır; bilişim teknolojilerini etkin bir şekilde kullanır."
                },
                {
                    "id": "PÇ.5",
                    "kategori": "BECERİLER - Bilişsel Uygulamalı",
                    "aciklama": "ARAŞTIRMA: Karmaşık Bilgisayar Mühendisliği problemlerinin veya araştırma konularının incelenmesi için deney tasarlar, deney yapar, veri toplar, sonuçları analiz eder ve yorumlar."
                },
                {
                    "id": "PÇ.6",
                    "kategori": "YETKİNLİKLER - Bağımsız Çalışabilme ve Sorumluluk Alabilme Yetkinliği",
                    "aciklama": "İŞBİRLİĞİ: Bilgisayar Mühendisliği disiplini içinde ve çok disiplinli takımlarda etkin biçimde çalışır; bireysel çalışma sergiler."
                },
                {
                    "id": "PÇ.7",
                    "kategori": "YETKİNLİKLER - Öğrenme Yetkinliği",
                    "aciklama": "GELİŞİM: Yaşam boyu öğrenmenin gerekliliğinin bilincindedir; bilgiye erişir, bilim ve teknolojideki gelişmeleri izler ve kendini sürekli yeniler."
                },
                {
                    "id": "PÇ.8",
                    "kategori": "YETKİNLİKLER - İletişim ve Sosyal Yetkinlik",
                    "aciklama": "İLETİŞİM: Türkçe sözlü ve yazılı etkin iletişim kurar; etkin rapor yazar ve yazılı raporları anlar, tasarım ve üretim raporları hazırlar, etkin sunum yapar, açık ve anlaşılır talimat verir ve alır."
                },
                {
                    "id": "PÇ.9",
                    "kategori": "YETKİNLİKLER - İletişim ve Sosyal Yetkinlik",
                    "aciklama": "TOPLUMSAL BİLİNÇ: Bilgisayar Mühendisliği uygulamalarının evrensel ve toplumsal boyutlarda sağlık, çevre ve güvenlik üzerindeki etkileri ve çağın mühendislik alanına yansıyan sorunları hakkında bilgi sahibidir."
                },
                {
                    "id": "PÇ.10",
                    "kategori": "YETKİNLİKLER - İletişim ve Sosyal Yetkinlik",
                    "aciklama": "ULUSLARARASILIK: Bir yabancı dili kullanarak Bilgisayar Mühendisliği ile ilişkili konularda, bilgi toplar ve meslektaşları ile iletişim kurar."
                },
                {
                    "id": "PÇ.11",
                    "kategori": "YETKİNLİKLER - Alana Özgü Yetkinlik",
                    "aciklama": "ETİK: Etik ilkelerine uygun davranma, mesleki ve etik sorumluluk bilincine sahiptir; mühendislik uygulamalarında kullanılan standartlar hakkında bilgi sahibidir."
                },
                {
                    "id": "PÇ.12",
                    "kategori": "YETKİNLİKLER - Alana Özgü Yetkinlik",
                    "aciklama": "YÖNETİM: Proje yönetimi, risk yönetimi ve değişiklik yönetimi gibi, iş hayatındaki uygulamalar hakkında bilgi sahibidir; girişimcilik, yenilikçilik hakkında bilinçlidir."
                }
            ],
            "programVeOgrenmeIliskisi": {
                "iliskiOlcekleri": "0-5 arası değerler (0: İlişki yok, 5: Çok güçlü ilişki)",
                "iliskiTablosu": [
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.1",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 5,
                            "PÇ.3": 0,
                            "PÇ.4": 0,
                            "PÇ.5": 3,
                            "PÇ.6": 0,
                            "PÇ.7": 0,
                            "PÇ.8": 0,
                            "PÇ.9": 3,
                            "PÇ.10": 0,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.2",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 0,
                            "PÇ.4": 0,
                            "PÇ.5": 0,
                            "PÇ.6": 3,
                            "PÇ.7": 0,
                            "PÇ.8": 0,
                            "PÇ.9": 0,
                            "PÇ.10": 3,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.3",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 3,
                            "PÇ.4": 0,
                            "PÇ.5": 0,
                            "PÇ.6": 0,
                            "PÇ.7": 3,
                            "PÇ.8": 0,
                            "PÇ.9": 0,
                            "PÇ.10": 0,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.4",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 0,
                            "PÇ.4": 3,
                            "PÇ.5": 0,
                            "PÇ.6": 0,
                            "PÇ.7": 0,
                            "PÇ.8": 0,
                            "PÇ.9": 0,
                            "PÇ.10": 0,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.5",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 0,
                            "PÇ.4": 0,
                            "PÇ.5": 3,
                            "PÇ.6": 0,
                            "PÇ.7": 0,
                            "PÇ.8": 0,
                            "PÇ.9": 3,
                            "PÇ.10": 0,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.6",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 0,
                            "PÇ.4": 0,
                            "PÇ.5": 0,
                            "PÇ.6": 3,
                            "PÇ.7": 0,
                            "PÇ.8": 0,
                            "PÇ.9": 0,
                            "PÇ.10": 3,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    },
                    {
                        "ogrenmeÇiktisiID": "ÖÇ.7",
                        "programÇiktilariIliskileri": {
                            "PÇ.1": 0,
                            "PÇ.2": 3,
                            "PÇ.3": 3,
                            "PÇ.4": 0,
                            "PÇ.5": 0,
                            "PÇ.6": 0,
                            "PÇ.7": 3,
                            "PÇ.8": 0,
                            "PÇ.9": 0,
                            "PÇ.10": 0,
                            "PÇ.11": 0,
                            "PÇ.12": 0
                        }
                    }
                ]
            },
            "toplumsalKatkiVeSurdurulebilirlik": {
                "surdurulebilirKalkinmaAmaclari": [
                    { "amac": "Yoksulluğa Son", "secili": false },
                    { "amac": "Açlığa Son", "secili": false },
                    { "amac": "Sağlık ve Kaliteli Yaşam", "secili": false },
                    { "amac": "Nitelikli Eğitim", "secili": true },
                    { "amac": "Toplumsal Cinsiyet Eşitliği", "secili": false },
                    { "amac": "Temiz Su ve Sanitasyon", "secili": false },
                    { "amac": "Erişilebilir ve Temiz Enerji", "secili": false },
                    { "amac": "İnsana Yakışır İş ve Ekonomik Büyüme", "secili": true },
                    { "amac": "Sanayi, Yenilikçilik ve Altyapı", "secili": true },
                    { "amac": "Eşitsizliklerin Azaltılması", "secili": false },
                    { "amac": "Sürdürülebilir Şehirler ve Topluluklar", "secili": false },
                    { "amac": "Sorumlu Üretim ve Tüketim", "secili": true },
                    { "amac": "İklim Eylemi", "secili": false },
                    { "amac": "Sudaki Yaşam", "secili": false },
                    { "amac": "Karasal Yaşam", "secili": false },
                    { "amac": "Barış, Adalet ve Güçlü Kurumlar", "secili": true },
                    { "amac": "Amaçlar İçin Ortaklıklar", "secili": false }
                ],
                "toplumsalKatkiAlanlari": [
                    { "alan": "Eğitim ve Öğretim", "secili": true },
                    { "alan": "Sağlık", "secili": false },
                    { "alan": "Sosyal Hizmetler ve Toplumsal Eşitlik", "secili": false },
                    { "alan": "Çevre ve Sürdürülebilirlik", "secili": true },
                    { "alan": "Teknolojik ve Bilimsel Yenilikler", "secili": true },
                    { "alan": "Ekonomik Kalkınma ve Girişimcilik", "secili": true },
                    { "alan": "Kültürel ve Sanatsal Etkinlikler", "secili": false },
                    { "alan": "Uluslararası İş birliği ve Diplomasi", "secili": false },
                    { "alan": "Toplum yararına yapılacak diğer çalışmalar", "secili": true }
                ]
            },
            "dersSekmeler": {
                "dersGenel": true,
                "dersOgrenmeÇiktilari": true,
                "haftalikDersIcerikleri": true,
                "dersIsYuku": true,
                "dersDegerlendirme": true,
                "programVeOgrenmeÇiktilariIliskisi": true,
                "toplumsalKatkiVeSurdurulebilirlik": true
            },
            "etkinlikTurleri": [
                "Alan Çalışması", "Alan Gezisi", "Ara Sınav", "Ara Sınav İçin Bireysel Çalışma",
                "Beyin Fırtınası", "Bireysel Çalışma", "Bütünleme Sınavı", "Deney", "Deney Sonrası Quiz",
                "Derse Katılım", "Ev Ödevi", "Final Sınavı", "Final Sınavı İçin Bireysel Çalışma",
                "Gösterme", "Gözlem", "Laboratuvar", "Laboratuvar Ara Sınavı", "Laboratuvar Sınavı",
                "Makale Kritik Etme", "Makale Yazma", "Multirom CD Çalışması", "Ödev Problemleri İçin Çalışma",
                "Okuma", "Örnek Vaka İncelemesi", "Performans", "Problem Çözümü", "Proje Hazırlama",
                "Proje Sunma", "Proje Tasarımı/Yönetimi", "Quiz", "Quiz İçin Bireysel Çalışma",
                "Rapor", "Rapor Hazırlama", "Rapor Sunma", "Rehberli Problem Çözümü",
                "Rol Oynama / Dramatizasyon", "Seminer", "Soru-Yanıt", "Sözlü Sınav",
                "Takım/Grup Çalışması", "Tartışma", "Toplantı Başkanlığı Yapma", "Uygulama/Pratik"
            ],
            "yariyilIciOlasiEtkinlikler": [
                "Ara Sınav", "Laboratuvar Sınavı", "Deney", "Deney Sonrası Quiz", "Performans",
                "Quiz", "Rapor", "Rapor Sunma", "Makale Kritik Etme", "Makale Yazma",
                "Proje Hazırlama", "Proje Sunma", "Rehberli Problem Çözümü", "Seminer",
                "Sözlü Sınav", "Ödev Problemleri İçin Çalışma", "Proje Tasarımı/Yönetimi"
            ],
            "yariyilSonuOlasiEtkinlikler": [
                "Final Sınavı", "Laboratuvar Ara Sınavı", "Makale Yazma", "Proje Hazırlama",
                "Proje Sunma", "Proje Tasarımı/Yönetimi", "Quiz", "Rapor", "Rapor Hazırlama",
                "Rapor Sunma", "Seminer", "Sözlü Sınav", "Gözlem"
            ],
            "denetimBilgileri": {
                "olusturmaTarihi": new Date().toISOString().split('T')[0] + ' ' + new Date().toTimeString().split(' ')[0],
                "olusturan": "test_data_generator",
                "sonGuncellenmeTarihi": new Date().toISOString().split('T')[0] + ' ' + new Date().toTimeString().split(' ')[0],
                "guncelleyen": "test_data_generator",
                "durum": "Test"
            },
            "numaralandirmaDegerleri": {
                "dersTurleri": ["Zorunlu", "Seçmeli"],
                "dersSeviyesi": ["Lisans", "Yüksek Lisans", "Doktora"],
                "ogretimSistemi": ["Birinci Öğretim", "İkinci Öğretim", "Uzaktan Öğretim"],
                "egitimDili": ["Türkçe", "İngilizce"],
                "stajDurumu": ["Mevcut Değil", "Mevcut", "Zorunlu", "Seçmeli"],
                "dokumanDurumu": ["Taslak", "Onaylandı", "Yayınlandı", "Revize Edildi"]
            }
        };
        
        // Öğrenci notları objesi oluştur
        testStudents.forEach(student => {
            testCourseData.ogrenciNotlari[student.ogrenciNo] = {};
        });
        
        // JSON'u sisteme yükle (applyJsonData fonksiyonunu kullan)
        const jsonString = JSON.stringify(testCourseData, null, 2);
        
        // JSON içeriğini textarea'ya yerleştir
        const jsonContent = document.getElementById('jsonContent');
        if (jsonContent) {
            jsonContent.value = jsonString;
        }
        
        // JSON'u otomatik olarak uygula
        APP_STATE.courseData = testCourseData;
        APP_STATE.jsonFileName = `test-ce100-algorithms-programming-ii-${Date.now()}.json`;
        
        // Öğrenme çıktıları ve program çıktılarını APP_STATE'e ata
        APP_STATE.learningOutcomes = testCourseData.dersOgrenmeÇiktilari || [];
        APP_STATE.programOutcomes = testCourseData.programCiktilari || [];
        APP_STATE.outcomeMatrix = testCourseData.programVeOgrenmeIliskisi || null;
        
        // Verileri işle
        importStudentData(testCourseData);
        createAssessmentTreeFromCourseData();
        
        // UI'ları güncelle
        renderTree();
        renderOutcomes();
        renderProgramOutcomes();
        renderCourseDetails();
        renderOutcomeMatrix();
        updateCourseInfo();
        updateAssessmentView();
        updateCategoryWeights();
        updateStudentTable();
        // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
        updateGroupSelectors();
        updateTreeMappingControls();
        
        showModernToast(`Gerçek MUDEK uyumlu test ders datası oluşturuldu: CE100 - Algorithms And Programming II (${numStudents} öğrenci)`, "success");
        
    } catch (error) {
        console.error("Test ders datası oluşturulurken hata:", error);
        showModernToast("Test ders datası oluşturulamadı!", "error");
    }
}

/**
 * Bileşen için kağıt sırası bazında giriş bölümü oluşturma
 * @param {Object} activity - Ana aktivite
 * @param {HTMLElement} container - Konteyner elementi
 */
function createComponentPaperOrderInputSection(activity, container) {
    try {
        const componentId = activity.id;
        const allQuestions = activity.children || [];
        const maxQuestions = allQuestions.length;
        
        // Grup seçeneklerini güvenli şekilde oluştur
        const groups = (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari && APP_STATE.courseData.grupHaritalari[componentId]) 
            ? APP_STATE.courseData.grupHaritalari[componentId].gruplar || ['A']
            : ['A'];
        
        // Grup sistemi her zaman kullanılır (tek grup olsa bile)
        const useGroupSystem = true;
        
        // Kağıt sırası bazında bölümler oluştur
        for (let paperOrder = 1; paperOrder <= maxQuestions; paperOrder++) {
            const paperSection = document.createElement('div');
            paperSection.className = 'paper-order-section';
            
            const paperHeader = document.createElement('h6');
            paperHeader.innerHTML = `Kağıt Sırası ${paperOrder}`;
            paperHeader.className = 'paper-order-header';
            paperSection.appendChild(paperHeader);
            
            const table = document.createElement('table');
            table.className = 'assessment-table paper-order-table';
            
            const tableHTML = `
                <thead>
                    <tr>
                                            <th>No</th>
                    <th>Öğrenci No</th>
                    <th>Adı</th>
                    <th>Soyadı</th>
                    <th>E-posta</th>
                    ${useGroupSystem ? '<th>Grup</th>' : ''}
                    ${useGroupSystem ? '<th>Cevap Anahtarı Sırası</th>' : ''}
                    ${useGroupSystem ? '<th>Etkinlik Adı<br/><small>(Soru/Rubrik)</small></th>' : ''}
                    ${useGroupSystem ? '<th>Açıklama</th>' : ''}
                    <th>Etkinlik Max. Puan<br/><small>(Soru/Rubrik)</small></th>
                    <th>Toplam Puan</th>
                    ${useGroupSystem ? '<th>ÖÇ</th>' : ''}
                    <th>Alınan Puan<br/><small>(Etkinlik Puanı)</small></th>
                    <th>Yarıyıl İçi<br/><small>(${getTermWeight()}%)</small></th>
                    <th>Yarıyıl Sonu<br/><small>(${getFinalWeight()}%)</small></th>
                    <th>Ortalama</th>
                    <th>Harf Notu</th>
                    </tr>
                </thead>
                <tbody>
                    ${APP_STATE.studentData.map((student, index) => {
                        const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                        console.log(`🔍 Kağıt sırası ${paperOrder} - ${componentId} için öğrenci ${student.studentId}: gruplar=${groups.join(',')}, mevcut=${studentCurrentGroup}`);
                        const groupOptions = groups.map(groupId => 
                            `<option value="${groupId}" ${studentCurrentGroup === groupId ? 'selected' : ''}>${groupId}</option>`
                        ).join('');
                        
                        // Bu kağıt sırasındaki sorunun gerçek ID'sini bul
                        const actualQuestionId = getQuestionIdByPaperOrder(student.studentId, paperOrder, componentId);
                        const actualQuestion = findNodeById(actualQuestionId);
                        
                        // Cevap anahtarındaki sırayı bul
                        const answerKeyOrder = getAnswerKeyOrder(student.studentId, paperOrder, componentId);
                        
                        // Etkinlik bilgilerini al
                        const activityName = actualQuestion?.name || `Etkinlik ${answerKeyOrder || paperOrder}`;
                        const questionDescription = actualQuestion?.description || actualQuestion?.name || '-';
                        // DÜZELTME: actualQuestionId zaten grup bazlı doğru soru, direkt puanını kullan
                        const maxPoints = actualQuestion?.points || 0;
                        const studentOutcomes = getQuestionOutcomesForStudent(student.studentId, actualQuestionId, componentId);
                        
                        // DEBUG: Tablo oluşturma sorunları için
                        if (paperOrder === 1 && index < 3) {
                            console.log(`🔍 DÜZELTME SONRASI - Öğrenci: ${student.studentId}, Grup: ${studentCurrentGroup}, PaperOrder: ${paperOrder}`);
                            console.log(`  - actualQuestionId: ${actualQuestionId}`);
                            console.log(`  - actualQuestion?.points: ${actualQuestion?.points}`);
                            console.log(`  - maxPoints: ${maxPoints}`);
                        }
                        
                        return `
                            <tr data-student-id="${student.studentId}" data-paper-order="${paperOrder}" data-component-id="${componentId}">
                                <td>${index + 1}</td>
                                <td>${student.studentId}</td>
                                <td>${student.name}</td>
                                <td>${student.surname}</td>
                                <td class="email-cell">
                                    <span class="email-text" title="${student.email || 'E-posta bulunamadı'}">${student.email || '-'}</span>
                                    ${student.email ? `<button class="email-button" title="E-posta gönder" onclick="openEmailModal({studentId: '${student.studentId}', name: '${student.name}', surname: '${student.surname}', email: '${student.email}'})">E-posta</button>` : ''}
                                </td>
                                ${useGroupSystem ? `
                                <td>
                                    <select class="group-selector compact" data-student-id="${student.studentId}" data-component-id="${componentId}" onchange="updateStudentGroupForComponent(this)">
                                        ${groupOptions}
                                    </select>
                                </td>` : ''}
                                ${useGroupSystem ? `
                                <td class="answer-key-order-cell">
                                    <span class="answer-key-badge" data-answer-key="${answerKeyOrder}" data-question-id="${actualQuestionId}">
                                        ${answerKeyOrder}
                                    </span>
                                </td>` : ''}
                                ${useGroupSystem ? `
                                <td class="question-name-cell">
                                    <span class="question-name-badge">${activityName}</span>
                                </td>` : ''}
                                ${useGroupSystem ? `
                                <td class="question-description-cell">
                                    <span class="question-desc-badge" title="${questionDescription}">${questionDescription}</span>
                                </td>` : ''}
                                <td class="question-points-cell" data-student-id="${student.studentId}" data-activity-id="${actualQuestionId}">
                                    ${maxPoints}
                                </td>
                                <td class="total-points-cell" data-student-id="${student.studentId}" data-component-id="${componentId}">
                                    ${getStudentTotalEarnedPointsForComponent(student.studentId, componentId)}
                                </td>
                                ${useGroupSystem ? `
                                <td class="outcomes-cell">
                                    <span class="outcomes-badge">${Array.isArray(studentOutcomes) ? studentOutcomes.join(', ') : (studentOutcomes || '-')}</span>
                                </td>` : ''}
                                <td>
                                    <input type="number" min="0" max="${maxPoints}" 
                                        data-student-id="${student.studentId}" 
                                        data-activity-id="${actualQuestionId}"
                                        data-paper-order="${paperOrder}"
                                        value="${getStudentGrade(student.studentId, actualQuestionId) || ''}"
                                        onchange="updateStudentGrade(this)"
                                        placeholder="0-${maxPoints}"
                                        title="${useGroupSystem ? `Kağıt sırası: ${paperOrder}, Cevap anahtarı: ${answerKeyOrder}, Maksimum puan: ${maxPoints}` : `Maksimum puan: ${maxPoints}`}"
                                    >
                                </td>
                                <td class="grade-summary-cell term-grade">${calculateStudentGrades(student.studentId).termGrade}</td>
                                <td class="grade-summary-cell final-grade">${calculateStudentGrades(student.studentId).finalGrade}</td>
                                <td class="grade-summary-cell total-grade">${calculateStudentGrades(student.studentId).totalGrade}</td>
                                <td class="grade-summary-cell letter-grade ${getLetterGradeClass(calculateStudentGrades(student.studentId).letterGrade)}">${calculateStudentGrades(student.studentId).letterGrade}</td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            `;
            
            table.innerHTML = tableHTML;
            paperSection.appendChild(table);
            container.appendChild(paperSection);
        }
        
        // DÜZELTME: Tablo oluşturulduktan sonra tüm satırları güncelle
        // Bu, grup bazlı maksimum puan gösterimini düzeltir
        setTimeout(() => {
            console.log('🔄 Tablo oluşturma sonrası grup bazlı güncelleme başlatılıyor...');
            APP_STATE.studentData.forEach(student => {
                const studentCurrentGroup = getStudentGroupForComponent(student.studentId, componentId);
                updateQuestionInfoForComponent(student.studentId, studentCurrentGroup, componentId);
            });
            console.log('✅ Grup bazlı güncelleme tamamlandı');
        }, 100);
        
    } catch (error) {
        console.error("Bileşen kağıt sırası giriş bölümü oluşturulurken hata oluştu:", error);
    }
}

/**
 * Öğrencinin grubuna göre belirli bir sorunun öğrenme çıktılarını getir
 * @param {string} studentId - Öğrenci ID'si
 * @param {string} questionId - Soru ID'si
 * @param {string} componentId - Bileşen ID'si
 * @returns {Array} - Öğrenme çıktıları
 */
function getQuestionOutcomesForStudent(studentId, questionId, componentId) {
    // Debug: getQuestionOutcomesForStudent çağrıldı
    
    try {
        if (!questionId) {
            return [];
        }
        
        const question = findNodeById(questionId);
        
        if (!question) {
            return [];
        }
        
        if (!question.outcomes || question.outcomes.length === 0) {
            return [];
        }
        
        return question.outcomes || [];
    } catch (error) {
        console.error("Soru öğrenme çıktıları alınırken hata:", error);
        return [];
    }
}

/**
 * Kağıt sırasına göre gerçek soru ID'sini bulma
 * @param {string} studentId - Öğrenci ID'si
 * @param {number} paperOrder - Kağıttaki sıra (1, 2, 3...)
 * @param {string} componentId - Bileşen ID'si
 * @returns {string} - Gerçek soru ID'si
 */
function getQuestionIdByPaperOrder(studentId, paperOrder, componentId) {
    try {
        const studentGroup = getStudentGroupForComponent(studentId, componentId);
        const parentNode = findNodeById(componentId);
        
        if (!parentNode || !parentNode.children) {
            return null;
        }
        
        // Grup haritası var mı kontrol et
        const groupMappings = APP_STATE.courseData?.grupHaritalari?.[componentId]?.haritalar?.[studentGroup];
        
        if (groupMappings) {
            // Grup haritasına göre kağıt sırasından gerçek soru ID'sini bul
            // Format 1: {position: questionId} - Yeni format
            if (groupMappings[paperOrder.toString()]) {
                return groupMappings[paperOrder.toString()];
            }
            // Format 2: {questionId: position} - Eski format desteği
            for (const [questionId, position] of Object.entries(groupMappings)) {
                if (parseInt(position) === paperOrder) {
                    return questionId;
                }
            }
        }
        
        // Grup haritası yoksa, varsayılan sıralama
        if (parentNode.children[paperOrder - 1]) {
            return parentNode.children[paperOrder - 1].id;
        }
        
        return null;
    } catch (error) {
        console.error("Kağıt sırasından soru ID'si bulunamadı:", error);
        return null;
    }
}

/**
 * Kağıt sırasından cevap anahtarındaki sırayı bulma
 * @param {string} studentId - Öğrenci ID'si
 * @param {number} paperOrder - Kağıttaki sıra (1, 2, 3...)
 * @param {string} componentId - Bileşen ID'si
 * @returns {string} - Cevap anahtarındaki sıra
 */
function getAnswerKeyOrder(studentId, paperOrder, componentId) {
    try {
        const actualQuestionId = getQuestionIdByPaperOrder(studentId, paperOrder, componentId);
        
        if (!actualQuestionId) {
            return `A1.${paperOrder}`;
        }
        
        // Soru ID'sini doğrudan cevap anahtarı sırası olarak döndür
        // Örneğin A1.1 -> "A1.1", A1.2 -> "A1.2"
        return actualQuestionId;
    } catch (error) {
        console.error("Cevap anahtarı sırası bulunamadı:", error);
        return `A1.${paperOrder}`;
    }
}

// Test fonksiyonlarını global hale getir
window.generateRandomAssessment = generateRandomAssessment;
window.generateRandomGroups = generateRandomGroups;
window.generateRandomScores = generateRandomScores;
window.generateTestStudents = generateTestStudents;
window.generateFullTestData = generateFullTestData;
window.clearAllTestData = clearAllTestData;
window.generateTestCourseData = generateTestCourseData;

// Test butonlarına event listener ekle
document.addEventListener('DOMContentLoaded', function() {
    // Test işlemleri butonları
    const testButtons = [
        { id: 'btnGenerateRandomTermAssessment', func: generateMultipleRandomTermAssessments },
        { id: 'btnGenerateRandomFinalAssessment', func: generateMultipleRandomFinalAssessments },
        { id: 'btnGenerateRandomGroups', func: generateRandomGroups },
        { id: 'btnGenerateIntelligentScores', func: generateIntelligentScores },
        { id: 'btnGenerateTestStudents', func: generateTestStudents },

        { id: 'btnGenerateTestCourseData', func: generateTestCourseData },
        { id: 'btnClearAllTestData', func: clearAllTestData },
        // Yeni temizleme butonları
        { id: 'btnClearAssessments', func: clearAssessments },
        { id: 'btnClearGroups', func: clearGroups },
        { id: 'btnClearScores', func: clearScores },
        { id: 'btnClearStudents', func: clearAllStudents },
        { id: 'btnResetSystem', func: resetCompleteSystem }
    ];
    
    testButtons.forEach(button => {
        const element = document.getElementById(button.id);
        if (element) {
            element.addEventListener('click', function() {
                console.log(`Test işlemi başlatıldı: ${button.id}`);
                
                // Loading durumu ekle
                element.classList.add('loading');
                element.disabled = true;
                
                try {
                    // Fonksiyonu çağır
                    const result = button.func();
                    
                    // Promise ise bekle
                    if (result && typeof result.then === 'function') {
                        result.finally(() => {
                            element.classList.remove('loading');
                            element.disabled = false;
                        });
                    } else {
                        // Kısa bir gecikme sonra loading'i kaldır
                        setTimeout(() => {
                            element.classList.remove('loading');
                            element.disabled = false;
                        }, 500);
                    }
                } catch (error) {
                    console.error(`Test işlemi hatası (${button.id}):`, error);
                    element.classList.remove('loading');
                    element.disabled = false;
                    showModernToast(`Test işlemi başarısız: ${error.message}`, "error");
                }
            });
        } else {
            console.warn(`Test butonu bulunamadı: ${button.id}`);
        }
    });
    
    console.log('Test işlemleri butonları başarıyla yüklendi!');
    
    // Rastgele değerlendirme slider kontrollerini başlat (akıllı puanlama dahil)
    initializeAssessmentSliders();
    
    // Akıllı puanlama kontrollerini başlat
    initializeSmartScoringControls();
    
    // Grup istatistiklerini başlat
    updateGroupStatistics();
    
    // Öğrenci filtresini başlat
    initializeAssessmentStudentFilter();
    
    // Öğrenci sayılarını başlangıçta güncelle
    updatePassFailCounts();
});

// =====================================================
// AKILLI PUANLAMA KONTROLLERİ
// =====================================================

/**
 * Akıllı puanlama kontrol elemanlarını başlatır
 */
function initializeSmartScoringControls() {
    console.log('🔍 Akıllı puanlama kontrolleri başlatılıyor...');
    
    const passRateSlider = document.getElementById('passRateSlider');
    const passRateValue = document.getElementById('passRateValue');
    const failRateDisplay = document.getElementById('failRateDisplay');
    const passRateDisplay = document.getElementById('passRateDisplay');
    
    // Debug logları
    console.log('passRateSlider:', passRateSlider ? '✅ Bulundu' : '❌ Bulunamadı');
    console.log('passRateValue:', passRateValue ? '✅ Bulundu' : '❌ Bulunamadı');
    console.log('failRateDisplay:', failRateDisplay ? '✅ Bulundu' : '❌ Bulunamadı');
    console.log('passRateDisplay:', passRateDisplay ? '✅ Bulundu' : '❌ Bulunamadı');
    
    if (passRateSlider && passRateValue && failRateDisplay && passRateDisplay) {
        // Slider değişim event'i
        passRateSlider.addEventListener('input', function() {
            const passRate = parseInt(this.value);
            const failRate = 100 - passRate;
            
            // Değerleri güncelle
            passRateValue.textContent = passRate + '%';
            passRateDisplay.textContent = passRate + '%';
            failRateDisplay.textContent = failRate + '%';
            
            // Öğrenci sayısını güncelle
            updateStudentCounts(passRate);
            
            // Slider renk geçişini güncelle
            updateSliderGradient(this, passRate);
        });
        
        // Başlangıç değerini ayarla
        const initialValue = parseInt(passRateSlider.value);
        updateSliderGradient(passRateSlider, initialValue);
        updateStudentCounts(initialValue);
        
        console.log('🎯 Akıllı puanlama kontrolleri başarıyla başlatıldı');
    } else {
        console.warn('⚠️ Akıllı puanlama kontrollerinin bazı elemanları bulunamadı');
    }
}

/**
 * Öğrenci sayı bilgilerini günceller
 * @param {number} passRate - Geçen öğrenci oranı
 */
function updateStudentCounts(passRate) {
    // Genel updatePassFailCounts fonksiyonunu kullan
    updatePassFailCounts();
    
    // Fail rate display'i de güncelle
    const failRateDisplay = document.getElementById('failRateDisplay');
    if (failRateDisplay) {
        failRateDisplay.textContent = (100 - passRate) + '%';
    }
}

/**
 * Slider'ın renk geçişini günceller
 * @param {HTMLElement} slider - Slider elementi
 * @param {number} passRate - Geçen öğrenci oranı
 */
function updateSliderGradient(slider, passRate) {
    // 0-100 aralığında yüzde hesaplama
    const percentage = passRate;
    
    // Dinamik renk hesaplama - 0'dan başlayacak şekilde güncellendi
    let gradientColor;
    if (passRate <= 10) {
        gradientColor = '#8b0000'; // Koyu kırmızı - hepsi kalıyor
    } else if (passRate < 30) {
        gradientColor = '#e74c3c'; // Kırmızı - çok düşük
    } else if (passRate < 50) {
        gradientColor = '#f39c12'; // Turuncu - düşük
    } else if (passRate < 70) {
        gradientColor = '#f1c40f'; // Sarı - orta
    } else if (passRate < 85) {
        gradientColor = '#27ae60'; // Yeşil - iyi
    } else {
        gradientColor = '#2980b9'; // Mavi - mükemmel
    }
    
    // CSS özelliğini güncelle - 0'dan başlayan gradient
    slider.style.background = `linear-gradient(90deg, #8b0000 0%, #e74c3c 15%, #f39c12 35%, #f1c40f 55%, #27ae60 75%, #2980b9 100%)`;
}

// =====================================================
// ÖÇ TOOLTIP SİSTEMİ
// =====================================================

/**
 * ÖÇ Badge'lerine tooltip sistemi ekler ve tıklama fonksiyonunu ayarlar
 */
function initializeOutcomeTooltips() {
    // Mevcut tooltip'leri temizle
    document.querySelectorAll('.outcome-tooltip').forEach(tooltip => tooltip.remove());
    
    // Tüm outcomes badge'lerini bul
    document.querySelectorAll('.outcomes-badge').forEach(badge => {
        const outcomeCodes = badge.textContent.trim().split(',').map(code => code.trim()).filter(code => code && code !== '-');
        
        // Çok fazla ÖÇ varsa (3'ten fazla) tıklanabilir yap
        if (outcomeCodes.length > 3) {
            badge.classList.add('clickable', 'many-outcomes');
            badge.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showOutcomeDetailModal(outcomeCodes);
            });
            // Çok ÖÇ olan badge'lerde tooltip yerine sadece basit bilgi
            badge.title = `${outcomeCodes.length} öğrenme çıktısı - Detaylar için tıklayın`;
        } else {
            // Az ÖÇ olan badge'lerde normal tooltip
        badge.addEventListener('mouseenter', showOutcomeTooltip);
        badge.addEventListener('mouseleave', hideOutcomeTooltip);
        }
    });
}

/**
 * ÖÇ tooltip'ini gösterir
 * @param {Event} event - Mouse event
 */
function showOutcomeTooltip(event) {
    const badge = event.target;
    const outcomeCodes = badge.textContent.trim().split(',').map(code => code.trim()).filter(code => code && code !== '-');
    
    if (outcomeCodes.length === 0) return;
    
    // Tooltip oluştur
    const tooltip = document.createElement('div');
    tooltip.className = 'outcome-tooltip';
    
    let tooltipContent = '';
    
    outcomeCodes.forEach((code, index) => {
        const outcome = getOutcomeInfo(code);
        const relations = getProgramOutcomeRelations(code);
        
        if (index > 0) tooltipContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #455a64;">';
        
        tooltipContent += `
            <div class="outcome-tooltip-content">
                <div class="outcome-tooltip-title">${code}</div>
                <div class="outcome-tooltip-description">${outcome.description || 'Açıklama bulunamadı'}</div>
                ${relations.length > 0 ? `
                    <div class="outcome-tooltip-relations">
                        <strong style="color: #81c784;">Program Çıktısı İlişkileri:</strong><br>
                        ${relations.map(rel => `
                            <div class="outcome-relation">
                                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                                    <span style="color: #4fc3f7; font-weight: bold;">${code}</span>
                                    <span class="outcome-relation-arrow">→</span>
                                    <span class="relation-level-${rel.level}">${rel.level}</span>
                                    <span class="outcome-relation-arrow">→</span>
                                    <span class="program-outcome-badge">${rel.programOutcome}</span>
                                    <span class="outcome-relation-level">${getRelationLevelText(rel.level)}</span>
                                </div>
                                ${rel.description ? `
                                    <div style="color: #b0bec5; font-size: 11px; margin-left: 8px; line-height: 1.3; padding: 2px 0;">
                                        <strong>${rel.programOutcome}:</strong> ${rel.description}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    });
    
    tooltip.innerHTML = tooltipContent;
    document.body.appendChild(tooltip);
    
    // Tooltip pozisyonunu ayarla
    positionTooltip(tooltip, badge);
    
    // Tooltip'i göster
    setTimeout(() => {
        tooltip.classList.add('show');
    }, 10);
}

/**
 * ÖÇ tooltip'ini gizler
 */
function hideOutcomeTooltip() {
    document.querySelectorAll('.outcome-tooltip').forEach(tooltip => {
        tooltip.classList.remove('show');
        setTimeout(() => {
            tooltip.remove();
        }, 200);
    });
}

/**
 * Tooltip pozisyonunu ayarlar (fixed positioning ile)
 * @param {HTMLElement} tooltip - Tooltip elementi
 * @param {HTMLElement} badge - Badge elementi
 */
function positionTooltip(tooltip, badge) {
    const badgeRect = badge.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    
    // İlk olarak tooltip'i gösterip boyutunu ölçelim
    tooltip.style.visibility = 'hidden';
    tooltip.style.display = 'block';
    const tooltipRect = tooltip.getBoundingClientRect();
    tooltip.style.visibility = 'visible';
    
    // Tooltip pozisyonunu hesapla (badge'in ortasından)
    let left = badgeRect.left + (badgeRect.width / 2) - (tooltipRect.width / 2);
    let top = badgeRect.bottom + 8;
    
    // Sağ taraftan taşma kontrolü
    if (left + tooltipRect.width > viewportWidth - 15) {
        left = viewportWidth - tooltipRect.width - 15;
    }
    
    // Sol taraftan taşma kontrolü
    if (left < 15) {
        left = 15;
    }
    
    // Alt taraftan taşma kontrolü - tooltip'i yukarı taşı
    if (top + tooltipRect.height > viewportHeight - 15) {
        top = badgeRect.top - tooltipRect.height - 8;
    }
    
    // Üst taraftan taşma kontrolü
    if (top < 15) {
        top = badgeRect.bottom + 8;
    }
    
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
}

/**
 * ÖÇ bilgilerini getirir
 * @param {string} outcomeCode - ÖÇ kodu
 * @returns {Object} - ÖÇ bilgileri
 */
function getOutcomeInfo(outcomeCode) {
    if (APP_STATE.learningOutcomes) {
        const outcome = APP_STATE.learningOutcomes.find(o => o.id === outcomeCode || o.kod === outcomeCode);
        if (outcome) {
            return {
                code: outcome.id || outcome.kod,
                description: outcome.aciklama || outcome.açıklama || outcome.description
            };
        }
    }
    
    return {
        code: outcomeCode,
        description: 'Açıklama bulunamadı'
    };
}

/**
 * Program çıktısı ilişkilerini getirir
 * @param {string} outcomeCode - ÖÇ kodu
 * @returns {Array} - Program çıktısı ilişkileri
 */
function getProgramOutcomeRelations(outcomeCode) {
    const relations = [];
    
    if (APP_STATE.outcomeMatrix && APP_STATE.outcomeMatrix.iliskiTablosu && APP_STATE.programOutcomes) {
        const relation = APP_STATE.outcomeMatrix.iliskiTablosu.find(r => r.ogrenmeÇiktisiID === outcomeCode);
        
        if (relation && relation.programÇiktilariIliskileri) {
            APP_STATE.programOutcomes.forEach(po => {
                const level = relation.programÇiktilariIliskileri[po.id];
                if (level && level > 0) {
                    relations.push({
                        programOutcome: po.id,
                        level: level,
                        description: po.aciklama || po.açıklama || po.description
                    });
                }
            });
        }
    }
    
    return relations.sort((a, b) => b.level - a.level); // Seviyeye göre azalan sıralama
}

/**
 * ÖÇ detay modalını gösterir
 * @param {Array} outcomeCodes - ÖÇ kodları
 */
function showOutcomeDetailModal(outcomeCodes) {
    const modal = document.getElementById('outcomeDetailModal');
    const container = document.getElementById('outcomeDetailContainer');
    
    if (!modal || !container) return;
    
    // Modal içeriğini oluştur
    let modalContent = '';
    
    outcomeCodes.forEach((code, index) => {
        const outcome = getOutcomeInfo(code);
        const relations = getProgramOutcomeRelations(code);
        
        modalContent += `
            <div class="outcome-detail-item">
                <div class="outcome-detail-header">
                    <span class="outcome-detail-code">${code}</span>
                    <h4 class="outcome-detail-title">Öğrenme Çıktısı ${index + 1}</h4>
                </div>
                <div class="outcome-detail-description">
                    ${outcome.description || 'Açıklama bulunamadı'}
                </div>
                ${relations.length > 0 ? `
                    <div class="outcome-detail-relations">
                        <h5>🎯 Program Çıktısı İlişkileri</h5>
                        <div class="outcome-relation-list">
                            ${relations.map(rel => `
                                <div class="outcome-relation-item">
                                    <span class="program-outcome-code">${rel.programOutcome}</span>
                                    <span class="relation-arrow">→</span>
                                    <span class="relation-level-badge level-${rel.level}">${rel.level}</span>
                                    <span>${getRelationLevelText(rel.level)}</span>
                                </div>
                                ${rel.description ? `
                                    <div class="relation-description">
                                        <strong>${rel.programOutcome}:</strong> ${rel.description}
                                    </div>
                                ` : ''}
                            `).join('')}
                        </div>
                    </div>
                ` : '<div class="outcome-detail-relations"><p style="color: #666; font-style: italic;">Program çıktısı ilişkisi bulunamadı</p></div>'}
            </div>
        `;
    });
    
    container.innerHTML = modalContent;
    
    // Modal'ı aç
    openModernModal('outcomeDetailModal');
}

/**
 * İlişki seviyesi metnini döndürür
 * @param {number} level - İlişki seviyesi
 * @returns {string} - İlişki seviyesi metni
 */
function getRelationLevelText(level) {
    const levelTexts = {
        0: 'İlişki Yok',
        1: 'Çok Zayıf',
        2: 'Zayıf', 
        3: 'Orta',
        4: 'Güçlü',
        5: 'Çok Güçlü'
    };
    return levelTexts[level] || 'Bilinmiyor';
}

/**
 * Öğrenci için detaylı e-posta içeriği oluşturur
 * @param {string} studentId - Öğrenci ID'si
 * @returns {Object} - E-posta konusu ve içeriği
 */
function generateDetailedEmailContent(studentId) {
    try {
        // Öğrenci bilgilerini bul - id ve studentId her ikisini de kontrol et
        const student = APP_STATE.studentData.find(s => s.id === studentId || s.studentId === studentId);
        if (!student) {
            console.warn('Öğrenci bulunamadı:', studentId);
            return { 
                subject: 'Ders Not Durumu', 
                body: 'Öğrenci bilgileri yüklenirken bir hata oluştu. Lütfen tekrar deneyiniz.' 
            };
        }

        // Not hesaplama
        const grades = calculateStudentGrades(studentId);
        
        // Kurs bilgileri
        const courseInfo = APP_STATE.courseData || {};
        const courseName = courseInfo.dersBilgisi?.dersAdi || courseInfo.dersGenel?.dersAdi || 'Ders Adı Bulunamadı';
        const courseTerm = courseInfo.dersBilgisi?.donem || courseInfo.dersGenel?.akademikYil || 'Dönem Bilgisi Yok';
        const instructor = courseInfo.dersBilgisi?.ogretimUyesi || courseInfo.dersIcerik?.dersiVerenOgretimUyesiOgretimGorevlisi || 'Öğretim Üyesi';
        
        // E-posta konusu
        const subject = `${courseName} - Ders Not Durumu - ${student.name} ${student.surname}`;
        
        // Geçme notu (genellikle 60 veya DD)
        const passingGrade = 60;
        const isPassing = grades.totalGrade >= passingGrade;
        
        // Detaylı notlar listesi
        let detailedScores = '';
        
        // Assessment tree'den etkinlik detaylarını al
        if (APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0) {
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            
            // Yarıyıl içi etkinlikler
            if (termActivities.length > 0) {
                detailedScores += `
                <div class="activity-category">
                    <h4>📋 Yarıyıl İçi Etkinlikler</h4>`;
                
                termActivities.forEach(activity => {
                    const activityScore = getStudentActivityScore(studentId, activity.id);
                    const maxScore = getActivityMaxScore(activity.id);
                    const displayName = getComponentDisplayName(activity.id);
                    const percentage = maxScore > 0 ? ((activityScore / maxScore) * 100).toFixed(2) : '0.0';
                    
                    detailedScores += `
                    <div class="activity-item">
                        <div class="activity-name">${displayName}</div>
                        <div class="activity-score">
                            <span class="score-value">${activityScore.toFixed(2)}/${maxScore}</span>
                            <span class="score-percentage">%${percentage}</span>
                        </div>
                    </div>`;
                });
                
                detailedScores += `</div>`;
            }
            
            // Yarıyıl sonu etkinlikler
            if (finalActivities.length > 0) {
                detailedScores += `
                <div class="activity-category">
                    <h4>📝 Yarıyıl Sonu Etkinlikler</h4>`;
                
                finalActivities.forEach(activity => {
                    const activityScore = getStudentActivityScore(studentId, activity.id);
                    const maxScore = getActivityMaxScore(activity.id);
                    const displayName = getComponentDisplayName(activity.id);
                    const percentage = maxScore > 0 ? ((activityScore / maxScore) * 100).toFixed(2) : '0.0';
                    
                    detailedScores += `
                    <div class="activity-item">
                        <div class="activity-name">${displayName}</div>
                        <div class="activity-score">
                            <span class="score-value">${activityScore.toFixed(2)}/${maxScore}</span>
                            <span class="score-percentage">%${percentage}</span>
                        </div>
                    </div>`;
                });
                
                detailedScores += `</div>`;
            }
        }
        
        // Text tabanlı e-posta içeriği - sembollerle görselleştirilmiş
        let termActivitiesText = '';
        let finalActivitiesText = '';
        
        // Assessment tree'den etkinlik detaylarını al
        if (APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0) {
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            
            // Yarıyıl içi etkinlikler
            if (termActivities.length > 0) {
                termActivitiesText = termActivities.map(activity => {
                    const activityScore = getStudentActivityScore(studentId, activity.id);
                    const maxScore = getActivityMaxScore(activity.id);
                    const displayName = getComponentDisplayName(activity.id);
                    const percentage = maxScore > 0 ? ((activityScore / maxScore) * 100).toFixed(2) : '0.0';
                    
                    return `- ${displayName}: ${activityScore.toFixed(2)}/${maxScore} (%${percentage})`;
                }).join('\n');
            }
            
            // Yarıyıl sonu etkinlikler
            if (finalActivities.length > 0) {
                finalActivitiesText = finalActivities.map(activity => {
                    const activityScore = getStudentActivityScore(studentId, activity.id);
                    const maxScore = getActivityMaxScore(activity.id);
                    const displayName = getComponentDisplayName(activity.id);
                    const percentage = maxScore > 0 ? ((activityScore / maxScore) * 100).toFixed(2) : '0.0';
                    
                    return `- ${displayName}: ${activityScore.toFixed(2)}/${maxScore} (%${percentage})`;
                }).join('\n');
            }
        }
        
        const body = `==================================================
              DERS NOT DURUMU
              ${courseName}
                ${courseTerm}
==================================================

Sayin ${student.name} ${student.surname} (${student.studentId}),

${courseName} dersi kapsaminda aldiginiz notlar ve basari durumunuz 
asagida detayli olarak belirtilmistir.

GENEL NOT OZETI:
- Yariyil Ici Notu    : ${grades.termGrade.toFixed(2)}/100
- Yariyil Sonu Notu   : ${grades.finalGrade.toFixed(2)}/100
- Toplam Basari Notu  : ${grades.totalGrade.toFixed(2)}/100
- Harf Notu          : ${grades.letterGrade}
${isPassing ? '* BASARILI - Dersi gectiniz!' : '* BASARISIZ - Ders tekrari gerekiyor'}

${termActivitiesText ? `YARIYIL ICI ETKINLIKLER:
${termActivitiesText}

` : ''}${finalActivitiesText ? `YARIYIL SONU ETKINLIKLER:
${finalActivitiesText}

` : ''}DEGERLENDIRME KRITERLERI:
- Yariyil Ici Agirligi: %${APP_STATE.courseData?.dersGenel?.yariYiliciAgirligi || 40}
- Yariyil Sonu Agirligi: %${APP_STATE.courseData?.dersGenel?.yariYilSonuAgirligi || 60}
- Basari Siniri: 60/100 (DD)

==================================================
Bu e-posta otomatik olarak ${new Date().toLocaleDateString('tr-TR')} tarihinde olusturulmustur.

Iyi calismalar,
${instructor}
==================================================`;


        return { subject, body };
        
    } catch (error) {
        console.error('E-posta içeriği oluşturulurken hata:', error);
        return { 
            subject: 'Not Bilgisi - Hata', 
            body: 'Not bilgileri oluşturulurken bir hata meydana geldi. Lütfen öğretim üyenizle iletişime geçiniz.' 
        };
    }
}

/**
 * Öğrencinin bir etkinlikteki puanını getirir
 * @param {string} studentId - Öğrenci ID'si  
 * @param {string} activityId - Etkinlik ID'si
 * @returns {number} - Öğrencinin puanı
 */
function getStudentActivityScore(studentId, activityId) {
    let totalScore = 0;
    
    function searchNode(node) {
        if (node.id === activityId && node.students && node.students[studentId]) {
            totalScore += parseFloat(node.students[studentId].grade || 0);
        }
        
        if (node.children) {
            node.children.forEach(child => searchNode(child));
        }
    }
    
    // Tüm assessment tree'de ara
    if (APP_STATE.assessmentTree) {
        APP_STATE.assessmentTree.forEach(activity => {
            searchNode(activity);
        });
    }
    
    return totalScore;
}

/**
 * Etkinliğin maksimum puanını getirir
 * @param {string} activityId - Etkinlik ID'si
 * @returns {number} - Maksimum puan
 */
function getActivityMaxScore(activityId) {
    let maxScore = 0;
    
    function searchNode(node) {
        if (node.id === activityId) {
            maxScore += parseFloat(node.points || 0);
        }
        
        if (node.children) {
            node.children.forEach(child => searchNode(child));
        }
    }
    
    // Tüm assessment tree'de ara
    if (APP_STATE.assessmentTree) {
        APP_STATE.assessmentTree.forEach(activity => {
            searchNode(activity);
        });
    }
    
    return maxScore;
}

/* =====================================================
   E-POSTA MODAL SİSTEMİ
   ===================================================== */

// Global değişkenler
let selectedEmailType = null;
let currentStudentForEmail = null;

/**
 * E-posta modalını açar
 * @param {Object} student - Öğrenci objesi
 */
function openEmailModal(student) {
    currentStudentForEmail = student;
    
    // Yeni modal oluştur
    createNewEmailModal();
    
    const modal = document.getElementById('newEmailModal');
    modal.style.display = 'flex';
    setTimeout(() => {
        modal.classList.add('active');
    }, 10);
}

/**
 * Yeni e-posta modalını oluşturur
 */
function createNewEmailModal() {
    // Eski modal varsa kaldır
    const existingModal = document.getElementById('newEmailModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'newEmailModal';
    modal.className = 'modal-overlay';
    
    modal.innerHTML = `
        <div class="new-modal-content">
            <div class="modal-header">
                <h2>📧 E-posta Gönder</h2>
                <span class="modal-close" onclick="closeNewEmailModal()">&times;</span>
            </div>
            
            <div class="modal-body">
                <!-- Öğrenci Bilgileri -->
                <div class="student-info-section">
                    <div class="student-info-card">
                        <div class="student-avatar">
                            ${currentStudentForEmail.name.charAt(0)}${currentStudentForEmail.surname.charAt(0)}
                        </div>
                        <div class="student-details">
                            <div class="student-name">${currentStudentForEmail.name} ${currentStudentForEmail.surname}</div>
                            <div class="student-meta">${currentStudentForEmail.studentId} • ${currentStudentForEmail.email}</div>
                        </div>
                    </div>
                </div>
                
                <!-- E-posta Türü Seçimi -->
                <div class="email-type-selection">
                    <h3>E-posta türünü seçin:</h3>
                    
                    <div class="email-type-grid">
                        <div class="email-type-card" data-type="survey">
                            <div class="card-icon">📋</div>
                            <h4>Anket E-postası</h4>
                            <p>Ders bazında öğrenme çıktıları anketi</p>
                        </div>
                        
                        <div class="email-type-card" data-type="detailed">
                            <div class="card-icon">📊</div>
                            <h4>Detaylı Puan Raporu</h4>
                            <p>Tüm sınav ve ödev sonuçları</p>
                        </div>
                        
                        <div class="email-type-card" data-type="analysis">
                            <div class="card-icon">📈</div>
                            <h4>ÖÇ-PÇ Analiz Raporu</h4>
                            <p>Öğrenme çıktıları ve program çıktıları analizi</p>
                        </div>
                        
                        <div class="email-type-card" data-type="info">
                            <div class="card-icon">💬</div>
                            <h4>Bilgi Talebi</h4>
                            <p>Görüşme daveti ve bilgi toplama</p>
                        </div>
                    </div>
                </div>
                
                <!-- Format Seçimi -->
                <div class="format-selection" id="formatSelection" style="display: none;">
                    <h3>Gönderim formatını seçin:</h3>
                    
                    <div class="format-options">
                        <div class="format-option text-option">
                            <div class="format-header">
                                <div class="format-icon">📝</div>
                                <div class="format-title">
                                    <h4>Sade Text Format</h4>
                                    <p>Düz metin formatında, Gmail'de direkt açılır</p>
                                </div>
                            </div>
                            <div class="format-features">
                                <span class="feature">✅ Hızlı ve basit</span>
                                <span class="feature">✅ Tüm e-posta istemcilerinde çalışır</span>
                                <span class="feature">✅ Direkt Gmail'de açılır</span>
                            </div>
                            <button class="format-btn text-btn" onclick="sendTextEmail()">📧 Direkt Gönder</button>
                        </div>
                        
                        <div class="format-option html-option recommended">
                            <div class="recommended-badge">Önerilen</div>
                            <div class="format-header">
                                <div class="format-icon">🎨</div>
                                <div class="format-title">
                                    <h4>HTML Format</h4>
                                    <p>Renkli, tablolu, profesyönel görünüm</p>
                                </div>
                            </div>
                            <div class="format-features">
                                <span class="feature">✅ Profesyönel tasarım</span>
                                <span class="feature">✅ Renkli tablolar ve checkbox'lar</span>
                                <span class="feature">✅ Gmail'de mükemmel görünüm</span>
                            </div>
                            <button class="format-btn html-btn" onclick="sendHtmlEmail()">🎨 HTML Gönder</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // CSS stilleri ekle
    if (!document.querySelector('#newEmailModalStyles')) {
        const styles = document.createElement('style');
        styles.id = 'newEmailModalStyles';
        styles.textContent = `
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .modal-overlay.active {
                opacity: 1;
            }
            
            .new-modal-content {
                background: white;
                border-radius: 15px;
                max-width: 700px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                transform: scale(0.9);
                transition: transform 0.3s ease;
            }
            
            .modal-overlay.active .new-modal-content {
                transform: scale(1);
            }
            
            .modal-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-radius: 15px 15px 0 0;
            }
            
            .modal-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .modal-close {
                background: none;
                border: none;
                color: white;
                font-size: 28px;
                cursor: pointer;
                line-height: 1;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: background 0.3s;
            }
            
            .modal-close:hover {
                background: rgba(255, 255, 255, 0.2);
            }
            
            .modal-body {
                padding: 30px;
            }
            
            .student-info-card {
                display: flex;
                align-items: center;
                gap: 15px;
                padding: 20px;
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                border-radius: 12px;
                margin-bottom: 30px;
                border: 1px solid #dee2e6;
            }
            
            .student-avatar {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 24px;
                text-transform: uppercase;
            }
            
            .student-name {
                font-weight: bold;
                font-size: 20px;
                margin-bottom: 5px;
                color: #333;
            }
            
            .student-meta {
                color: #666;
                font-size: 14px;
            }
            
            .email-type-selection h3 {
                margin-bottom: 20px;
                color: #333;
                font-size: 18px;
            }
            
            .email-type-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 15px;
                margin-bottom: 30px;
            }
            
            .email-type-card {
                padding: 20px;
                border: 2px solid #e9ecef;
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
                background: #fff;
            }
            
            .email-type-card:hover {
                border-color: #667eea;
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.15);
            }
            
            .email-type-card.selected {
                border-color: #667eea;
                background: linear-gradient(135deg, #f8f9ff 0%, #e8f1ff 100%);
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
            }
            
            .email-type-card .card-icon {
                font-size: 32px;
                margin-bottom: 10px;
            }
            
            .email-type-card h4 {
                margin: 0 0 8px 0;
                color: #333;
                font-size: 16px;
            }
            
            .email-type-card p {
                margin: 0;
                color: #666;
                font-size: 14px;
            }
            
            .format-selection {
                margin-top: 30px;
                padding-top: 30px;
                border-top: 2px solid #e9ecef;
            }
            
            .format-selection h3 {
                margin-bottom: 20px;
                color: #333;
                font-size: 18px;
            }
            
            .format-options {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
            
            .format-option {
                border: 2px solid #e9ecef;
                border-radius: 12px;
                padding: 25px;
                background: #fff;
                transition: all 0.3s ease;
                position: relative;
            }
            
            .format-option.recommended {
                border-color: #28a745;
                background: linear-gradient(135deg, #f8fff9 0%, #e8f8e9 100%);
            }
            
            .recommended-badge {
                position: absolute;
                top: -10px;
                right: 15px;
                background: #28a745;
                color: white;
                padding: 5px 15px;
                border-radius: 15px;
                font-size: 12px;
                font-weight: bold;
            }
            
            .format-header {
                display: flex;
                align-items: flex-start;
                gap: 15px;
                margin-bottom: 15px;
            }
            
            .format-icon {
                font-size: 32px;
                flex-shrink: 0;
            }
            
            .format-title h4 {
                margin: 0 0 5px 0;
                font-size: 18px;
                color: #333;
            }
            
            .format-title p {
                margin: 0;
                color: #666;
                font-size: 14px;
            }
            
            .format-features {
                margin: 15px 0 20px 0;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .feature {
                font-size: 14px;
                color: #555;
            }
            
            .format-btn {
                width: 100%;
                padding: 12px 20px;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            
            .text-btn {
                background: #007bff;
                color: white;
            }
            
            .text-btn:hover {
                background: #0056b3;
                transform: translateY(-1px);
            }
            
            .html-btn {
                background: #28a745;
                color: white;
            }
            
            .html-btn:hover {
                background: #1e7e34;
                transform: translateY(-1px);
            }
            
            @media (max-width: 768px) {
                .format-options {
                    grid-template-columns: 1fr;
                }
                
                .email-type-grid {
                    grid-template-columns: 1fr;
                }
                
                .new-modal-content {
                    width: 95%;
                    margin: 20px;
                }
                
                .modal-body {
                    padding: 20px;
                }
            }
        `;
        document.head.appendChild(styles);
    }
    
    document.body.appendChild(modal);
    
    // Email type cards için event listener
    modal.querySelectorAll('.email-type-card').forEach(card => {
        card.addEventListener('click', function() {
            // Önceki seçimi temizle
            modal.querySelectorAll('.email-type-card').forEach(c => c.classList.remove('selected'));
            
            // Yeni seçimi işaretle
            this.classList.add('selected');
            selectedEmailType = this.dataset.type;
            
            // Format seçimi bölümünü göster
            document.getElementById('formatSelection').style.display = 'block';
            
            // Smooth scroll
            document.getElementById('formatSelection').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        });
    });
}

/**
 * E-posta türü seçimi
 * @param {string} type - E-posta türü
 */
function selectEmailType(type) {
    selectedEmailType = type;
    
    // Önceki seçimi temizle
    document.querySelectorAll('.email-type-card').forEach(card => {
        card.classList.remove('selected');
    });
    
    // Yeni seçimi işaretle
    document.querySelector(`[data-type="${type}"]`).classList.add('selected');
    
    // Butonları aktif et
    document.getElementById('generateEmailBtn').disabled = false;
    document.getElementById('previewEmailBtn').disabled = false;
}

/**
 * E-posta önizlemesini gösterir
 */
function previewEmail() {
    if (!selectedEmailType || !currentStudentForEmail) return;
    
    const emailContent = generateEmailByType(selectedEmailType, currentStudentForEmail);
    const previewSection = document.getElementById('emailPreviewSection');
    const previewContent = document.getElementById('emailPreviewContent');
    
    previewContent.innerHTML = emailContent.body;
    previewSection.style.display = 'block';
    
    // Önizleme bölümüne scroll
    previewSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

/**
 * E-postayı oluşturur ve Gmail'de açar
 */
function generateEmail() {
    if (!selectedEmailType || !currentStudentForEmail) return;
    
    const emailContent = generateEmailByType(selectedEmailType, currentStudentForEmail);
    
    // URL uzunluk kontrolü
    const testUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(currentStudentForEmail.email)}&su=${encodeURIComponent(emailContent.subject)}&body=${encodeURIComponent(emailContent.body)}`;
    
    // URL çok uzunsa yeni pencerede açıp kullanıcının kopyalamasını sağla
    if (testUrl.length > 8000) {
        openEmailInNewWindow(emailContent, currentStudentForEmail.email);
    } else {
        // Normal Gmail URL ile aç
        window.open(testUrl, '_blank', 'noopener');
    }
    
    // Modalı kapat
    closeEmailModal();
    
    // Başarı mesajı göster
    showModernToast('E-posta hazırlandı!', 'success');
}

/**
 * E-posta içeriğini yeni pencerede açar
 */
function openEmailInNewWindow(emailContent, recipientEmail) {
    const newWindow = window.open('', '_blank', 'width=900,height=700,scrollbars=yes,resizable=yes');
    
    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-posta İçeriği - Gmail'de Kullanım İçin</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .instructions {
            background: #e3f2fd;
            padding: 20px;
            border-left: 4px solid #2196f3;
            margin: 0;
        }
        .email-info {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
        }
        .email-content {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            margin: 10px 0;
        }
        .buttons {
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
        }
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
            transition: background 0.3s;
        }
        .btn:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #28a745;
        }
        .btn-secondary:hover {
            background: #1e7e34;
        }
        .copy-success {
            color: #28a745;
            font-weight: bold;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📧 E-posta İçeriği Hazır</h1>
            <p>Gmail'de kullanmak için aşağıdaki adımları izleyin</p>
        </div>
        
        <div class="instructions">
            <h3>🚀 Otomatik İşlem:</h3>
            <p style="margin: 10px 0; font-size: 16px; color: #007bff;">
                <strong>Bu sayfa otomatik olarak:</strong>
            </p>
            <ol>
                <li>✅ E-posta içeriğini panoya kopyalar</li>
                <li>📧 Gmail'i yeni sekmede açar</li>
                <li>⚡ Sizin sadece Gmail'de <strong>Ctrl+V</strong> yapmanız yeterli!</li>
            </ol>
            <hr style="margin: 15px 0;">
            <h4>📋 Manuel Seçenekler:</h4>
            <ul style="font-size: 14px; color: #666;">
                <li><strong>Ctrl+C:</strong> Tekrar kopyala</li>
                <li><strong>Ctrl+G:</strong> Gmail'i tekrar aç</li>
                <li>Veya aşağıdaki butonları kullanın</li>
            </ul>
        </div>
        
        <div class="email-info">
            <p><strong>📨 Alıcı:</strong> ${recipientEmail}</p>
            <p><strong>📋 Konu:</strong> ${emailContent.subject}</p>
        </div>
        
        <div class="email-content" id="emailContent">
            ${emailContent.body}
        </div>
        
        <div class="buttons">
            <button class="btn" onclick="copyEmailContent()">📋 E-posta İçeriğini Kopyala</button>
            <button class="btn btn-secondary" onclick="openGmail()">📧 Gmail'i Aç</button>
            <p class="copy-success" id="copySuccess">✅ İçerik kopyalandı! Şimdi Gmail'e gidip yapıştırabilirsiniz.</p>
        </div>
    </div>

    <script>
        // Sayfa yüklendiğinde otomatik başlat
        window.addEventListener('load', function() {
            // 1 saniye bekle sonra otomatik işlemleri başlat
            setTimeout(autoStartProcess, 1000);
        });

        async function autoStartProcess() {
            try {
                // Modern Clipboard API ile otomatik kopyala
                await copyEmailContentModern();
                
                // 2 saniye bekle sonra Gmail'i aç
                setTimeout(() => {
                    openGmail();
                    showAutoSuccessMessage();
                }, 2000);
                
            } catch (err) {
                console.log('Modern API çalışmadı, fallback kullanılıyor');
                // Eski yöntemle dene
                copyEmailContentFallback();
                setTimeout(() => {
                    openGmail();
                }, 1500);
            }
        }

        // Modern Clipboard API ile kopyalama
        async function copyEmailContentModern() {
            const emailContent = document.getElementById('emailContent');
            const htmlContent = emailContent.innerHTML;
            const textContent = emailContent.innerText;
            
            try {
                // Hem HTML hem text formatında kopyala
                await navigator.clipboard.write([
                    new ClipboardItem({
                        'text/html': new Blob([htmlContent], { type: 'text/html' }),
                        'text/plain': new Blob([textContent], { type: 'text/plain' })
                    })
                ]);
                
                document.getElementById('copySuccess').style.display = 'block';
                document.getElementById('copySuccess').innerHTML = '✅ İçerik otomatik olarak kopyalandı! Gmail açılıyor...';
                return true;
            } catch (err) {
                throw err;
            }
        }

        // Fallback eski yöntem
        function copyEmailContentFallback() {
            const emailContent = document.getElementById('emailContent');
            const range = document.createRange();
            range.selectNodeContents(emailContent);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            try {
                document.execCommand('copy');
                document.getElementById('copySuccess').style.display = 'block';
                document.getElementById('copySuccess').innerHTML = '✅ İçerik kopyalandı! Gmail açılıyor...';
                setTimeout(() => {
                    document.getElementById('copySuccess').style.display = 'none';
                }, 5000);
            } catch (err) {
                document.getElementById('copySuccess').style.display = 'block';
                document.getElementById('copySuccess').innerHTML = '⚠️ Otomatik kopyalama başarısız. Lütfen manuel butonları kullanın.';
                document.getElementById('copySuccess').style.color = '#dc3545';
            }
            
            selection.removeAllRanges();
        }

        // Manuel kopyalama fonksiyonu
        async function copyEmailContent() {
            try {
                await copyEmailContentModern();
            } catch (err) {
                copyEmailContentFallback();
            }
        }
        
        function openGmail() {
            // Gmail URL'ini oluştur
            const gmailUrl = 'https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(recipientEmail)}&su=${encodeURIComponent(emailContent.subject)}';
            
            // Gmail'i aç
            const gmailWindow = window.open(gmailUrl, '_blank');
            
            // Gmail açıldıktan sonra otomatik yapıştırma deneme
            setTimeout(() => {
                tryAutoCompose(gmailWindow);
            }, 3000); // 3 saniye bekle Gmail yüklensin
        }

                 async function tryAutoCompose(gmailWindow) {
             try {
                 // Gmail penceresine focus ver
                 gmailWindow.focus();
                 
                 // Gmail'in yüklenmesini bekle
                 await waitForGmailLoad(gmailWindow);
                 
                 // E-posta içeriğini al
                 const emailContent = document.getElementById('emailContent');
                 const htmlContent = emailContent.innerHTML;
                 
                 // Farklı otomatik yapıştırma yöntemleri dene
                 const success = await tryMultiplePasteMethods(gmailWindow, htmlContent);
                 
                 if (!success) {
                     // Başarısız olursa kullanıcıya hatırlatma göster
                     showPasteReminder();
                 } else {
                     showSuccessMessage();
                 }
                 
             } catch (error) {
                 console.log('Otomatik yapıştırma mümkün değil:', error);
                 showPasteReminder();
             }
         }

         async function waitForGmailLoad(gmailWindow) {
             return new Promise((resolve) => {
                 let attempts = 0;
                 const maxAttempts = 20; // 10 saniye max bekleme
                 
                 const checkLoad = () => {
                     attempts++;
                     try {
                         if (gmailWindow.document && 
                             gmailWindow.document.readyState === 'complete' &&
                             (gmailWindow.document.querySelector('[contenteditable]') || 
                              gmailWindow.document.querySelector('.Am.Al.editable'))) {
                             resolve();
                         } else if (attempts < maxAttempts) {
                             setTimeout(checkLoad, 500);
                         } else {
                             resolve(); // Timeout olsa bile devam et
                         }
                     } catch (err) {
                         if (attempts < maxAttempts) {
                             setTimeout(checkLoad, 500);
                         } else {
                             resolve();
                         }
                     }
                 };
                 
                 checkLoad();
             });
         }

         async function tryMultiplePasteMethods(gmailWindow, htmlContent) {
             const methods = [
                 // Yöntem 1: Gmail compose alanını direkt hedefle
                 async () => {
                     const composeArea = gmailWindow.document.querySelector('[contenteditable="true"]') ||
                                        gmailWindow.document.querySelector('.Am.Al.editable') ||
                                        gmailWindow.document.querySelector('[role="textbox"]');
                     
                     if (composeArea) {
                         composeArea.focus();
                         composeArea.innerHTML = htmlContent;
                         composeArea.dispatchEvent(new gmailWindow.Event('input', { bubbles: true }));
                         return true;
                     }
                     return false;
                 },
                 
                 // Yöntem 2: Clipboard API ile yapıştırma
                 async () => {
                     if (gmailWindow.navigator.clipboard) {
                         await gmailWindow.navigator.clipboard.writeText(htmlContent);
                         gmailWindow.document.execCommand('paste');
                         return true;
                     }
                     return false;
                 },
                 
                 // Yöntem 3: Simulate user paste action
                 async () => {
                     const activeElement = gmailWindow.document.activeElement;
                     if (activeElement && activeElement.contentEditable === 'true') {
                         const pasteEvent = new gmailWindow.ClipboardEvent('paste', {
                             bubbles: true,
                             cancelable: true,
                             clipboardData: new gmailWindow.DataTransfer()
                         });
                         
                         // HTML data ekle
                         pasteEvent.clipboardData.setData('text/html', htmlContent);
                         pasteEvent.clipboardData.setData('text/plain', emailContent.innerText);
                         
                         activeElement.dispatchEvent(pasteEvent);
                         return true;
                     }
                     return false;
                 },
                 
                 // Yöntem 4: Keyboard simulation with focus
                 async () => {
                     gmailWindow.focus();
                     await new Promise(resolve => setTimeout(resolve, 500));
                     
                     const events = [
                         new gmailWindow.KeyboardEvent('keydown', { key: 'v', ctrlKey: true, bubbles: true }),
                         new gmailWindow.KeyboardEvent('keypress', { key: 'v', ctrlKey: true, bubbles: true }),
                         new gmailWindow.KeyboardEvent('keyup', { key: 'v', ctrlKey: true, bubbles: true })
                     ];
                     
                     events.forEach(event => gmailWindow.document.dispatchEvent(event));
                     return true;
                 }
             ];
             
             // Her yöntemi sırayla dene
             for (let i = 0; i < methods.length; i++) {
                 try {
                     console.log(\`Yapıştırma yöntemi \${i + 1} deneniyor...\`);
                     const success = await methods[i]();
                     if (success) {
                         console.log(\`Yöntem \${i + 1} başarılı!\`);
                         return true;
                     }
                     // Yöntemler arası kısa bekleme
                     await new Promise(resolve => setTimeout(resolve, 1000));
                 } catch (err) {
                     console.log(\`Yöntem \${i + 1} hata:\`, err);
                 }
             }
             
             return false;
         }

         function showSuccessMessage() {
             setTimeout(() => {
                 const success = document.createElement('div');
                 success.style.cssText = \`
                     position: fixed;
                     top: 20px;
                     right: 20px;
                     background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
                     color: white;
                     padding: 20px;
                     border-radius: 10px;
                     box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                     z-index: 10000;
                     font-family: Arial, sans-serif;
                     font-size: 16px;
                     max-width: 350px;
                     animation: slideIn 0.5s ease-out;
                 \`;
                 
                 success.innerHTML = \`
                     <div style="display: flex; align-items: center; margin-bottom: 10px;">
                         <span style="font-size: 24px; margin-right: 10px;">🎉</span>
                         <strong>Başarılı!</strong>
                     </div>
                     <p style="margin: 0;">
                         E-posta içeriği Gmail'e otomatik olarak yapıştırıldı!
                     </p>
                 \`;
                 
                 document.body.appendChild(success);
                 
                 // 5 saniye sonra otomatik kapat
                 setTimeout(() => {
                     if (success.parentElement) {
                         success.remove();
                     }
                 }, 5000);
                 
             }, 1000);
         }

        function showPasteReminder() {
            // Ana pencerede hatırlatma göster
            setTimeout(() => {
                const reminder = document.createElement('div');
                reminder.style.cssText = \`
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    z-index: 10000;
                    font-family: Arial, sans-serif;
                    font-size: 16px;
                    max-width: 350px;
                    animation: slideIn 0.5s ease-out;
                \`;
                
                reminder.innerHTML = \`
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 24px; margin-right: 10px;">📧</span>
                        <strong>Gmail Açıldı!</strong>
                    </div>
                    <p style="margin: 0 0 15px 0;">
                        Gmail'de <strong>Ctrl+V</strong> tuşlarına basarak e-posta içeriğini yapıştırın.
                    </p>
                    <div style="text-align: center;">
                        <button onclick="this.parentElement.parentElement.remove()" 
                                style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); 
                                       color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                            Anladım ✓
                        </button>
                    </div>
                \`;
                
                // CSS animation ekle
                if (!document.querySelector('#slideInAnimation')) {
                    const style = document.createElement('style');
                    style.id = 'slideInAnimation';
                    style.textContent = \`
                        @keyframes slideIn {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    \`;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(reminder);
                
                // 10 saniye sonra otomatik kapat
                setTimeout(() => {
                    if (reminder.parentElement) {
                        reminder.remove();
                    }
                }, 10000);
                
            }, 1000);
        }

        function showAutoSuccessMessage() {
            document.getElementById('copySuccess').style.display = 'block';
            document.getElementById('copySuccess').innerHTML = '🚀 Tamamlandı! Gmail açıldı, içerik kopyalandı. Artık Ctrl+V ile yapıştırabilirsiniz!';
            document.getElementById('copySuccess').style.color = '#28a745';
            document.getElementById('copySuccess').style.fontSize = '16px';
            document.getElementById('copySuccess').style.fontWeight = 'bold';
        }

        // Klavye kısayolu ekle
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copyEmailContent();
            }
            if (e.ctrlKey && e.key === 'g') {
                e.preventDefault();
                openGmail();
            }
        });
    </script>
</body>
</html>`;
    
    newWindow.document.write(htmlContent);
    newWindow.document.close();
}

/**
 * E-posta türüne göre içerik oluşturur
 */
function generateEmailByType(type, student) {
    const instructor = getInstructorName();
    const courseName = getCourseInfo().name;
    const courseTerm = getCourseInfo().term;
    
    switch (type) {
        case 'survey':
            return generateSurveyEmail(student, instructor, courseName, courseTerm);
        case 'detailed':
            return generateDetailedScoreEmail(student, instructor, courseName, courseTerm);
        case 'analysis':
            return generateAnalysisEmail(student, instructor, courseName, courseTerm);
        case 'info':
            return generateInfoRequestEmail(student, instructor, courseName, courseTerm);
        default:
            return generateDetailedEmailContent(student.studentId);
    }
}

/**
 * Anket e-postası oluşturur
 */
function generateSurveyEmail(student, instructor, courseName, courseTerm) {
    const subject = `${courseName} - Ders Bazinda Ogrenme Ciktilari Anketi`;
    
    console.log('DEBUG: APP_STATE.courseData:', APP_STATE.courseData);
    console.log('DEBUG: dersOgrenmeÇiktilari:', APP_STATE.courseData?.dersOgrenmeÇiktilari);
    
    const outcomes = APP_STATE.courseData?.dersOgrenmeÇiktilari || [];
    
    console.log('DEBUG: outcomes length:', outcomes.length);
    console.log('DEBUG: outcomes:', outcomes);
    const courseCode = APP_STATE.courseData?.dersBilgisi?.dersKodu || 'XXX000';
    
    // HTML formatında soru listesi
    let questionSection = '';
    if (outcomes.length > 0) {
        questionSection = `
        <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-family: Arial, sans-serif;">
            <thead>
                <tr style="background-color: #f0f0f0;">
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd; width: 60%;">Öğrenme Çıktıları</th>
                    <th style="padding: 10px; text-align: center; border: 1px solid #ddd; width: 8%;">5</th>
                    <th style="padding: 10px; text-align: center; border: 1px solid #ddd; width: 8%;">4</th>
                    <th style="padding: 10px; text-align: center; border: 1px solid #ddd; width: 8%;">3</th>
                    <th style="padding: 10px; text-align: center; border: 1px solid #ddd; width: 8%;">2</th>
                    <th style="padding: 10px; text-align: center; border: 1px solid #ddd; width: 8%;">1</th>
                </tr>
            </thead>
            <tbody>`;
        
        outcomes.forEach((outcome, index) => {
            const questionNum = index + 1;
            const fullDescription = outcome.aciklama || outcome.description || 'Tanımlanmamış';
            
            questionSection += `
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 15px; border: 1px solid #ddd; vertical-align: top;">
                        <strong>${questionNum}.</strong> ${fullDescription}
                    </td>
                    <td style="padding: 15px; border: 1px solid #ddd; text-align: center; vertical-align: middle;">
                        <input type="checkbox" style="transform: scale(1.5);" />
                    </td>
                    <td style="padding: 15px; border: 1px solid #ddd; text-align: center; vertical-align: middle;">
                        <input type="checkbox" style="transform: scale(1.5);" />
                    </td>
                    <td style="padding: 15px; border: 1px solid #ddd; text-align: center; vertical-align: middle;">
                        <input type="checkbox" style="transform: scale(1.5);" />
                    </td>
                    <td style="padding: 15px; border: 1px solid #ddd; text-align: center; vertical-align: middle;">
                        <input type="checkbox" style="transform: scale(1.5);" />
                    </td>
                    <td style="padding: 15px; border: 1px solid #ddd; text-align: center; vertical-align: middle;">
                        <input type="checkbox" style="transform: scale(1.5);" />
                    </td>
                </tr>`;
        });
        
        questionSection += `
            </tbody>
        </table>
        
        <div style="margin: 20px 0; padding: 15px; background-color: #f9f9f9; border-left: 4px solid #007bff;">
            <h4 style="margin: 0 0 10px 0; color: #007bff;">Değerlendirme Skalası:</h4>
            <ul style="margin: 0; padding-left: 20px; list-style-type: none;">
                <li><strong>5:</strong> Kesinlikle Katılıyorum</li>
                <li><strong>4:</strong> Katılıyorum</li>
                <li><strong>3:</strong> Kısmen Katılıyorum</li>
                <li><strong>2:</strong> Katılmıyorum</li>
                <li><strong>1:</strong> Kesinlikle Katılmıyorum</li>
            </ul>
        </div>`;
    } else {
        questionSection = `
        <div style="padding: 20px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; color: #856404;">
            <strong>Uyarı:</strong> Bu ders için öğrenme çıktıları tanımlanmamış.<br>
            Lütfen ders sorumlusu ile iletişime geçiniz.
        </div>`;
    }
    
    const body = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ders Değerlendirme Anketi</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px;">
    
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0;">
        <h1 style="margin: 0; font-size: 24px; font-weight: bold;">Recep Tayyip Erdoğan Üniversitesi</h1>
        <h2 style="margin: 10px 0; font-size: 18px; font-weight: normal;">Bilgisayar Mühendisliği</h2>
        <h3 style="margin: 10px 0; font-size: 16px; font-weight: normal;">Ders Bazında Öğrenme Çıktıları Anketi</h3>
    </div>
    
    <div style="background-color: #f8f9fa; padding: 25px; border: 1px solid #dee2e6;">
        <p style="margin: 0 0 15px 0; font-size: 16px;">
            <strong>Değerli Recep Tayyip Erdoğan Üniversitesi Bilgisayar Mühendisliği Öğrencileri;</strong>
        </p>
        
        <p style="margin: 0 0 15px 0; text-align: justify;">
            Aşağıda verilen ders bazında öğrenme çıktısı anketi bölümümüz lisans 
            programında yer alan derslerin değerlendirilmesi amacı ile hazırlanmıştır. 
            Ankete yanıt verirken lütfen dersin ilgili öğrenme çıktısına katkısını 
            değerlendiriniz. Katkı oranı için seçtiğiniz yanıta karşılık gelen 
            kutucuğa işaret koyunuz.
        </p>
        
        <p style="margin: 0; font-style: italic; color: #6c757d;">
            Gösterdiğiniz ilgi ve zamanınız için çok teşekkür ederiz.
        </p>
    </div>
    
    <div style="background-color: white; padding: 25px; border: 1px solid #dee2e6; border-top: none;">
        <div style="background-color: #e9ecef; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
            <h3 style="margin: 0; color: #495057;">
                <strong>Dersin Kodu / Adı:</strong> ${courseCode} / ${courseName}
            </h3>
        </div>
        
        ${questionSection}
    </div>
    
    <div style="background-color: #f8f9fa; padding: 25px; border: 1px solid #dee2e6; border-top: none; border-radius: 0 0 10px 10px;">
        <div style="text-align: center; margin-bottom: 20px;">
            <p style="margin: 0; font-size: 14px; color: #6c757d;">
                Bu anket <strong>${new Date().toLocaleDateString('tr-TR')}</strong> tarihinde gönderilmiştir.
            </p>
        </div>
        
        <div style="background-color: white; padding: 20px; border-radius: 5px; border-left: 4px solid #28a745;">
            <p style="margin: 0 0 10px 0; font-size: 16px;">
                <strong>Merhaba ${student.name} ${student.surname},</strong>
            </p>
            <p style="margin: 0 0 15px 0;">
                Lütfen anketi doldurarak bana geri gönderiniz.
            </p>
            <p style="margin: 0; font-style: italic; color: #28a745;">
                <strong>İyi çalışmalar,</strong><br>
                ${instructor}
            </p>
        </div>
    </div>
    
</body>
</html>`;

    return { subject, body };
}

/**
 * ÖÇ-PÇ analiz e-postası
 */
/**
 * Detaylı puan bilgisi e-postası
 */
/**
 * HTML format için yardımcı fonksiyonlar
 */
function createStudentInfoHTML(studentData, courseName, courseTerm) {
    return `
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; margin-bottom: 25px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.1);">
        <h2 style="margin: 0 0 15px 0; font-size: 24px; font-weight: 700;">📚 Öğrenci Bilgileri</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; font-size: 16px;">
            <div><strong>👤 Ad Soyad:</strong> ${studentData.name} ${studentData.surname}</div>
            <div><strong>🆔 Öğrenci No:</strong> ${studentData.studentId}</div>
            <div><strong>📖 Ders:</strong> ${courseName}</div>
            <div><strong>📅 Dönem:</strong> ${courseTerm}</div>
        </div>
    </div>`;
}

function createTermComponentHTML(componentData, studentGrades, isTermSection = true) {
    const componentId = componentData.id;
    const componentName = componentData.name || componentData.ad || componentId;
    const weight = componentData.weight || componentData.agirlik || 0;
    
    const sectionColor = isTermSection ? '#e8f5e8' : '#fff3e0';
    const headerColor = isTermSection ? '#4caf50' : '#ff9800';
    
    let childrenHTML = '';
    let componentScore = 0;
    let maxComponentScore = 0;
    
    // Alt öğeleri kontrol et ve notları topla - TEXT FORMAT MANTIGI
    if (componentData.children && componentData.children.length > 0) {
        componentData.children.forEach(child => {
            const childId = child.id;
            const childName = child.name || child.ad || childId;
            const childPoints = child.points || 20; // Varsayılan 20 puan
            
            // Notu al - farklı kaynaklardan dene
            const grade = studentGrades[childId] || studentGrades[componentId]?.[childId] || 0;
            
            childrenHTML += `
                <div style="margin: 8px 0; padding: 10px; background: #f9f9f9; border-left: 3px solid ${headerColor}; border-radius: 4px;">
                    <span style="font-weight: 600;">${childName}:</span> ${grade}/${childPoints} puan
                </div>`;
            
            // Alt öğe notlarını topla
            componentScore += parseFloat(grade) || 0;
            maxComponentScore += parseFloat(childPoints) || 0;
        });
    } else {
        // Alt öğe yoksa doğrudan bileşen puanını al
        componentScore = studentGrades[componentId] || 0;
        maxComponentScore = 100; // Varsayılan maksimum puan
    }
    
    // Yüzdelik hesaplama
    const componentPercentage = maxComponentScore > 0 ? (componentScore / maxComponentScore * 100) : 0;
    const agirlikli_katki = (componentPercentage * weight) / 100;
    
    return `
    <div style="background: ${sectionColor}; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 5px solid ${headerColor};">
        <h4 style="color: ${headerColor}; margin: 0 0 15px 0; font-size: 18px; font-weight: 700;">
            ${componentName} - ${componentId} (Ağırlık: %${weight})
        </h4>
        ${childrenHTML}
        <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
            <div style="margin: 5px 0;"><strong>📊 Bileşen Toplamı:</strong> ${componentScore}/${maxComponentScore} (%${componentPercentage.toFixed(2)})</div>
            <div style="margin: 5px 0; color: #666; font-style: italic;">📐 Formül: BP = ${componentScore}/${maxComponentScore} × 100 = %${componentPercentage.toFixed(2)}</div>
            <div style="margin: 5px 0; color: ${headerColor}; font-weight: 600;">⚖️ Ağırlıklı Katkı: AK = ${componentPercentage.toFixed(2)} × ${weight}/100 = %${agirlikli_katki.toFixed(2)}</div>
        </div>
    </div>`;
}

function createResultHTML(yilIciOrtalaması, yilSonuOrtalamasi, overallAverage, letterGrade) {
    const genel_yariyil_ici_katkisi = (yilIciOrtalaması * 40) / 100;
    const genel_yariyil_sonu_katkisi = (yilSonuOrtalamasi * 60) / 100;
    const passed = overallAverage >= 60;
    
    return `
    <div style="background: linear-gradient(135deg, #ff6b6b 0%, #ffa726 100%); color: white; padding: 25px; margin: 25px 0; border-radius: 12px; text-align: center;">
        <h3 style="margin: 0 0 20px 0; font-size: 22px; font-weight: 700;">🎯 Yıl Sonu Hesaplama</h3>
        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <div style="margin: 8px 0;">Yarıyıl İçi Katkısı: %${yilIciOrtalaması.toFixed(2)} × 40/100 = <strong>%${genel_yariyil_ici_katkisi.toFixed(2)}</strong></div>
            <div style="margin: 8px 0;">Yarıyıl Sonu Katkısı: %${yilSonuOrtalamasi.toFixed(2)} × 60/100 = <strong>%${genel_yariyil_sonu_katkisi.toFixed(2)}</strong></div>
            <hr style="border: 1px solid rgba(255,255,255,0.3); margin: 15px 0;">
            <div style="font-size: 20px; font-weight: 700;">Genel Ortalama: %${genel_yariyil_ici_katkisi.toFixed(2)} + %${genel_yariyil_sonu_katkisi.toFixed(2)} = <span style="color: #ffeb3b;">%${overallAverage.toFixed(2)}</span></div>
        </div>
        <div style="font-size: 24px; font-weight: 700; margin: 15px 0;">
            <span style="color: #ffeb3b;">Harf Notu: ${letterGrade}</span>
        </div>
        <div style="font-size: 18px; color: ${passed ? '#4caf50' : '#f44336'}; background: rgba(255,255,255,0.9); color: ${passed ? '#2e7d32' : '#c62828'}; padding: 10px; border-radius: 6px; font-weight: 700;">
            ${passed ? '✅ GEÇTİ' : '❌ KALDI'}
        </div>
    </div>`;
}

function createGradeExplanationHTML() {
    return `
    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h4 style="color: #495057; margin: 0 0 15px 0; font-weight: 700;">📋 Not Açıklaması</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; text-align: center;">
            <div style="background: #28a745; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">AA: 90-100</div>
            <div style="background: #20c997; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">BA: 85-89</div>
            <div style="background: #17a2b8; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">BB: 80-84</div>
            <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 6px; font-weight: 600;">CB: 75-79</div>
            <div style="background: #fd7e14; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">CC: 70-74</div>
            <div style="background: #dc3545; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">DC: 65-69</div>
            <div style="background: #6f42c1; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">DD: 60-64</div>
            <div style="background: #e83e8c; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">FD: 50-59</div>
            <div style="background: #6c757d; color: white; padding: 8px; border-radius: 6px; font-weight: 600;">FF: 0-49</div>
        </div>
    </div>`;
}

function createContactHTML(instructor) {
    return `
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h4 style="margin: 0 0 15px 0; font-weight: 700;">📞 İletişim</h4>
        <div style="line-height: 1.6;">
            <div style="margin: 8px 0;">📧 <strong>E-posta:</strong> ${instructor}</div>
            <div style="margin: 8px 0;">🕐 <strong>Ofis Saatleri:</strong> [Belirtilecek]</div>
            <div style="margin: 8px 0;">💬 <strong>Sorularınız için:</strong> Lütfen bana ulaşabilirsiniz</div>
            <div style="margin: 8px 0;">📅 <strong>Rapor Tarihi:</strong> ${new Date().toLocaleDateString('tr-TR')}</div>
        </div>
    </div>`;
}

/**
 * Detaylı puan e-postası oluşturur (HTML formatı) - DÜZELTILMIŞ
 */
function generateDetailedScoreEmail(student, instructor, courseName, courseTerm) {
    const subject = `${courseName} - Kapsamlı Değerlendirme Raporu`;
    
    // Öğrenci verilerini al
    let studentData = APP_STATE.studentData?.find(s => s.studentId === student.studentId);
    if (!studentData) {
        studentData = {
            studentId: student.studentId,
            name: student.name || 'Bilinmeyen',
            surname: student.surname || 'Öğrenci'
        };
    }

    // Sistemdeki tüm değerlendirme bileşenlerini al
    let assessmentTree = APP_STATE.assessmentTree || APP_STATE.courseData?.degerlendirmeAgaci || [];
    
    // Öğrenci notlarını al
    const allGradesData = APP_STATE.gradesData || APP_STATE.courseData?.ogrenciNotlari || {};
    const studentGrades = allGradesData[studentData.studentId] || {};
    
    // YARIYIL ICI ETKINLIKLER (40% ağırlık) - TEXT FORMAT MANTIGI
    const termComponents = assessmentTree.filter(comp => comp.id && comp.id.startsWith('A'));
    let termWeightedSum = 0;
    let termTotalWeight = 0;
    let termHTML = '';
    
    termComponents.forEach(componentData => {
        const componentId = componentData.id;
        const weight = componentData.weight || componentData.agirlik || 0;
        
        // Alt öğe hesaplama mantığı - TEXT FORMAT GİBİ
        let componentScore = 0;
        let maxComponentScore = 0;
        
        if (componentData.children && componentData.children.length > 0) {
            // Alt öğeler varsa bunları topla
            componentData.children.forEach(child => {
                const childId = child.id;
                const childPoints = child.points || 20;
                const grade = studentGrades[childId] || studentGrades[componentId]?.[childId] || 0;
                
                componentScore += parseFloat(grade) || 0;
                maxComponentScore += parseFloat(childPoints) || 0;
            });
        } else {
            // Alt öğe yoksa doğrudan bileşen puanını al
            componentScore = studentGrades[componentId] || 0;
            maxComponentScore = 100;
        }
        
        termHTML += createTermComponentHTML(componentData, studentGrades, true);
        
        // Yüzdelik hesaplama ve ağırlıklı katkı
        const componentPercentage = maxComponentScore > 0 ? (componentScore / maxComponentScore * 100) : 0;
        const agirlikli_katki = (componentPercentage * weight) / 100;
        termWeightedSum += agirlikli_katki;
        termTotalWeight += weight;
    });
    
    // YARIYIL SONU ETKINLIKLER (60% ağırlık) - TEXT FORMAT MANTIGI  
    const finalComponents = assessmentTree.filter(comp => comp.id && comp.id.startsWith('F'));
    let finalWeightedSum = 0;
    let finalTotalWeight = 0;
    let finalHTML = '';
    
    finalComponents.forEach(componentData => {
        const componentId = componentData.id;
        const weight = componentData.weight || componentData.agirlik || 0;
        
        // Alt öğe hesaplama mantığı - TEXT FORMAT GİBİ
        let componentScore = 0;
        let maxComponentScore = 0;
        
        if (componentData.children && componentData.children.length > 0) {
            // Alt öğeler varsa bunları topla
            componentData.children.forEach(child => {
                const childId = child.id;
                const childPoints = child.points || 20;
                const grade = studentGrades[childId] || studentGrades[componentId]?.[childId] || 0;
                
                componentScore += parseFloat(grade) || 0;
                maxComponentScore += parseFloat(childPoints) || 0;
            });
        } else {
            // Alt öğe yoksa doğrudan bileşen puanını al
            componentScore = studentGrades[componentId] || 0;
            maxComponentScore = 100;
        }
        
        finalHTML += createTermComponentHTML(componentData, studentGrades, false);
        
        // Yüzdelik hesaplama ve ağırlıklı katkı
        const componentPercentage = maxComponentScore > 0 ? (componentScore / maxComponentScore * 100) : 0;
        const agirlikli_katki = (componentPercentage * weight) / 100;
        finalWeightedSum += agirlikli_katki;
        finalTotalWeight += weight;
    });
    
    // YIL SONU HESAPLAMA (Yarıyıl İçi %40 + Yarıyıl Sonu %60) - DOĞRU FORMÜL
    const yilIciOrtalaması = termTotalWeight > 0 ? (termWeightedSum * 100 / termTotalWeight) : 0;
    const yilSonuOrtalamasi = finalTotalWeight > 0 ? (finalWeightedSum * 100 / finalTotalWeight) : 0;
    
    const genel_yariyil_ici_katkisi = (yilIciOrtalaması * 40) / 100;  // Yarıyıl içi %40
    const genel_yariyil_sonu_katkisi = (yilSonuOrtalamasi * 60) / 100; // Yarıyıl sonu %60
    const overallAverage = genel_yariyil_ici_katkisi + genel_yariyil_sonu_katkisi; // DOĞRU HESAPLAMA
    
    const letterGrade = calculateLetterGrade(overallAverage);
    
    const body = `
    <div style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; background: #ffffff; color: #333;">
        ${createStudentInfoHTML(studentData, courseName, courseTerm)}
        
        <div style="background: #e8f5e8; padding: 20px; margin: 20px 0; border-radius: 10px; border-left: 5px solid #4caf50;">
            <h3 style="color: #4caf50; margin: 0 0 15px 0; font-size: 20px; font-weight: 700;">🌱 Yarıyıl İçi Etkinlikler (Toplam Ağırlık: %40)</h3>
            ${termHTML}
            <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 15px; text-align: center;">
                <div style="font-size: 16px; font-weight: 600; color: #4caf50;">📊 Yarıyıl İçi Toplamı: %${termWeightedSum.toFixed(2)}</div>
                <div style="font-size: 14px; color: #666; margin-top: 5px;">Yarıyıl İçi Ortalaması: %${yilIciOrtalaması.toFixed(2)}</div>
            </div>
        </div>
        
        <div style="background: #fff3e0; padding: 20px; margin: 20px 0; border-radius: 10px; border-left: 5px solid #ff9800;">
            <h3 style="color: #ff9800; margin: 0 0 15px 0; font-size: 20px; font-weight: 700;">🏁 Yarıyıl Sonu Etkinlikler (Toplam Ağırlık: %60)</h3>
            ${finalHTML}
            <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 15px; text-align: center;">
                <div style="font-size: 16px; font-weight: 600; color: #ff9800;">📊 Yarıyıl Sonu Toplamı: %${finalWeightedSum.toFixed(2)}</div>
                <div style="font-size: 14px; color: #666; margin-top: 5px;">Yarıyıl Sonu Ortalaması: %${yilSonuOrtalamasi.toFixed(2)}</div>
            </div>
        </div>
        
        ${createResultHTML(yilIciOrtalaması, yilSonuOrtalamasi, overallAverage, letterGrade)}
        ${createGradeExplanationHTML()}
        ${createContactHTML(instructor)}
        
        <div style="text-align: center; padding: 20px; color: #666; font-style: italic;">
            <div style="margin: 10px 0;">Bu rapor tüm hesaplamaları adım adım göstermektedir.</div>
            <div style="font-weight: 600;">İyi çalışmalar! 🎓</div>
        </div>
    </div>`;

    return { subject, body };
}

/**
 * Sayısal notu harf notuna çevirir
 */
// İlk calculateLetterGrade fonksiyonu kaldırıldı - daha kısa versiyon korundu

function generateAnalysisEmail(student, instructor, courseName, courseTerm) {
    const subject = `${courseName} - OC-PC Performans Analizi`;
    
    // Öğrenci verilerini al
    let studentData = APP_STATE.studentData?.find(s => s.studentId === student.studentId);
    if (!studentData) {
        studentData = {
            studentId: student.studentId,
            name: student.name || 'Bilinmeyen',
            surname: student.surname || 'Öğrenci'
        };
    }

    // Öğrenme çıktılarını ve program çıktılarını al
    const outcomes = APP_STATE.courseData?.dersOgrenmeÇiktilari || [];
    const programOutcomes = APP_STATE.courseData?.programCiktilari || [];
    
    // Değerlendirme ağacını al
    const assessmentTree = APP_STATE.assessmentTree || [];
    const studentGrades = APP_STATE.gradesData?.[studentData.studentId] || {};
    
    // ÖÇ performansını hesapla - JSON'dan gelen tam tanımları kullan
    let outcomeAnalysis = '';
    let totalOutcomePerformance = 0;
    let validOutcomes = 0;
    
    outcomes.forEach((outcome, index) => {
        const outcomeId = outcome.id || `ÖÇ.${index + 1}`;
        const fullDescription = outcome.aciklama || outcome.description || 'Tanımlanmamış';
        
        // Bu öğrenme çıktısı ile ilişkili aktivitelerin performansını hesapla
        let outcomePerformance = 0;
        let relatedActivities = 0;
        
        // Değerlendirme ağacından bu öğrenme çıktısı ile ilişkili aktiviteleri bul
        assessmentTree.forEach(component => {
            if (component.outcomes && component.outcomes.includes(outcomeId)) {
                const componentGrade = studentGrades[component.id] || 0;
                const componentMax = component.points || 100;
                const componentPerf = componentMax > 0 ? (componentGrade / componentMax) * 100 : 0;
                
                outcomePerformance += componentPerf;
                relatedActivities++;
            }
            
            // Alt öğeleri de kontrol et
            if (component.children) {
                component.children.forEach(child => {
                    if (child.outcomes && child.outcomes.includes(outcomeId)) {
                        const childGrade = studentGrades[child.id] || 0;
                        const childMax = child.points || 100;
                        const childPerf = childMax > 0 ? (childGrade / childMax) * 100 : 0;
                        
                        outcomePerformance += childPerf;
                        relatedActivities++;
                    }
                });
            }
        });
        
        const finalPerformance = relatedActivities > 0 ? (outcomePerformance / relatedActivities) : 0;
        const performanceLevel = finalPerformance >= 85 ? 'Çok İyi' : 
                               finalPerformance >= 70 ? 'İyi' : 
                               finalPerformance >= 55 ? 'Orta' : 
                               finalPerformance >= 40 ? 'Zayıf' : 'Çok Zayıf';
        
        outcomeAnalysis += `${outcomeId}: ${performanceLevel} (%${finalPerformance.toFixed(2)})\n`;
        outcomeAnalysis += `   Tanımı: ${fullDescription}\n`;
        outcomeAnalysis += `   İlişkili Etkinlik Sayısı: ${relatedActivities}\n\n`;
        
        if (relatedActivities > 0) {
            totalOutcomePerformance += finalPerformance;
            validOutcomes++;
        }
    });
    
    // Program çıktıları ile ilişki analizi - JSON'dan gelen ilişki matrisini kullan
    const relationshipMatrix = APP_STATE.courseData?.programVeOgrenmeIliskisi?.iliskiTablosu || [];
    let programAnalysis = '';
    
    programOutcomes.forEach((pc, index) => {
        const pcId = pc.id || `PÇ.${index + 1}`;
        const pcCategory = pc.kategori || 'Kategori Belirtilmemiş';
        const pcFullDescription = pc.aciklama || pc.description || 'Tanımlanmamış';
        
        // Bu program çıktısı ile ilişkili öğrenme çıktılarını JSON'dan bul
        const relatedRelations = relationshipMatrix.filter(relation => {
            const relationValue = relation.programÇiktilariIliskileri?.[pcId] || 0;
            return relationValue > 0;
        });
        
        if (relatedRelations.length > 0) {
            let strongRelations = 0;
            let moderateRelations = 0;
            let totalRelationStrength = 0;
            
            relatedRelations.forEach(relation => {
                const strength = relation.programÇiktilariIliskileri[pcId];
                totalRelationStrength += strength;
                if (strength >= 4) strongRelations++;
                else if (strength >= 3) moderateRelations++;
            });
            
            const avgStrength = relatedRelations.length > 0 ? (totalRelationStrength / relatedRelations.length).toFixed(2) : 0;
            
            programAnalysis += `${pcId} - ${pcCategory}\n`;
            programAnalysis += `   Tanımı: ${pcFullDescription}\n`;
            programAnalysis += `   İlişkili ÖÇ Sayısı: ${relatedRelations.length}\n`;
            programAnalysis += `   Güçlü İlişki: ${strongRelations}, Orta İlişki: ${moderateRelations}\n`;
            programAnalysis += `   Ortalama İlişki Gücü: ${avgStrength}/5\n\n`;
        }
    });
    
    // Genel performans değerlendirmesi
    const overallPerformance = validOutcomes > 0 ? (totalOutcomePerformance / validOutcomes) : 0;
    const performanceComment = overallPerformance >= 85 ? 'Çok başarılı bir performans gösterdiniz! Tüm öğrenme çıktılarını mükemmel bir şekilde karşıladınız.' :
                              overallPerformance >= 70 ? 'Genel olarak başarılı bir performans! Çoğu öğrenme çıktısını iyi seviyede karşıladınız.' :
                              overallPerformance >= 55 ? 'Orta düzey bir performans sergiledınız. Bazı alanlarda gelişim fırsatlarınız mevcut.' :
                              overallPerformance >= 40 ? 'Performansınızı artırmak için ek çalışma gerekli. Temel konuları gözden geçirmenizi öneriyorum.' :
                              'Performansınızda önemli gelişim alanları var. Kapsamlı bir çalışma planı oluşturmanızı öneriyorum.';
    
    const body = `Merhaba ${studentData.name} ${studentData.surname},

${courseName} dersi için ÖÇ-PÇ (Öğrenme Çıktıları - Program Çıktıları) performans analiziniz aşağıdadır:

ÖĞRENCI BİLGİLERİ:
=================
Ad Soyad: ${studentData.name} ${studentData.surname}
Öğrenci No: ${studentData.studentId}
Ders: ${courseName}
Dönem: ${courseTerm}

ÖĞRENME ÇIKTILARI PERFORMANSI:
=============================
${outcomes.length > 0 ? outcomeAnalysis : 'Bu ders için öğrenme çıktıları tanımlanmamış.'}

PROGRAM ÇIKTILARI İLİŞKİ ANALİZİ:
=================================
${programOutcomes.length > 0 ? programAnalysis : 'Program çıktıları bilgisi mevcut değil.'}

GENEL DEĞERLENDİRME:
===================
Genel ÖÇ Performansı: %${overallPerformance.toFixed(2)}
Değerlendirme: ${performanceComment}

Analiz Edilen ÖÇ Sayısı: ${validOutcomes}
Toplam ÖÇ Sayısı: ${outcomes.length}
Toplam PÇ Sayısı: ${programOutcomes.length}

GELİŞİM PLANI VE ÖNERİLER:
=========================
${overallPerformance >= 85 ? 
`1. Kısa Vadeli: Mevcut performansınızı koruyun ve başkalarına mentörlük yapın
2. Orta Vadeli: Liderlik becerilerinizi geliştirin ve proje yönetimi deneyimi kazanın
3. Uzun Vadeli: İleri düzey konulara odaklanın ve araştırma projelerine katılın` :
overallPerformance >= 70 ?
`1. Kısa Vadeli: İyi olduğunuz alanları pekiştirin ve zayıf noktalarınızı belirleyin
2. Orta Vadeli: Zayıf alanlarda ek çalışma yapın ve pratik uygulamalar geliştirin
3. Uzun Vadeli: Kapsamlı tekrar ve projeler ile bilginizi pekiştirin` :
overallPerformance >= 55 ?
`1. Kısa Vadeli: Temel konuları yeniden gözden geçirin ve anlayamadığınız noktaları belirleyin
2. Orta Vadeli: Daha fazla pratik yapın, örnek problemler çözün ve grup çalışmalarına katılın
3. Uzun Vadeli: Çalışma yöntemlerinizi geliştirin ve düzenli tekrar programı oluşturun` :
overallPerformance >= 40 ?
`1. Kısa Vadeli: Temel kavramları öğrenin, ders notlarını düzenli olarak gözden geçirin
2. Orta Vadeli: Düzenli çalışma alışkanlığı edinin ve öğretim üyesinden destek alın
3. Uzun Vadeli: Ek destek kaynaklarından yararlanın ve study grup oluşturun` :
`1. Kısa Vadeli: Dersin temel hedeflerini anlayın ve eksikliklerinizi tespit edin
2. Orta Vadeli: Birebir rehberlik alın ve temel konularda yoğunlaşın
3. Uzun Vadeli: Kapsamlı bir çalışma planı oluşturun ve düzenli takip yapın`}

ÖNERİLEN KAYNAKLAR:
==================
- Ders notları ve sunumları
- Kaynak kitaplar ve referanslar
- Online eğitim platformları
- Örnek problemler ve çözümleri
- Grup çalışması ve tartışma ortamları

İLETİŞİM:
=========
Bu analiz hakkında detaylı görüşmek isterseniz:
- Ofis saatleri: [Belirtilecek]
- E-posta: ${instructor}
- Görüşme randevusu: Önceden haber verin

Bu analiz ${new Date().toLocaleDateString('tr-TR')} tarihinde oluşturulmuştur.

İyi çalışmalar,
${instructor}`;

    return { subject, body };
}

/**
 * Bilgi talebi e-postası
 */
function generateInfoRequestEmail(student, instructor, courseName, courseTerm) {
    const subject = `${courseName} - Gorusme Davet ve Bilgi Talebi`;
    
    const body = `Merhaba ${student.name} ${student.surname},

${courseName} dersi kapsaminda sizinle gorusmek istiyorum.

GORUSME SECENEKLERI:
- Yuz yuze gorusme (ofis saatleri)
- Online gorusme (Teams/Zoom)
- E-posta gorusmesi

GORUSMEK ISTEDIGIM KONULAR:
- Ders performansiniz ve gelisim alanlari
- Anlamakta zorlandiginiz konular
- Calisma yontemleriniz ve oneriler
- Gelecek planlariniz ve kariyer hedefleri

LUTFEN YANITLAYINIZ:
1. Hangi konularda zorlaniyorsunuz?
2. Ek destek almak istediginiz alanlar neler?
3. Gorusme icin uygun gunleriniz?
4. Tercih ettiginiz gorusme sekli?

En kisa surede yanitinizi bekliyorum.

Iyi calismalar,
${instructor}`;

    return { subject, body };
}

/**
 * E-posta modalını kapatır
 */
function closeEmailModal() {
    const modal = document.getElementById('emailTypeModal');
    modal.classList.remove('active');
    
    // Animasyon tamamlandıktan sonra modal'ı gizle
    setTimeout(() => {
        modal.style.display = 'none';
    }, 300);
    
    // Değişkenleri temizle
    selectedEmailType = null;
    currentStudentForEmail = null;
    
    // Önizleme bölümünü gizle
    document.getElementById('emailPreviewSection').style.display = 'none';
}

/**
 * Modal event listener'larını başlatır
 */
function initializeEmailModal() {
    // E-posta türü kartlarına tıklama olayları
    document.querySelectorAll('.email-type-card').forEach(card => {
        card.addEventListener('click', function() {
            selectEmailType(this.dataset.type);
        });
    });
    
    // Modal butonları
    document.getElementById('generateEmailBtn').addEventListener('click', generateEmail);
    document.getElementById('previewEmailBtn').addEventListener('click', previewEmail);
    
    // Modal kapatma olayları
    document.querySelectorAll('#emailTypeModal .modern-close').forEach(closeBtn => {
        closeBtn.addEventListener('click', closeEmailModal);
    });
    
    // Modal dışına tıklama ile kapatma
    document.getElementById('emailTypeModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeEmailModal();
        }
    });
}

/**
 * Yardımcı fonksiyonlar
 */
// Bu HTML fonksiyonları artık kullanılmadığı için kaldırıldı - text tabanlı e-posta kullanıyoruz

// Bu HTML fonksiyonları da kaldırıldı - text tabanlı e-posta kullanıyoruz

function getInstructorName() {
    return APP_STATE.courseData?.dersIcerik?.dersiVerenOgretimUyesiOgretimGorevlisi || 
           APP_STATE.courseData?.dersBilgisi?.ogretimUyesi || 
           'Öğretim Üyesi';
}

function getCourseInfo() {
    return {
        name: APP_STATE.courseData?.dersBilgisi?.dersAdi || 
              APP_STATE.courseData?.dersGenel?.dersAdi || 
              'Ders',
        term: APP_STATE.courseData?.dersBilgisi?.donem || 
              APP_STATE.courseData?.dersGenel?.akademikYil || 
              '2023-2024'
    };
}

/**
 * Yeni modalı kapat
 */
function closeNewEmailModal() {
    const modal = document.getElementById('newEmailModal');
    if (modal) {
        modal.classList.remove('active');
        setTimeout(() => {
            modal.remove();
        }, 300);
    }
    selectedEmailType = null;
}

/**
 * Text formatında e-posta gönder
 */
function sendTextEmail() {
    if (!selectedEmailType || !currentStudentForEmail) return;
    
    let textContent;
    
    // Her e-posta türü için özel text formatı
    switch (selectedEmailType) {
        case 'survey':
            textContent = generateSurveyTextEmail(currentStudentForEmail);
            break;
        case 'detailed':
            textContent = generateDetailedScoreTextEmail(currentStudentForEmail);
            break;
        case 'analysis':
            textContent = generateAnalysisTextEmail(currentStudentForEmail);
            break;
        case 'info':
            textContent = generateInfoRequestTextEmail(currentStudentForEmail);
            break;
        default:
            showModernToast('❌ Bilinmeyen e-posta türü!', 'error');
            return;
    }
    
    // Gmail URL oluştur
    const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(currentStudentForEmail.email)}&su=${encodeURIComponent(textContent.subject)}&body=${encodeURIComponent(textContent.body)}`;
    
    // Gmail'i aç
    window.open(gmailUrl, '_blank', 'noopener');
    
    // Modalı kapat
    closeNewEmailModal();
    
    // Başarı mesajı göster
    showModernToast('📧 Text formatında e-posta Gmail\'de açıldı!', 'success');
}

/**
 * Anket e-postası için özel text formatı
 */
function generateSurveyTextEmail(student) {
    const instructor = getInstructorName();
    const courseInfo = getCourseInfo();
    const courseName = courseInfo.name;
    const courseTerm = courseInfo.term;
    const courseCode = APP_STATE.courseData?.dersBilgisi?.dersKodu || 'XXX000';
    
    const subject = `${courseName} - Ders Bazinda Ogrenme Ciktilari Anketi`;
    
    const outcomes = APP_STATE.courseData?.dersOgrenmeÇiktilari || [];
    
    let questionSection = '';
    if (outcomes.length > 0) {
        questionSection = `Dersin Kodu / Adi: ${courseCode} / ${courseName}\n\n`;
        questionSection += `OGRENME CIKTILARI DEGERLENDIRME ANKETI\n`;
        questionSection += `${'='.repeat(70)}\n\n`;
        
        outcomes.forEach((outcome, index) => {
            const questionNum = index + 1;
            const fullDescription = outcome.aciklama || outcome.description || 'Tanimlanmamis';
            
            // Soru metni
            questionSection += `${questionNum}. ${fullDescription}\n`;
            
            // Her soru için kendi sayıları ve kutucukları
            questionSection += `                                   5   4   3   2   1\n`;
            questionSection += `                                  ( ) ( ) ( ) ( ) ( )\n\n`;
        });
        
        questionSection += `${'='.repeat(70)}\n\n`;
        questionSection += `DEGERLENDIRME SKALASI:\n`;
        questionSection += `5: Kesinlikle Katiliyorum\n`;
        questionSection += `4: Katiliyorum\n`;
        questionSection += `3: Kismen Katiliyorum\n`;
        questionSection += `2: Katilmiyorum\n`;
        questionSection += `1: Kesinlikle Katilmiyorum\n\n`;
    } else {
        questionSection = `UYARI: Bu ders icin ogrenme ciktilari tanimlanmamis.\nLutfen ders sorumlusu ile iletisime geciniz.\n\n`;
    }
    
    const body = `DERS DEGERLENDIRME ANKETI

Recep Tayyip Erdogan Universitesi
Bilgisayar Muhendisligi
Ders Bazinda Ogrenme Ciktilari Anketi

${'='.repeat(70)}

Degerli Recep Tayyip Erdogan Universitesi Bilgisayar Muhendisligi Ogrencileri;

Asagida verilen ders bazinda ogrenme ciktisi anketi bolumumuz lisans 
programinda yer alan derslerin degerlendirilmesi amaci ile hazirlanmistir. 
Ankete yanit verirken lutfen dersin ilgili ogrenme ciktisina katkisini 
degerlendiriniz. Katki orani icin sectiginiz yanita karsilik gelen 
kutucuga isaret koyunuz.

Gosterdiginiz ilgi ve zamaniniz icin cok tesekkur ederiz.

${'='.repeat(70)}

${questionSection}
${'='.repeat(70)}

Bu anket ${new Date().toLocaleDateString('tr-TR')} tarihinde gonderilmistir.

Merhaba ${student.name} ${student.surname},

Lutfen anketi doldurarak bana geri gonderiniz.

Iyi calismalar,
${instructor}`;

    return { subject, body };
}

/**
 * HTML formatında e-posta gönder
 */
function sendHtmlEmail() {
    if (!selectedEmailType || !currentStudentForEmail) return;
    
    const emailContent = generateEmailByType(selectedEmailType, currentStudentForEmail);
    
    // HTML formatı için yeni pencere aç
    openEmailInNewWindow(emailContent, currentStudentForEmail.email);
    
    // Modalı kapat
    closeNewEmailModal();
    
    // Başarı mesajı göster
    showModernToast('🎨 HTML formatında e-posta hazırlandı!', 'success');
}

/**
 * Detaylı puan e-postası için text formatı
 */
function generateDetailedScoreTextEmail(student) {
    const instructor = getInstructorName();
    const courseInfo = getCourseInfo();
    const courseName = courseInfo.name;
    const courseTerm = courseInfo.term;
    
    const subject = `${courseName} - Not Bilgisi`;
    
    // Öğrenci verilerini al
    let studentData = APP_STATE.studentData?.find(s => s.studentId === student.studentId);
    if (!studentData) {
        studentData = {
            studentId: student.studentId,
            name: student.name || 'Bilinmeyen',
            surname: student.surname || 'Öğrenci'
        };
    }

    // Öğrenci notlarını al
    const allGradesData = APP_STATE.gradesData || APP_STATE.courseData?.ogrenciNotlari || {};
    const studentGrades = allGradesData[studentData.studentId] || {};
    
    // Temel hesaplamalar
    const assessmentTree = APP_STATE.assessmentTree || [];
    const termComponents = assessmentTree.filter(comp => comp.id && comp.id.startsWith('A'));
    const finalComponents = assessmentTree.filter(comp => comp.id && comp.id.startsWith('F'));
    
    let termWeightedSum = 0;
    let termTotalWeight = 0;
    let finalWeightedSum = 0;
    let finalTotalWeight = 0;
    
    // Yarıyıl içi hesaplama
    termComponents.forEach(comp => {
        let grade = studentGrades[comp.id] || 0;
        
        // Alt öğeleri kontrol et ve topla
        if (comp.children && comp.children.length > 0) {
            let childrenTotal = 0;
            comp.children.forEach(child => {
                const childGrade = studentGrades[child.id] || 0;
                childrenTotal += parseFloat(childGrade) || 0;
            });
            grade = childrenTotal; // Alt öğelerin toplamını kullan
        }
        
        const weight = comp.weight || 0;
        termWeightedSum += (grade * weight) / 100;
        termTotalWeight += weight;
    });
    
    // Yarıyıl sonu hesaplama
    finalComponents.forEach(comp => {
        let grade = studentGrades[comp.id] || 0;
        
        // Alt öğeleri kontrol et ve topla
        if (comp.children && comp.children.length > 0) {
            let childrenTotal = 0;
            comp.children.forEach(child => {
                const childGrade = studentGrades[child.id] || 0;
                childrenTotal += parseFloat(childGrade) || 0;
            });
            grade = childrenTotal; // Alt öğelerin toplamını kullan
        }
        
        const weight = comp.weight || 0;
        finalWeightedSum += (grade * weight) / 100;
        finalTotalWeight += weight;
    });
    
    const yilIciOrt = termTotalWeight > 0 ? (termWeightedSum * 100 / termTotalWeight) : 0;
    const yilSonuOrt = finalTotalWeight > 0 ? (finalWeightedSum * 100 / finalTotalWeight) : 0;
    const genelOrt = (yilIciOrt * 40 + yilSonuOrt * 60) / 100;
    const harfNotu = calculateLetterGrade(genelOrt);

    const body = `${courseName} - NOT RAPORU

${studentData.name} ${studentData.surname} (${studentData.studentId})
${courseTerm} - ${new Date().toLocaleDateString('tr-TR')}

YARIYIL ICI NOTLAR:
${termComponents.map(comp => {
    let grade = studentGrades[comp.id] || 0;
    
    // Alt öğeleri kontrol et ve topla
    if (comp.children && comp.children.length > 0) {
        let childrenTotal = 0;
        comp.children.forEach(child => {
            const childGrade = studentGrades[child.id] || 0;
            childrenTotal += parseFloat(childGrade) || 0;
        });
        grade = childrenTotal; // Alt öğelerin toplamını kullan
    }
    
    const name = comp.name || comp.ad || comp.id;
    return `${name}: ${grade}/100 (%${comp.weight || 0})`;
}).join('\n')}
Yariyil Ici Ortalama: %${yilIciOrt.toFixed(2)}

YARIYIL SONU NOTLAR:
${finalComponents.map(comp => {
    let grade = studentGrades[comp.id] || 0;
    
    // Alt öğeleri kontrol et ve topla
    if (comp.children && comp.children.length > 0) {
        let childrenTotal = 0;
        comp.children.forEach(child => {
            const childGrade = studentGrades[child.id] || 0;
            childrenTotal += parseFloat(childGrade) || 0;
        });
        grade = childrenTotal; // Alt öğelerin toplamını kullan
    }
    
    const name = comp.name || comp.ad || comp.id;
    return `${name}: ${grade}/100 (%${comp.weight || 0})`;
}).join('\n')}
Yariyil Sonu Ortalama: %${yilSonuOrt.toFixed(2)}

HESAPLAMA:
Yariyil Ici (%40): ${yilIciOrt.toFixed(2)} * 0.4 = ${(yilIciOrt * 0.4).toFixed(2)}
Yariyil Sonu (%60): ${yilSonuOrt.toFixed(2)} * 0.6 = ${(yilSonuOrt * 0.6).toFixed(2)}
GENEL ORTALAMA: %${genelOrt.toFixed(2)}
HARF NOTU: ${harfNotu}
DURUM: ${genelOrt >= 60 ? 'GECTI' : 'KALDI'}

NOT SISTEMI:
AA:90-100, BA:85-89, BB:80-84, CB:75-79, CC:70-74
DC:65-69, DD:60-64, FD:50-59, FF:0-49

Sorulariniz icin: ${instructor}

Iyi calismalar,
${instructor}`;

    return { subject, body };
}

// Yardımcı fonksiyonlar
function calculateOCPerformanceFromText(ocId, studentGrades, assessmentTree) {
    // Gerçek ÖÇ performans hesaplaması
    let outcomePerformance = 0;
    let relatedActivities = 0;
    
    // Değerlendirme ağacından bu öğrenme çıktısı ile ilişkili aktiviteleri bul
    assessmentTree.forEach(component => {
        if (component.outcomes && component.outcomes.includes(ocId)) {
            const componentGrade = studentGrades[component.id] || 0;
            const componentMax = component.points || 100;
            const componentPerf = componentMax > 0 ? (componentGrade / componentMax) * 100 : 0;
            
            outcomePerformance += componentPerf;
            relatedActivities++;
        }
        
        // Alt öğeleri de kontrol et
        if (component.children) {
            component.children.forEach(child => {
                if (child.outcomes && child.outcomes.includes(ocId)) {
                    const childGrade = studentGrades[child.id] || 0;
                    const childMax = child.points || 100;
                    const childPerf = childMax > 0 ? (childGrade / childMax) * 100 : 0;
                    
                    outcomePerformance += childPerf;
                    relatedActivities++;
                }
            });
        }
    });
    
    return relatedActivities > 0 ? (outcomePerformance / relatedActivities) : 0;
}

/**
 * PÇ ilişki gücü hesaplama fonksiyonu
 */
function calculatePCRelationStrength(pcId, relationMatrix) {
    const relatedRelations = relationMatrix.filter(relation => {
        const relationValue = relation.programÇiktilariIliskileri?.[pcId] || 0;
        return relationValue > 0;
    });
    
    if (relatedRelations.length === 0) return { strength: 0, level: 'Yok' };
    
    let totalStrength = 0;
    relatedRelations.forEach(relation => {
        totalStrength += relation.programÇiktilariIliskileri[pcId];
    });
    
    const avgStrength = totalStrength / relatedRelations.length;
    let level = 'Zayıf';
    if (avgStrength >= 4) level = 'Güçlü';
    else if (avgStrength >= 3) level = 'Orta';
    
    return { strength: avgStrength, level: level };
}

function getPerformanceTextLevel(performance) {
    if (performance >= 90) return 'Mukemmel';
    else if (performance >= 80) return 'Cok Iyi';
    else if (performance >= 70) return 'Iyi';
    else if (performance >= 60) return 'Orta';
    else if (performance >= 50) return 'Zayif';
    else return 'Yetersiz';
}

/**
 * ÖÇ-PÇ Analiz e-postası için text formatı
 */
function generateAnalysisTextEmail(student) {
    const instructor = getInstructorName();
    const courseInfo = getCourseInfo();
    const courseName = courseInfo.name;
    const courseTerm = courseInfo.term;
    
    const subject = `${courseName} - OC-PC Analizi`;
    
    // Öğrenci verilerini al
    let studentData = APP_STATE.studentData?.find(s => s.studentId === student.studentId);
    if (!studentData) {
        studentData = {
            studentId: student.studentId,
            name: student.name || 'Bilinmeyen',
            surname: student.surname || 'Öğrenci'
        };
    }

    // Temel veriler
    const outcomes = APP_STATE.courseData?.dersOgrenmeÇiktilari || [];
    const programOutcomes = APP_STATE.courseData?.programCiktilari || [];
    const assessmentTree = APP_STATE.assessmentTree || [];
    const studentGrades = APP_STATE.gradesData?.[studentData.studentId] || {};
    const relationMatrix = APP_STATE.courseData?.programVeOgrenmeIliskisi?.iliskiTablosu || [];
    
    // Gerçek ÖÇ performans hesabı
    const totalOC = outcomes.length;
    const totalPC = programOutcomes.length;
    let totalOCPerformance = 0;
    let validOCCount = 0;
    
    // Gerçek ÖÇ hesaplamaları
    const ocResults = outcomes.slice(0, 4).map(oc => {
        const performance = calculateOCPerformanceFromText(oc.id, studentGrades, assessmentTree);
        totalOCPerformance += performance;
        if (performance > 0) validOCCount++;
        return `${oc.id}: %${performance.toFixed(2)}`;
    }).join('\n');
    
    // Gerçek PÇ hesaplamaları
    let strongRelations = 0;
    let moderateRelations = 0;
    programOutcomes.forEach(pc => {
        const relation = calculatePCRelationStrength(pc.id, relationMatrix);
        if (relation.level === 'Güçlü') strongRelations++;
        else if (relation.level === 'Orta') moderateRelations++;
    });
    
    // Genel performans
    const avgPerformance = validOCCount > 0 ? totalOCPerformance / validOCCount : 0;

    const body = `${courseName} - OC-PC ANALIZI

${studentData.name} ${studentData.surname} (${studentData.studentId})
${courseTerm} - ${new Date().toLocaleDateString('tr-TR')}

OGRENME CIKTILARI (OC):
${ocResults}
${totalOC > 4 ? `... ve ${totalOC - 4} tane daha` : ''}

PROGRAM CIKTILARI (PC):
Iliskili PC Sayisi: ${totalPC}
Guclu Iliski: ${strongRelations}
Orta Iliski: ${moderateRelations}

GENEL PERFORMANS:
OC Ortalamasi: %${avgPerformance.toFixed(2)}
Degerlendirme: ${avgPerformance >= 80 ? 'Cok Iyi' : avgPerformance >= 70 ? 'Iyi' : avgPerformance >= 60 ? 'Orta' : 'Zayif'}

MUDEK DEGERLENDIRME:
OC Basari Orani: %${validOCCount > 0 ? (validOCCount / totalOC * 100).toFixed(2) : '0.0'}
PC Iliski Orani: %${totalPC > 0 ? ((strongRelations + moderateRelations) / totalPC * 100).toFixed(2) : '0.0'}

${avgPerformance >= 80 ? 
'ONERI: Mevcut performansinizi koruun ve surdurun' :
avgPerformance >= 70 ? 
'ONERI: Zayif alanlarda gelisim plani yapin' : 
'ONERI: Temel yetkinliklere odaklanin'}

Detayli analiz icin: ${instructor}

Iyi calismalar,
${instructor}`;

    return { subject, body };
}

/**
 * Bilgi talebi e-postası için text formatı
 */
function generateInfoRequestTextEmail(student) {
    const instructor = getInstructorName();
    const courseInfo = getCourseInfo();
    const courseName = courseInfo.name;
    
    const subject = `${courseName} - Gorusme Talebi`;
    
    const body = `${courseName} - GORUSME TALEBI

Merhaba ${student.name} ${student.surname},

${courseName} dersi hakkinda sizinle gorusmek istiyorum.

GORUSME KONULARI:
- Ders performansiniz
- Zorluklar ve destekler
- Calisma onerileri
- Gelecek planlariniz

YANITLAYINIZ:
1. Hangi konularda zorlaniyorsunuz?
2. Ne konuda destek istersiniz?
3. Gorusme icin uygun gun?
4. Tercih: Yuz yuze / Online?

Yanitinizi bekliyorum.

Iyi calismalar,
${instructor}`;

    return { subject, body };
}

/**
 * Harf notu hesaplama yardımcı fonksiyonu
 */
function calculateLetterGrade(score) {
    if (score >= 90) return 'AA';
    if (score >= 85) return 'BA';
    if (score >= 80) return 'BB';
    if (score >= 75) return 'CB';
    if (score >= 70) return 'CC';
    if (score >= 65) return 'DC';
    if (score >= 60) return 'DD';
    if (score >= 50) return 'FD';
    return 'FF';
}

/**
 * Modern Test Operations - V2 Card System
 */
function initializeModernTestOperations() {
    console.log('🔧 Modern Test Operations başlatılıyor...');
    
    // Slider değer güncellemeleri
    initializeModernSliders();
    
    // Dual Range Slider sistemi
    initializeModernDualRange();
    
    // Akıllı puanlama sistemi
    initializeModernScoring();
    
    // İstatistik güncellemeleri
    updateModernStats();
}

/**
 * Modern slider'ları başlat
 */
function initializeModernSliders() {
    // Yarıyıl İçi Etkinlik Sayısı Slider
    const termActivitySlider = document.getElementById('termActivityCountSlider');
    const termActivityValue = document.getElementById('termActivityCountValue');
    
    if (termActivitySlider && termActivityValue) {
        termActivitySlider.addEventListener('input', function() {
            termActivityValue.textContent = this.value;
        });
    }
    
    // Yarıyıl İçi Soru/Rubrik Sayısı Slider
    const termSlider = document.getElementById('termComponentsSlider');
    const termValue = document.getElementById('termComponentsValue');
    
    if (termSlider && termValue) {
        termSlider.addEventListener('input', function() {
            termValue.textContent = this.value;
        });
    }
    
    // Yarıyıl Sonu Etkinlik Sayısı Slider
    const finalActivitySlider = document.getElementById('finalActivityCountSlider');
    const finalActivityValue = document.getElementById('finalActivityCountValue');
    
    if (finalActivitySlider && finalActivityValue) {
        finalActivitySlider.addEventListener('input', function() {
            finalActivityValue.textContent = this.value;
        });
    }
    
    // Yarıyıl Sonu Soru/Rubrik Sayısı Slider
    const finalSlider = document.getElementById('finalComponentsSlider');
    const finalValue = document.getElementById('finalComponentsValue');
    
    if (finalSlider && finalValue) {
        finalSlider.addEventListener('input', function() {
            finalValue.textContent = this.value;
        });
    }
}

/**
 * Modern Dual Range Slider sistemi
 */
function initializeModernDualRange() {
    const minSlider = document.getElementById('groupMinSlider');
    const maxSlider = document.getElementById('groupMaxSlider');
    const minValue = document.getElementById('groupMinValue');
    const maxValue = document.getElementById('groupMaxValue');
    
    if (!minSlider || !maxSlider || !minValue || !maxValue) return;
    
    function updateValues() {
        let minVal = parseInt(minSlider.value);
        let maxVal = parseInt(maxSlider.value);
        
        // Min değer max değerden büyük olamaz
        if (minVal > maxVal) {
            minVal = maxVal;
            minSlider.value = minVal;
        }
        
        // Max değer min değerden küçük olamaz
        if (maxVal < minVal) {
            maxVal = minVal;
            maxSlider.value = maxVal;
        }
        
        minValue.textContent = minVal;
        maxValue.textContent = maxVal;
        
        // İstatistikleri güncelle
        updateModernStats();
    }
    
    minSlider.addEventListener('input', updateValues);
    maxSlider.addEventListener('input', updateValues);
    
    // İlk değerleri ayarla
    updateValues();
}

/**
 * Modern Scoring sistemi
 */
function initializeModernScoring() {
    const passRateSlider = document.getElementById('passRateSlider');
    const passRateValue = document.getElementById('passRateValue');
    
    if (!passRateSlider || !passRateValue) return;
    
    passRateSlider.addEventListener('input', function() {
        const value = parseInt(this.value);
        passRateValue.textContent = value + '%';
        
        // Pass/Fail hesaplamalarını güncelle
        updatePassFailCounts();
    });
    
    // İlk değeri ayarla
    passRateValue.textContent = passRateSlider.value + '%';
    updatePassFailCounts();
    
    // Grup slider'larının sınırlarını başlangıçta ayarla
    updateGroupSliderLimits();
}

/**
 * Pass/Fail sayılarını güncelle
 */
function updatePassFailCounts() {
    console.log('🔍 updatePassFailCounts çağrıldı');
    
    const passRateSlider = document.getElementById('passRateSlider');
    const passStudentCount = document.getElementById('passStudentCount');
    const failStudentCount = document.getElementById('failStudentCount');
    const passRateDisplay = document.getElementById('passRateDisplay');
    const failRateDisplay = document.getElementById('failRateDisplay');
    const studentCountDisplay = document.getElementById('studentCountDisplay');
    const groupCountDisplay = document.getElementById('groupCountDisplay');
    
    console.log('🔍 DOM elementleri:', {
        passRateSlider: !!passRateSlider,
        passStudentCount: !!passStudentCount,
        failStudentCount: !!failStudentCount,
        passRateDisplay: !!passRateDisplay,
        failRateDisplay: !!failRateDisplay,
        studentCountDisplay: !!studentCountDisplay,
        groupCountDisplay: !!groupCountDisplay
    });
    
    if (!passRateSlider || !passStudentCount || !failStudentCount) {
        console.warn('⚠️ Gerekli DOM elementleri bulunamadı');
        return;
    }
    
    // Gerçek öğrenci sayısını al
    const totalStudents = getTotalStudentCount();
    const passRate = parseInt(passRateSlider.value);
    const failRate = 100 - passRate;
    
    console.log('🔍 Veriler:', {
        totalStudents,
        passRate,
        failRate,
        studentDataLength: APP_STATE.studentData?.length || 0,
        appStateStudentData: !!APP_STATE.studentData
    });
    
    // Gerçek not verilerini kontrol et
    let actualPassCount = 0;
    let actualFailCount = 0;
    let hasActualGrades = false;
    
    if (totalStudents > 0 && APP_STATE.gradesData) {
        APP_STATE.studentData.forEach(student => {
            const studentGrades = APP_STATE.gradesData[student.studentId];
            if (studentGrades && studentGrades.harfNotu) {
                hasActualGrades = true;
                const letterGrade = studentGrades.harfNotu;
                // AA, BA, BB, CB, CC, DC = geçer, DD, FD, FF = kalır
                const passingGrades = ['AA', 'BA', 'BB', 'CB', 'CC', 'DC'];
                if (passingGrades.includes(letterGrade)) {
                    actualPassCount++;
                } else {
                    actualFailCount++;
                }
            }
        });
    }
    
    // Hesaplanan veya gerçek sayıları kullan
    let displayPassCount, displayFailCount;
    let displayPassRate, displayFailRate;
    
    if (hasActualGrades && (actualPassCount > 0 || actualFailCount > 0)) {
        // Gerçek not verileri varsa onları kullan
        displayPassCount = actualPassCount;
        displayFailCount = actualFailCount;
        displayPassRate = Math.round((actualPassCount / totalStudents) * 100);
        displayFailRate = Math.round((actualFailCount / totalStudents) * 100);
        console.log('📊 Gerçek not verileri kullanılıyor');
    } else {
        // Tahmini hesaplama yap
        displayPassCount = Math.round(totalStudents * passRate / 100);
        displayFailCount = totalStudents - displayPassCount;
        displayPassRate = passRate;
        displayFailRate = failRate;
        console.log('📊 Tahmini hesaplama kullanılıyor');
    }
    
    // Status badge'lerdeki öğrenci sayılarını güncelle
    passStudentCount.textContent = displayPassCount;
    failStudentCount.textContent = displayFailCount;
    
    // Oran gösterimlerini güncelle
    if (passRateDisplay) {
        passRateDisplay.textContent = `${displayPassRate}%`;
    }
    
    if (failRateDisplay) {
        failRateDisplay.textContent = `${displayFailRate}%`;
    }
    
    // Toplam öğrenci sayısını güncelle
    if (studentCountDisplay) {
        studentCountDisplay.textContent = totalStudents;
        console.log('✅ studentCountDisplay güncellendi:', totalStudents);
    } else {
        console.warn('⚠️ studentCountDisplay elementi bulunamadı');
    }
    
    // Grup bilgisi artık kategori detaylarında gösteriliyor
    
    console.log(`🎯 İstatistikler güncellendi: Toplam ${totalStudents} öğrenci, Geçecek ${displayPassCount} (%${displayPassRate}), Kalacak ${displayFailCount} (%${displayFailRate})`);
}

/**
 * Modern istatistikleri güncelle
 */
function updateModernStats() {
    const totalStudentsCount = document.getElementById('totalStudentsCount');
    const activeGroupsCount = document.getElementById('activeGroupsCount');
    
    if (totalStudentsCount) {
        totalStudentsCount.textContent = getTotalStudentCount();
    }
    
    if (activeGroupsCount) {
        activeGroupsCount.textContent = getActiveGroupsCount();
    }
}

/**
 * Toplam öğrenci sayısını al
 */
function getTotalStudentCount() {
    if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
        return APP_STATE.studentData.length;
    }
    return 0;
}

/**
 * Ana bileşen bazlı grup sayısı bilgisini al - Sadece ana etkinlikleri göster (A1, A2, F1...)
 */
function getActiveGroupsCount() {
    try {
        // courseData.grupHaritalari'ndan sadece ana bileşenlerin grup sayılarını al
        if (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari) {
            const mainComponentGroupCounts = [];
            
            Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
                // Sadece ana bileşenleri al (A1, A2, F1... - alt sorular değil A1.1, A1.2...)
                if (componentId.match(/^[AF]\d+$/) && !componentId.includes('.')) {
                    const component = APP_STATE.courseData.grupHaritalari[componentId];
                    if (component && component.gruplar && Array.isArray(component.gruplar)) {
                        // Sadece geçerli grupları say
                        const validGroups = component.gruplar.filter(group => 
                            group && group.length === 1 && /^[A-Z]$/.test(group)
                        );
                        
                        if (validGroups.length > 0) {
                            mainComponentGroupCounts.push({
                                id: componentId,
                                name: componentId,
                                count: validGroups.length
                            });
                        }
                    }
                }
            });
            
            console.log('🔍 Ana bileşen grup sayıları:', mainComponentGroupCounts);
            
            if (mainComponentGroupCounts.length > 0) {
                // Eğer tüm bileşenler aynı grup sayısına sahipse kısa format
                const allCounts = mainComponentGroupCounts.map(comp => comp.count);
                const uniqueCounts = [...new Set(allCounts)];
                
                if (uniqueCounts.length === 1) {
                    // Tüm bileşenler aynı grup sayısına sahip
                    const groupCount = uniqueCounts[0];
                    return `${mainComponentGroupCounts.length} bileşen × ${groupCount} grup`;
                } else {
                    // Farklı grup sayıları var, detaylı göster
                    return mainComponentGroupCounts.map(comp => `${comp.name}:${comp.count}`).join(', ');
                }
            }
        }
        
        // Fallback: Öğrenci verilerinden tek grup sayısı
        if (APP_STATE.studentData && APP_STATE.studentData.length > 0) {
            const uniqueGroups = new Set();
            APP_STATE.studentData.forEach(student => {
                if (student.grup && student.grup.length === 1 && /^[A-Z]$/.test(student.grup)) {
                    uniqueGroups.add(student.grup);
                }
            });
            
            if (uniqueGroups.size > 0) {
                return `${uniqueGroups.size} grup (tüm bileşenler)`;
            }
    }
    
        // Son çare: Varsayılan
        console.log('🔍 Hiç grup bulunamadı, varsayılan döndürülüyor');
        return '1 grup';
        
    } catch (error) {
        console.error('❌ getActiveGroupsCount hatası:', error);
        return 'Hata';
    }
}

/**
 * Grup detayları tooltip'ini güncelle
 */
function updateGroupDetailsTooltip() {
    try {
        const groupDetailsContent = document.getElementById('groupDetailsContent');
        if (!groupDetailsContent) return;
        
        let html = '';
        
        // courseData.grupHaritalari'ndan sadece ana bileşenlerin detaylı grup bilgilerini al
    if (APP_STATE.courseData && APP_STATE.courseData.grupHaritalari) {
            const componentDetails = [];
            
            Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
                // Sadece ana bileşenleri al (A1, A2, F1... - alt sorular değil A1.1, A1.2...)
                if (componentId.match(/^[AF]\d+$/) && !componentId.includes('.')) {
                    const component = APP_STATE.courseData.grupHaritalari[componentId];
                    if (component && component.gruplar && Array.isArray(component.gruplar)) {
                        // Bileşen adını al ve formatla
                        const activityNode = APP_STATE.assessmentTree?.find(node => node.id === componentId);
                        let componentName = componentId;
                        
                        if (activityNode) {
                            // Emoji'yi belirle
                            let emoji = '📝';
                            if (activityNode.type.includes('Ev Ödevi') || activityNode.type.includes('Ödev')) emoji = '📚';
                            else if (activityNode.type.includes('Laboratuvar') || activityNode.type.includes('Lab')) emoji = '⚗️';
                            else if (activityNode.type.includes('Final')) emoji = '🎯';
                            else if (activityNode.type.includes('Quiz')) emoji = '❓';
                            else if (activityNode.type.includes('Proje')) emoji = '🚀';
                            else if (activityNode.type.includes('Rapor')) emoji = '📊';
                            else if (activityNode.type.includes('Sunum')) emoji = '🎤';
                            
                            // Alt bileşen sayısını hesapla
                            const subComponentCount = activityNode.children ? activityNode.children.length : 0;
                            let subComponentText = '';
                            
                            if (subComponentCount > 0) {
                                // Alt bileşenlerin tipini belirle
                                const firstChild = activityNode.children[0];
                                if (firstChild.type === 'Soru' || firstChild.type.includes('Soru')) {
                                    subComponentText = ` (${subComponentCount} Soru)`;
                                } else if (firstChild.type === 'Rubrik' || firstChild.type.includes('Rubrik')) {
                                    subComponentText = ` (${subComponentCount} Rubrik)`;
                                } else {
                                    subComponentText = ` (${subComponentCount} Bileşen)`;
                                }
                            } else {
                                subComponentText = ' (Boş)';
                            }
                            
                            // Ağırlık bilgisini al
                            const weight = activityNode.weight || 0;
                            
                            componentName = `${emoji} ${activityNode.name} %${weight}${subComponentText}`;
                        }
                        
                        // Sadece geçerli grupları say
                        const validGroups = component.gruplar.filter(group => 
                            group && group.length === 1 && /^[A-Z]$/.test(group)
                        );
                        
                        if (validGroups.length > 0) {
                            componentDetails.push({
                                name: componentName,
                                gruplar: validGroups,
                                count: validGroups.length
                            });
                        }
                    }
                }
            });
            
            if (componentDetails.length > 0) {
                // Bileşen bazlı grup detayları
                componentDetails.forEach(detail => {
                    html += `
                        <div class="group-detail-item">
                            <div class="group-detail-name">${detail.name}</div>
                            <div>
                                <span class="group-detail-groups">${detail.gruplar.join(', ')}</span>
                                <span class="group-count-badge">${detail.count}</span>
                            </div>
                        </div>
                    `;
                });
                
                                 // Bileşen sayısı ve grup dağılımı özeti
                 const totalComponents = componentDetails.length;
                 const groupCounts = componentDetails.map(detail => detail.count);
                 const minGroups = Math.min(...groupCounts);
                 const maxGroups = Math.max(...groupCounts);
                 
                 html += `
                     <div class="group-detail-item" style="border-top: 2px solid #e9ecef; margin-top: 8px; padding-top: 8px; font-weight: 600;">
                         <div class="group-detail-name">📊 Bileşen Özeti</div>
                         <div>
                             <span class="group-detail-groups">${totalComponents} bileşen, ${minGroups === maxGroups ? minGroups : `${minGroups}-${maxGroups}`} grup/bileşen</span>
                             <span class="group-count-badge" style="background: #4caf50; color: white;">${totalComponents}</span>
                         </div>
                     </div>
                 `;
            } else {
                html = '<div class="group-detail-item"><div class="group-detail-name">Henüz grup tanımlanmamış</div></div>';
            }
        } else {
            html = '<div class="group-detail-item"><div class="group-detail-name">Grup verisi bulunamadı</div></div>';
        }
        
        groupDetailsContent.innerHTML = html;
        
    } catch (error) {
        console.error('❌ updateGroupDetailsTooltip hatası:', error);
    }
}

/**
 * Akıllı puan dağılımı - 100 puan garantisi
 */
function distributePointsIntelligently(componentCount, totalPoints = 100) {
    if (componentCount <= 0) return [];
    
    // Temel puan dağılımı
    const basePoints = Math.floor(totalPoints / componentCount);
    const remainder = totalPoints % componentCount;
    
    const points = new Array(componentCount).fill(basePoints);
    
    // Kalan puanları dağıt
    for (let i = 0; i < remainder; i++) {
        points[i]++;
    }
    
    // Toplam kontrolü
    const actualTotal = points.reduce((sum, point) => sum + point, 0);
    if (actualTotal !== totalPoints) {
        // Son elemana farkı ekle/çıkar
        points[points.length - 1] += (totalPoints - actualTotal);
    }
    
    return points;
}

/**
 * Etkinlik ağırlıklarını otomatik oranla
 */
function autoBalanceActivityWeights() {
    const termActivities = getActivitiesByType('term');
    const finalActivities = getActivitiesByType('final');
    
    // Yarıyıl içi ağırlıkları oranla (40%)
    if (termActivities.length > 0) {
        const termWeights = distributePointsIntelligently(termActivities.length, 40);
        termActivities.forEach((activity, index) => {
            if (activity.weightElement) {
                activity.weightElement.value = termWeights[index];
            }
        });
    }
    
    // Yarıyıl sonu ağırlıkları oranla (60%)
    if (finalActivities.length > 0) {
        const finalWeights = distributePointsIntelligently(finalActivities.length, 60);
        finalActivities.forEach((activity, index) => {
            if (activity.weightElement) {
                activity.weightElement.value = finalWeights[index];
            }
        });
    }
    
    // Kategori ağırlıklarını güncelle
    updateCategoryWeights();
}

/**
 * Modern Test Operations Event Listeners
 */
function initializeModernEventListeners() {
    // Yarıyıl İçi Değerlendirme Oluştur - Artık çoklu fonksiyon kullanıyor
    const btnTermAssessment = document.getElementById('btnGenerateRandomTermAssessment');
    if (btnTermAssessment) {
        btnTermAssessment.addEventListener('click', function() {
            generateMultipleRandomTermAssessments();
        });
    }
    
    // Yarıyıl Sonu Değerlendirme Oluştur - Artık çoklu fonksiyon kullanıyor
    const btnFinalAssessment = document.getElementById('btnGenerateRandomFinalAssessment');
    if (btnFinalAssessment) {
        btnFinalAssessment.addEventListener('click', function() {
            generateMultipleRandomFinalAssessments();
        });
    }
    
    // Test Öğrencileri Oluştur
    const btnTestStudents = document.getElementById('btnGenerateTestStudents');
    if (btnTestStudents) {
        btnTestStudents.addEventListener('click', generateTestStudents);
    }
    
    // Test Ders Verisi Oluştur
    const btnTestCourse = document.getElementById('btnGenerateTestCourseData');
    if (btnTestCourse) {
        btnTestCourse.addEventListener('click', generateTestCourseData);
    }
    
    // Rastgele Gruplar Oluştur
    const btnRandomGroups = document.getElementById('btnGenerateRandomGroups');
    if (btnRandomGroups) {
        btnRandomGroups.addEventListener('click', function() {
            const minGroups = parseInt(document.getElementById('groupMinSlider').value);
            const maxGroups = parseInt(document.getElementById('groupMaxSlider').value);
            generateRandomGroupsInRange(minGroups, maxGroups);
        });
    }
    
    // Akıllı Puanlama Uygula
    const btnSmartScoring = document.getElementById('btnGenerateRandomScores');
    if (btnSmartScoring) {
        btnSmartScoring.addEventListener('click', function() {
            const passRate = parseInt(document.getElementById('passRateSlider').value);
            generateIntelligentScores(passRate);
        });
    }
    
    // Temizleme Butonları - DUPLICATE EVENT LISTENER SORUNU ÇÖZÜLDÜ
    // Bu event listener'lar testButtons forEach döngüsü ile zaten ekleniyor
    // Bu nedenle buradaki duplicate listener'ları kaldırıyoruz
    console.log("ℹ️ Temizleme butonları event listener'ları testButtons döngüsü ile yönetiliyor");
    
    const btnTestToast = document.getElementById('btnTestToast');
    if (btnTestToast) {
        btnTestToast.addEventListener('click', testToastSystem);
    }
}

/**
 * Rastgele gruplar aralık içinde oluştur
 */
/**
 * Grup slider'larının maksimum değerlerini öğrenci sayısına göre güncelleme
 */
function updateGroupSliderLimits() {
    const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
    const minSlider = document.getElementById('groupMinSlider');
    const maxSlider = document.getElementById('groupMaxSlider');
    
    let maxAllowedGroups;
    
    if (studentCount === 0) {
        // Öğrenci yoksa test amaçlı 20 grup'a kadar izin ver
        maxAllowedGroups = 20;
        console.log(`🎯 Grup slider'ları test modunda - Öğrenci yok, 20 grup'a kadar izin veriliyor`);
    } else {
        // Öğrenci varsa öğrenci sayısı ile sınırla (minimum 20 grup)
        maxAllowedGroups = Math.max(studentCount, 20); // En az 20, öğrenci sayısı daha fazlaysa o kadar
        
        if (studentCount < 20) {
            console.log(`🎯 Grup slider'ları güncellendi - Öğrenci sayısı: ${studentCount}, Max grup: ${studentCount} (boş grup önleme)`);
        } else {
            console.log(`🎯 Grup slider'ları güncellendi - Öğrenci sayısı: ${studentCount}, Max grup: ${maxAllowedGroups}`);
        }
    }
        
        if (minSlider) {
            minSlider.max = maxAllowedGroups;
            // Eğer mevcut değer sınırı aşıyorsa düşür
            if (parseInt(minSlider.value) > maxAllowedGroups) {
                minSlider.value = maxAllowedGroups;
                const minValueDisplay = document.getElementById('groupMinValue');
                if (minValueDisplay) minValueDisplay.textContent = maxAllowedGroups;
            }
        }
        
        if (maxSlider) {
            maxSlider.max = maxAllowedGroups;
            // Eğer mevcut değer sınırı aşıyorsa düşür
            if (parseInt(maxSlider.value) > maxAllowedGroups) {
                maxSlider.value = maxAllowedGroups;
                const maxValueDisplay = document.getElementById('groupMaxValue');
                if (maxValueDisplay) maxValueDisplay.textContent = maxAllowedGroups;
            }
    }
}

function generateRandomGroupsInRange(minGroups, maxGroups) {
    if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
        showModernToast('Önce öğrenci verileri oluşturun!', 'warning');
        return;
    }
    
    const studentCount = APP_STATE.studentData.length;
    
    // UYARI: Öğrenci sayısından fazla grup oluşturma kontrolü
    if (minGroups > studentCount) {
        showModernToast(`⚠️ Uyarı: Minimum grup sayısı (${minGroups}) öğrenci sayısından (${studentCount}) fazla! Boş gruplar oluşmasın diye maksimum ${studentCount} grup oluşturulabilir.`, "warning");
        return;
    }
    
    if (maxGroups > studentCount) {
        showModernToast(`⚠️ Uyarı: Maksimum grup sayısı (${maxGroups}) öğrenci sayısından (${studentCount}) fazla! Boş gruplar oluşmasın diye en fazla ${studentCount} grup oluşturulabilir.`, "warning");
        // Maksimum grup sayısını öğrenci sayısı ile sınırla
        maxGroups = Math.min(maxGroups, studentCount);
    }
    
    const actualGroupCount = Math.floor(Math.random() * (maxGroups - minGroups + 1)) + minGroups;
    generateRandomGroups();
    
    showModernToast(`Rastgele grup oluşturma tamamlandı! ${actualGroupCount} grup oluşturuldu.`, 'success');
    updateModernStats();
}

/**
 * Akıllı puanlama sistemi
 */
/**
 * Akıllı puanlama sistemi (Onay ile)
 */
function generateIntelligentScores(targetPassRate) {
    // Mevcut verileri kontrol et
    const hasStudents = APP_STATE.studentData && APP_STATE.studentData.length > 0;
    const hasAssessments = APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0;
    
    // Mevcut puanları daha hassas kontrol et
    let hasExistingScores = false;
    let existingScoreCount = 0;
    
    // gradesData kontrolü - sadece gerçek veri varsa
    if (APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0) {
        for (const studentId in APP_STATE.gradesData) {
            if (APP_STATE.gradesData[studentId] && Object.keys(APP_STATE.gradesData[studentId]).length > 0) {
                hasExistingScores = true;
                existingScoreCount += Object.keys(APP_STATE.gradesData[studentId]).length;
            }
        }
    }
    
    // testScores kontrolü
    if (APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0) {
        hasExistingScores = true;
        existingScoreCount += Object.keys(APP_STATE.testScores).length;
    }
    
    console.log('🔍 hasExistingScores kontrolü:', {
        hasExistingScores,
        existingScoreCount,
        gradesDataKeys: Object.keys(APP_STATE.gradesData || {}),
        testScoresKeys: Object.keys(APP_STATE.testScores || {})
    });
    
    if (!hasStudents) {
        showModernToast('Önce öğrenci verileri oluşturun!', 'warning');
        return;
    }
    
    if (!hasAssessments) {
        showModernToast('Önce değerlendirme bileşenleri oluşturun!', 'warning');
        return;
    }
    
    // targetPassRate parametresi yoksa slider'dan al
    if (targetPassRate === undefined) {
        const passRateSlider = document.getElementById('passRateSlider');
        targetPassRate = passRateSlider ? parseInt(passRateSlider.value) : 70;
    }
    
    const studentCount = APP_STATE.studentData.length;
    const assessmentCount = APP_STATE.assessmentTree.length;
    const passCount = Math.round(studentCount * targetPassRate / 100);
    const failCount = studentCount - passCount;
    
    let warningMessage = '';
    
    if (hasExistingScores) {
        const existingScoreCount = Object.keys(APP_STATE.gradesData || {}).length + Object.keys(APP_STATE.testScores || {}).length;
        warningMessage = `Mevcut not verileri silinecek ve yeniden oluşturulacak!\n\n${studentCount} öğrenci için ${assessmentCount} değerlendirme bileşeninde %${targetPassRate} geçme oranına göre akıllı puanlama yapılacak.\n\n• ${passCount} öğrenci geçecek\n• ${failCount} öğrenci kalacak\n\nMevcut ${existingScoreCount} not verisi kaybolacak. Bu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    } else {
        warningMessage = `${studentCount} öğrenci için ${assessmentCount} değerlendirme bileşeninde %${targetPassRate} geçme oranına göre akıllı puanlama yapılacak.\n\n• ${passCount} öğrenci geçecek\n• ${failCount} öğrenci kalacak\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    }
    
    showModernConfirm('🧠 Akıllı Puanlama Sistemi Uygula', warningMessage, {
            confirmText: 'Evet, Uygula',
            cancelText: 'İptal',
        confirmClass: 'btn-modern-warning',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
        executeGenerateIntelligentScores(targetPassRate);
    });
}

/**
 * Akıllı puanlama sistemi (Gerçek işlem)
 */
function executeGenerateIntelligentScores(targetPassRate) {
    if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
        showModernToast('Önce öğrenci verileri oluşturun!', 'warning');
        return;
    }
    
    if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
        showModernToast('Önce değerlendirme bileşenleri oluşturun!', 'warning');
        return;
    }
    
    // Akıllı puanlama algoritması
    const students = APP_STATE.studentData;
    const passCount = Math.round(students.length * targetPassRate / 100);
    
    // Her öğrenci için puanlar oluştur
    students.forEach((student, index) => {
        const shouldPass = index < passCount;
        generateStudentScores(student.studentId, shouldPass);
    });
    
    showModernToast(`Hedef %${targetPassRate} geçme oranıyla puanlar oluşturuldu!`, 'success');
    updatePassFailCounts();
    
    // Güvenli fonksiyon çağrısı
    if (typeof updateGradeDisplays === 'function') {
        updateGradeDisplays();
    } else {
        console.log('updateGradeDisplays fonksiyonu henüz tanımlı değil');
        updateModernStats();
    }
    
    // Değerlendirme görünümünü güncelle
    if (typeof updateAssessmentView === 'function') {
        updateAssessmentView();
    }
    
    console.log('🎯 Akıllı puanlama tamamlandı - APP_STATE.gradesData:', APP_STATE.gradesData);
}

/**
 * Öğrenci için akıllı puanlar oluştur
 */
function generateStudentScores(studentId, shouldPass) {
    if (!APP_STATE.gradesData) {
        APP_STATE.gradesData = {};
    }
    
    if (!APP_STATE.gradesData[studentId]) {
        APP_STATE.gradesData[studentId] = {};
    }
    
    const studentGrades = APP_STATE.gradesData[studentId];
    
    // Her değerlendirme bileşeni için puan oluştur
    APP_STATE.assessmentTree.forEach(node => {
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                generateComponentScore(child, studentGrades, shouldPass);
            });
        }
    });
}

/**
 * Bileşen için akıllı puan oluştur
 */
function generateComponentScore(component, studentGrades, shouldPass) {
    const componentId = component.id;
    
    if (component.children && component.children.length > 0) {
        // Alt bileşenler varsa onlar için de puan oluştur
        component.children.forEach(child => {
            generateComponentScore(child, studentGrades, shouldPass);
        });
    } else {
        // Yaprak düğüm - gerçek puan oluştur
        const maxPoints = parseFloat(component.points) || 100;
        let score;
        
        if (shouldPass) {
            // Geçecek öğrenci: Güvenli geçme aralığı (65-95 arası)
            // %15 ihtimalle mükemmel (90-95)
            // %35 ihtimalle çok iyi (80-90)  
            // %50 ihtimalle iyi (65-80)
            const rand = Math.random();
            if (rand < 0.15) {
                score = Math.random() * 5 + 90; // 90-95 mükemmel
            } else if (rand < 0.50) {
                score = Math.random() * 10 + 80; // 80-90 çok iyi
        } else {
                score = Math.random() * 15 + 65; // 65-80 iyi
            }
        } else {
            // Kalacak öğrenci: Güvenli kalma aralığı (10-60 arası)
            // %20 ihtimalle çok düşük (10-30)
            // %40 ihtimalle düşük (30-45)
            // %40 ihtimalle orta-düşük (45-60)
            const rand = Math.random();
            if (rand < 0.20) {
                score = Math.random() * 20 + 10; // 10-30 çok düşük
            } else if (rand < 0.60) {
                score = Math.random() * 15 + 30; // 30-45 düşük
            } else {
                score = Math.random() * 15 + 45; // 45-60 orta-düşük
            }
        }
        
        // Puanı maksimum puana göre ölçekle
        const actualScore = (score / 100) * maxPoints;
        studentGrades[componentId] = Math.round(actualScore * 100) / 100;
    }
}

// Modern Toast fonksiyonu zaten yukarıda tanımlı

/**
 * Not görünümlerini güncelle
 */
// İlk updateGradeDisplays fonksiyonu kaldırıldı - gelişmiş versiyon korundu

/**
 * Öğrenci görünümlerini güncelle
 */
function updateStudentDisplays() {
    // Öğrenci tablosunu güncelle
    if (typeof updateStudentTable === 'function') {
        updateStudentTable();
    }
    
    // updateStudentSelector fonksiyonu kaldırıldı (Öğrenci Bazlı Not Girişi sekmesi ile birlikte)
    
    console.log('Öğrenci görünümleri güncellendi');
}

/**
 * Grup görünümlerini güncelle
 */
function updateGroupDisplays() {
    // Grup bilgilerini güncelle
    if (typeof updateGroupInfo === 'function') {
        updateGroupInfo();
    }
    
    // Grup istatistiklerini güncelle
    if (typeof updateGroupStatistics === 'function') {
        updateGroupStatistics();
    }
    
    console.log('Grup görünümleri güncellendi');
}

/**
 * Tüm değerlendirmeleri temizle
 */
function clearAllAssessments() {
    showModernConfirm('🗑️ Tüm Değerlendirmeleri Sil', 'Tüm değerlendirme bileşenlerini silmek istediğinizden emin misiniz? Bu işlem geri alınamaz!', {
        confirmText: 'Evet, Sil',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-danger',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            APP_STATE.assessmentTree = [];
            renderTree();
            updateCategoryWeights();
            updatePassFailCounts();
            showModernToast('🗑️ Tüm değerlendirmeler temizlendi!', 'success');
    });
}

/**
 * Tüm grupları temizle
 */
function clearAllGroups() {
    showModernConfirm('👥 Tüm Grupları Sil', 'Tüm grup atamalarını silmek istediğinizden emin misiniz?\n\n• Tüm öğrenci grup atamaları silinecek\n• Grup haritalama verileri silinecek\n• Değerlendirme yapısı korunacak\n\nBu işlem geri alınamaz!', {
        confirmText: 'Evet, Sil',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-danger',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            performClearGroups();
    });
}

/**
 * Tüm puanları temizle
 */
function clearAllScores() {
    showModernConfirm('📊 Tüm Puanları Sil', 'Tüm öğrenci puanlarını silmek istediğinizden emin misiniz?\n\n• Tüm not girişleri silinecek\n• Değerlendirme yapısı korunacak\n• Grup atamaları korunacak\n\nBu işlem geri alınamaz!', {
        confirmText: 'Evet, Sil',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-danger',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            performClearScores();
    });
}

/**
 * Tüm öğrencileri temizle
 */
function clearAllStudents() {
    // Önce silinecek öğrenci var mı kontrol et
    const hasStudents = (APP_STATE.studentData && APP_STATE.studentData.length > 0) || 
                       (APP_STATE.students && APP_STATE.students.length > 0);
    
    if (!hasStudents) {
        showModernToast("ℹ️ Silinecek öğrenci bulunmuyor.", "info");
        return;
    }
    
    showModernConfirm('🎓 Tüm Öğrencileri Sil', 'Tüm öğrenci verilerini silmek istediğinizden emin misiniz?\n\n• Öğrenci listesi silinecek\n• Tüm notlar silinecek\n• Grup atamaları silinecek\n• Değerlendirme yapısı korunacak\n\nBu işlem geri alınamaz!', {
        confirmText: 'Evet, Sil',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-danger',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            performClearStudentsOnly();
    });
}

/**
 * Sistemi tamamen resetle
 */
function resetCompleteSystem() {
    console.log("🔧 resetCompleteSystem başlatıldı");
    
    // Sistemi resetlemek için en azından bir veri var mı kontrol et
    const hasAnyData = (APP_STATE.studentData && APP_STATE.studentData.length > 0) ||
                      (APP_STATE.students && APP_STATE.students.length > 0) ||
                      (APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0) ||
                      (APP_STATE.courseData && Object.keys(APP_STATE.courseData).length > 0) ||
                      (APP_STATE.gradesData && Object.keys(APP_STATE.gradesData).length > 0) ||
                      (APP_STATE.testScores && Object.keys(APP_STATE.testScores).length > 0);
    
    if (!hasAnyData) {
        showModernToast("ℹ️ Sistem zaten boş durumda, resetleme gerekmiyor.", "info");
        return;
    }
    
    showModernConfirm('🔄 Sistemi Tamamen Resetle', 'Sistemi tamamen sıfırlamak istediğinizden emin misiniz?\n\n• Ders bilgileri silinecek\n• Tüm öğrenciler silinecek\n• Tüm değerlendirmeler silinecek\n• Tüm notlar silinecek\n• Tüm gruplar silinecek\n\nBu işlem geri alınamaz ve sistem başlangıç durumuna dönecek!', {
        confirmText: 'Evet, Resetle',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-danger',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            console.log("✅ resetCompleteSystem onaylandı, resetleme başlıyor...");
            performResetSystem();
    });
}

/**
 * Toast sistemini test et
 */
function testToastSystem() {
    showModernConfirm('🧪 Toast Sistemini Test Et', 'Toast bildirim sistemini test etmek ister misiniz?\n\nFarklı türlerde toast mesajları gösterilecek.', {
        confirmText: 'Evet, Test Et',
        cancelText: 'İptal',
        confirmClass: 'btn-modern-primary',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
            performToastSystemTest();
    });
}

/**
 * Toast sistem testini gerçekleştir
 */
function performToastSystemTest() {
    let delay = 0;
    
    // Başarı toast'ı
    setTimeout(() => {
        showModernToast('✅ Başarılı işlem testi!', 'success');
    }, delay);
    delay += 1500;
    
    // Uyarı toast'ı
    setTimeout(() => {
        showModernToast('⚠️ Uyarı mesajı testi!', 'warning');
    }, delay);
    delay += 1500;
    
    // Hata toast'ı
    setTimeout(() => {
        showModernToast('❌ Hata mesajı testi!', 'error');
    }, delay);
    delay += 1500;
    
    // Bilgi toast'ı
    setTimeout(() => {
        showModernToast('ℹ️ Bilgi mesajı testi!', 'info');
    }, delay);
    delay += 1500;
    
    // Test tamamlandı
    setTimeout(() => {
        showModernToast('🎉 Toast sistem testi tamamlandı!', 'success');
    }, delay);
}

/**
 * Sistem resetleme işlemini gerçekleştir
 */
function performResetSystem() {
    try {
        console.log("🔧 performResetSystem başlatıldı");
        
        // 1. Tüm APP_STATE verilerini koordineli şekilde sıfırla
        APP_STATE.courseData = null;
        APP_STATE.students = [];
        APP_STATE.assessmentTree = [];
        APP_STATE.studentGrades = {};
        APP_STATE.groupMapping = {};
        APP_STATE.learningOutcomes = [];
        APP_STATE.programOutcomes = [];
        APP_STATE.outcomeMatrix = null;
        APP_STATE.selectedNode = null;
        APP_STATE.selectedStudentId = null;
        
        // 2. Eski format desteği için
        APP_STATE.studentData = [];
        APP_STATE.gradesData = {};
        APP_STATE.testScores = {};
        APP_STATE.gruplar = [];
        
        // 3. Ders bilgilerini sıfırla
        const courseTitle = document.getElementById('courseTitle');
        const courseDetails = document.getElementById('courseDetails');
        const courseTerm = document.getElementById('courseTerm');
        
        if (courseTitle) courseTitle.textContent = 'Ders Bilgileri';
        if (courseDetails) courseDetails.textContent = 'JSON dosyası yükleyiniz';
        if (courseTerm) courseTerm.textContent = '';
        
        // 4. UI'ları güvenli şekilde güncelle
        renderTree();
        updateStudentTable();
        updateAssessmentView();
        
        // 5. Not tablosunu güvenli şekilde temizle
        try {
            updateGradesTable([]);
        } catch (tableError) {
            console.warn("⚠️ Not tablosu güncellenirken hata (görmezden gelindi):", tableError);
            const gradesTable = document.getElementById('gradesTable');
            if (gradesTable) {
                const tbody = gradesTable.querySelector('tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="8" class="empty-message">Not girişi yapılmadı</td></tr>';
                }
            }
        }
        
        updateCategoryWeights();
        
        // 6. Eski format fonksiyonları varsa güvenli şekilde çağır
        if (typeof updateStudentDisplays === 'function') {
            updateStudentDisplays();
        }
        if (typeof updateGroupDisplays === 'function') {
            updateGroupDisplays();
        }
        if (typeof updateModernStats === 'function') {
            updateModernStats();
        }
        if (typeof updatePassFailCounts === 'function') {
            updatePassFailCounts();
        }
        if (typeof updateGroupSelectors === 'function') {
            updateGroupSelectors();
        }
        if (typeof updateTreeMappingControls === 'function') {
            updateTreeMappingControls();
        }
        
        // 7. Tüm containers'ı temizle
        const containers = [
            'studentGradesContainer',
            'assessmentContainer',
            'gradesTableContainer',
            'courseDetailsContainer',
            'outcomesList',
            'programOutcomesList',
            'matrixContainer'
        ];
        
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) {
                if (containerId === 'courseDetailsContainer') {
                    container.innerHTML = '<div class="details-empty-message">Ders detayları için JSON yükleyin.</div>';
                } else if (containerId === 'outcomesList') {
                    container.innerHTML = '<div class="outcomes-empty-message">Henüz öğrenme çıktısı tanımlanmadı. Ders JSON yükleyin.</div>';
                } else if (containerId === 'programOutcomesList') {
                    container.innerHTML = '<div class="outcomes-empty-message">Henüz program çıktısı tanımlanmadı. Ders JSON yükleyin.</div>';
                } else if (containerId === 'matrixContainer') {
                    container.innerHTML = '<div class="matrix-empty-message">ÖÇ-PÇ ilişki matrisi için ders JSON yükleyin.</div>';
                } else {
                    container.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
                }
            }
        });
        
        // 8. Tree container'ı özel mesajla
        const treeContainer = document.getElementById('treeContainer');
        if (treeContainer) {
            treeContainer.innerHTML = '<div class="tree-empty-message">Henüz değerlendirme bileşeni eklenmedi. Ders JSON yükleyin veya yeni bileşenler ekleyin.</div>';
        }
        
        showModernToast("🔄 Sistem tamamen ve koordineli şekilde sıfırlandı!", "success", 4000);
        
    } catch (error) {
        console.error("❌ Sistem resetlenirken hata:", error);
        showModernToast("❌ Sistem resetlenirken hata oluştu!", "error");
    }
}

/**
 * Grup temizleme işlemini gerçekleştir
 */
function performClearGroups() {
    try {
        // Grup haritalamalarını temizle
        if (APP_STATE.courseData) {
            APP_STATE.courseData.grupHaritalari = {};
        }
        APP_STATE.groupMapping = {};
        
        // Öğrencilerin gruplarını varsayılan gruba ata
        if (APP_STATE.students) {
            APP_STATE.students.forEach(student => {
                student.grup = 'A';
            });
        }
        if (APP_STATE.studentData) {
            APP_STATE.studentData.forEach(student => {
                student.grup = 'A';
            });
        }
        
        // Eski format desteği
        APP_STATE.gruplar = [];
        
        // UI'ları güncelle
        if (typeof updateGroupSelectors === 'function') {
            updateGroupSelectors();
        }
        updateStudentTable();
        if (typeof updateTreeMappingControls === 'function') {
            updateTreeMappingControls();
        }
        if (typeof updateAllInlineGroupInputs === 'function') {
            updateAllInlineGroupInputs();
        }
        if (typeof updateAllMappingDisplays === 'function') {
            updateAllMappingDisplays();
        }
        updateAssessmentView();
        
        // Eski format fonksiyonları varsa çağır
        if (typeof updateGroupDisplays === 'function') {
            updateGroupDisplays();
        }
        if (typeof updateModernStats === 'function') {
            updateModernStats();
        }
        if (typeof updatePassFailCounts === 'function') {
            updatePassFailCounts();
        }
        
        showModernToast("👥 Tüm grup atamaları silindi!", "success");
        
    } catch (error) {
        console.error("Gruplar temizlenirken hata:", error);
        showModernToast("❌ Gruplar temizlenemedi!", "error");
    }
}

/**
 * Puan temizleme işlemini gerçekleştir
 */
function performClearScores() {
    try {
        APP_STATE.studentGrades = {};
        APP_STATE.gradesData = {};
        if (typeof APP_STATE.testScores !== 'undefined') {
            APP_STATE.testScores = {};
        }
        
        // UI'ları güncelle
        updateAssessmentView();
        updateGradesTable();
        
        // Öğrenci bazlı not girişi sekmesini temizle
        const studentGradesContainer = document.getElementById('studentGradesContainer');
        if (studentGradesContainer) {
            studentGradesContainer.innerHTML = '<p class="empty-message">Veri bulunamadı.</p>';
        }
        
        // Not tablosunu temizle
        const gradesTableContainer = document.getElementById('gradesTableContainer');
        if (gradesTableContainer) {
            gradesTableContainer.innerHTML = '<p class="empty-message">Henüz not hesaplanmadı.</p>';
        }
        
        // Eski format fonksiyonları varsa çağır
        if (typeof updateGradeDisplays === 'function') {
            updateGradeDisplays();
        }
        if (typeof updateModernStats === 'function') {
            updateModernStats();
        }
        if (typeof updatePassFailCounts === 'function') {
            updatePassFailCounts();
        }
        
        showModernToast("📊 Tüm öğrenci puanları silindi!", "success");
        
    } catch (error) {
        console.error("Puanlar temizlenirken hata:", error);
        showModernToast("❌ Puanlar temizlenemedi!", "error");
    }
}

/**
 * Öğrenci temizleme işlemini gerçekleştir
 */
function performClearStudentsOnly() {
    try {
        APP_STATE.students = [];
        APP_STATE.studentGrades = {};
        APP_STATE.groupMapping = {};
        
        // Eski format desteği
        APP_STATE.studentData = [];
        APP_STATE.gradesData = {};
        
        updateStudentTable();
        updateAssessmentView();
        updateGradesTable();
        
        // Eski format fonksiyonları varsa çağır
        if (typeof updateStudentDisplays === 'function') {
            updateStudentDisplays();
        }
        if (typeof updateModernStats === 'function') {
            updateModernStats();
        }
        if (typeof updatePassFailCounts === 'function') {
            updatePassFailCounts();
        }
        if (typeof updateGroupSliderLimits === 'function') {
            updateGroupSliderLimits(); // Grup slider'larını sıfırla
        }
        
        showModernToast("🎓 Tüm öğrenci verileri silindi!", "success");
        
    } catch (error) {
        console.error("Öğrenciler temizlenirken hata:", error);
        showModernToast("❌ Öğrenciler temizlenemedi!", "error");
    }
}

/**
 * Rastgele yarıyıl içi değerlendirme oluştur
 */
// İlk generateRandomTermAssessment fonksiyonu kaldırıldı - gelişmiş versiyon korundu

/**
 * Rastgele yarıyıl sonu değerlendirme oluştur
 */
// İlk generateRandomFinalAssessment fonksiyonu kaldırıldı - gelişmiş versiyon korundu

/**
 * Rastgele bileşen oluştur
 */
function createRandomComponent(isQuestion, type, index) {
    const questionTypes = ['Çoktan Seçmeli', 'Açık Uçlu', 'Doğru/Yanlış', 'Eşleştirme'];
    const rubricTypes = ['Proje Değerlendirme', 'Sunum Rubriği', 'Lab Raporu', 'Ödev Rubriği'];
    
    if (isQuestion) {
        return {
            id: generateUniqueId(),
            name: `${type === 'term' ? 'Ara' : 'Final'} Sınav Soru ${index}`,
            type: 'question',
            category: type,
            points: 0, // Daha sonra dağıtılacak
            questionType: questionTypes[Math.floor(Math.random() * questionTypes.length)],
            outcomes: getRandomOutcomes(),
            description: `${type === 'term' ? 'Yarıyıl içi' : 'Yarıyıl sonu'} değerlendirme sorusu`
        };
    } else {
        return {
            id: generateUniqueId(),
            name: `${type === 'term' ? 'Ara' : 'Final'} Rubrik ${index}`,
            type: 'rubric',
            category: type,
            points: 0, // Daha sonra dağıtılacak
            rubricType: rubricTypes[Math.floor(Math.random() * rubricTypes.length)],
            outcomes: getRandomOutcomes(),
            description: `${type === 'term' ? 'Yarıyıl içi' : 'Yarıyıl sonu'} rubrik değerlendirmesi`
        };
    }
}

/**
 * Yarıyıl içi ana düğümünü al veya oluştur
 */
function getOrCreateTermNode() {
    let termNode = APP_STATE.assessmentTree.find(node => node.category === 'term');
    if (!termNode) {
        termNode = {
            id: generateUniqueId(),
            name: 'Yarıyıl İçi Değerlendirme',
            type: 'term',
            category: 'term',
            weight: 40,
            children: []
        };
        APP_STATE.assessmentTree.push(termNode);
    }
    return termNode;
}

/**
 * Yarıyıl sonu ana düğümünü al veya oluştur
 */
function getOrCreateFinalNode() {
    let finalNode = APP_STATE.assessmentTree.find(node => node.category === 'final');
    if (!finalNode) {
        finalNode = {
            id: generateUniqueId(),
            name: 'Yarıyıl Sonu Değerlendirme',
            type: 'final',
            category: 'final',
            weight: 60,
            children: []
        };
        APP_STATE.assessmentTree.push(finalNode);
    }
    return finalNode;
}

// İkinci getRandomOutcomes fonksiyonu kaldırıldı - parametre alan versiyon korundu

// =====================================================
// ORAN DENGELEME SİSTEMİ
// =====================================================

/**
 * Dengeleme kontrolü yapar ve gerekirse modal gösterir
 * @param {string} category - 'term' veya 'final'
 * @param {number} addedCount - Eklenen bileşen sayısı
 */
function checkBalanceAndShowModal(category, addedCount) {
    const balanceStatus = analyzeBalanceStatus();
    
    if (balanceStatus.needsBalance) {
        showBalanceModal(category, addedCount, balanceStatus);
    } else {
        // Dengeleme gerekmiyor, sadece bilgi ver
        showModernToast(`${addedCount} adet ${category === 'term' ? 'yarıyıl içi' : 'yarıyıl sonu'} bileşen oluşturuldu!`, 'success');
    }
}

/**
 * Mevcut dengeleme durumunu analiz eder
 * @returns {Object} Dengeleme durumu bilgileri
 */
function analyzeBalanceStatus() {
    const termNodes = getNodesByCategory('term');
    const finalNodes = getNodesByCategory('final');
    
    // Yarıyıl içi analizi
    const termAnalysis = analyzeNodeGroup(termNodes, 'Yarıyıl İçi');
    const finalAnalysis = analyzeNodeGroup(finalNodes, 'Yarıyıl Sonu');
    
    // Genel ağırlık analizi
    const totalTermWeight = termNodes.reduce((sum, node) => sum + (node.weight || 0), 0);
    const totalFinalWeight = finalNodes.reduce((sum, node) => sum + (node.weight || 0), 0);
    const totalWeight = totalTermWeight + totalFinalWeight;
    
    const needsBalance = !termAnalysis.isBalanced || !finalAnalysis.isBalanced || totalWeight !== 100;
    
    return {
        needsBalance,
        termAnalysis,
        finalAnalysis,
        totalTermWeight,
        totalFinalWeight,
        totalWeight,
        issues: [
            ...termAnalysis.issues,
            ...finalAnalysis.issues,
            ...(totalWeight !== 100 ? [`Toplam ağırlık %${totalWeight} (olması gereken %100)`] : [])
        ]
    };
}

/**
 * Düğüm grubunu analiz eder
 * @param {Array} nodes - Analiz edilecek düğümler
 * @param {string} categoryName - Kategori adı
 * @returns {Object} Analiz sonucu
 */
function analyzeNodeGroup(nodes, categoryName) {
    const issues = [];
    let isBalanced = true;
    
    nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            const totalPoints = node.children.reduce((sum, child) => sum + (child.points || 0), 0);
            if (totalPoints !== 100) {
                issues.push(`${node.name}: ${totalPoints} puan (olması gereken 100)`);
                isBalanced = false;
            }
        }
    });
    
    return { isBalanced, issues, nodes };
}

/**
 * Kategori bazında düğümleri getirir
 * @param {string} category - Kategori ('term' veya 'final')
 * @returns {Array} Düğüm listesi
 */
function getNodesByCategory(category) {
    return APP_STATE.assessmentTree.filter(node => node.category === category);
}

/**
 * Dengeleme modalını gösterir
 * @param {string} category - Kategori
 * @param {number} addedCount - Eklenen bileşen sayısı
 * @param {Object} balanceStatus - Dengeleme durumu
 */
function showBalanceModal(category, addedCount, balanceStatus) {
    const modal = document.getElementById('balanceDistributionModal');
    const statusContainer = document.getElementById('currentBalanceStatus');
    
    if (!modal || !statusContainer) return;
    
    // Mevcut durum bilgisini oluştur
    let statusHTML = `
        <div class="status-category">
            <h5>📊 Mevcut Durum</h5>
            <div class="status-items">
    `;
    
    balanceStatus.issues.forEach(issue => {
        statusHTML += `<div class="status-item unbalanced">${issue}</div>`;
    });
    
    statusHTML += `
            </div>
        </div>
        <div class="status-category">
            <h5>🎯 Hedef</h5>
            <div class="status-items">
                <div class="status-item balanced">Yarıyıl İçi: Her sınav 100 puan</div>
                <div class="status-item balanced">Yarıyıl Sonu: Her sınav 100 puan</div>
                <div class="status-item balanced">Ağırlık Toplamı: %100</div>
            </div>
        </div>
    `;
    
    statusContainer.innerHTML = statusHTML;
    
    // Modal event listener'larını ayarla
    setupBalanceModalEvents(category, addedCount, balanceStatus);
    
    // Modal'ı aç
    openModernModal('balanceDistributionModal');
}

/**
 * Dengeleme modal event listener'larını ayarlar
 * @param {string} category - Kategori
 * @param {number} addedCount - Eklenen bileşen sayısı
 * @param {Object} balanceStatus - Dengeleme durumu
 */
function setupBalanceModalEvents(category, addedCount, balanceStatus) {
    // Önceki event listener'ları temizle
    const cards = document.querySelectorAll('.balance-option-card');
    const previewBtn = document.getElementById('previewBalanceBtn');
    const applyBtn = document.getElementById('applyBalanceBtn');
    
    // Seçim temizle
    cards.forEach(card => card.classList.remove('selected'));
    previewBtn.disabled = true;
    applyBtn.disabled = true;
    
    // Kart seçim event'leri
    cards.forEach(card => {
        const newCard = card.cloneNode(true);
        card.parentNode.replaceChild(newCard, card);
        
        newCard.addEventListener('click', () => {
            // Tüm seçimleri temizle
            document.querySelectorAll('.balance-option-card').forEach(c => c.classList.remove('selected'));
            // Bu kartı seç
            newCard.classList.add('selected');
            
            // Butonları etkinleştir
            previewBtn.disabled = false;
            applyBtn.disabled = false;
            
            // Seçilen opsiyon
            const selectedOption = newCard.getAttribute('data-option');
            
            // Event listener'ları güncelle
            setupButtonEvents(selectedOption, category, addedCount, balanceStatus);
        });
    });
}

/**
 * Buton event listener'larını ayarlar
 * @param {string} selectedOption - Seçilen dengeleme opsionu
 * @param {string} category - Kategori
 * @param {number} addedCount - Eklenen bileşen sayısı
 * @param {Object} balanceStatus - Dengeleme durumu
 */
function setupButtonEvents(selectedOption, category, addedCount, balanceStatus) {
    const previewBtn = document.getElementById('previewBalanceBtn');
    const applyBtn = document.getElementById('applyBalanceBtn');
    
    // Önceki event listener'ları temizle
    const newPreviewBtn = previewBtn.cloneNode(true);
    const newApplyBtn = applyBtn.cloneNode(true);
    previewBtn.parentNode.replaceChild(newPreviewBtn, previewBtn);
    applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
    
    // Önizleme butonu
    newPreviewBtn.addEventListener('click', () => {
        showBalancePreview(selectedOption, balanceStatus);
    });
    
    // Uygulama butonu
    newApplyBtn.addEventListener('click', () => {
        applyBalanceOption(selectedOption, balanceStatus);
        closeModernModal('balanceDistributionModal');
        showModernToast(`${addedCount} adet ${category === 'term' ? 'yarıyıl içi' : 'yarıyıl sonu'} bileşen oluşturuldu ve dengeleme uygulandı!`, 'success');
    });
}

/**
 * Dengeleme önizlemesini gösterir
 * @param {string} selectedOption - Seçilen dengeleme opsionu
 * @param {Object} balanceStatus - Dengeleme durumu
 */
function showBalancePreview(selectedOption, balanceStatus) {
    const previewSection = document.getElementById('balancePreview');
    const previewContent = document.getElementById('previewContent');
    
    if (!previewSection || !previewContent) return;
    
    const changes = calculateBalanceChanges(selectedOption, balanceStatus);
    
    let previewHTML = '';
    
    // Yarıyıl içi değişiklikler
    if (changes.termChanges.length > 0) {
        previewHTML += `
            <div class="preview-category">
                <h6>📘 Yarıyıl İçi Değerlendirmeler</h6>
                <div class="preview-items">
                    <div class="preview-header">Etkinlik</div>
                    <div class="preview-header">Eski Puan</div>
                    <div class="preview-header">Yeni Puan</div>
        `;
        
        changes.termChanges.forEach(change => {
            const isChanged = change.oldValue !== change.newValue;
            previewHTML += `
                <div class="preview-item ${isChanged ? 'changed' : ''}">${change.name}</div>
                <div class="preview-item ${isChanged ? 'changed' : ''}">
                    ${isChanged ? `<span class="old-value">${change.oldValue}</span>` : change.oldValue}
                </div>
                <div class="preview-item ${isChanged ? 'changed' : ''}">
                    ${isChanged ? `<span class="new-value">${change.newValue}</span>` : change.newValue}
                </div>
            `;
        });
        
        previewHTML += `</div></div>`;
    }
    
    // Yarıyıl sonu değişiklikler
    if (changes.finalChanges.length > 0) {
        previewHTML += `
            <div class="preview-category">
                <h6>📕 Yarıyıl Sonu Değerlendirmeler</h6>
                <div class="preview-items">
                    <div class="preview-header">Etkinlik</div>
                    <div class="preview-header">Eski Puan</div>
                    <div class="preview-header">Yeni Puan</div>
        `;
        
        changes.finalChanges.forEach(change => {
            const isChanged = change.oldValue !== change.newValue;
            previewHTML += `
                <div class="preview-item ${isChanged ? 'changed' : ''}">${change.name}</div>
                <div class="preview-item ${isChanged ? 'changed' : ''}">
                    ${isChanged ? `<span class="old-value">${change.oldValue}</span>` : change.oldValue}
                </div>
                <div class="preview-item ${isChanged ? 'changed' : ''}">
                    ${isChanged ? `<span class="new-value">${change.newValue}</span>` : change.newValue}
                </div>
            `;
        });
        
        previewHTML += `</div></div>`;
    }
    
    // Özet
    previewHTML += `
        <div class="total-summary">
            <div class="total-row">
                <span class="total-label">Yarıyıl İçi Toplam:</span>
                <span class="total-value ${changes.termTotal === 100 ? 'perfect' : 'unbalanced'}">${changes.termTotal} puan</span>
            </div>
            <div class="total-row">
                <span class="total-label">Yarıyıl Sonu Toplam:</span>
                <span class="total-value ${changes.finalTotal === 100 ? 'perfect' : 'unbalanced'}">${changes.finalTotal} puan</span>
            </div>
            <div class="total-row">
                <span class="total-label">Genel Ağırlık Toplamı:</span>
                <span class="total-value ${changes.weightTotal === 100 ? 'perfect' : 'unbalanced'}">%${changes.weightTotal}</span>
            </div>
        </div>
    `;
    
    previewContent.innerHTML = previewHTML;
    previewSection.style.display = 'block';
}

/**
 * Dengeleme değişikliklerini hesaplar
 * @param {string} selectedOption - Seçilen dengeleme opsionu
 * @param {Object} balanceStatus - Dengeleme durumu
 * @returns {Object} Değişiklik detayları
 */
function calculateBalanceChanges(selectedOption, balanceStatus) {
    const changes = {
        termChanges: [],
        finalChanges: [],
        termTotal: 0,
        finalTotal: 0,
        weightTotal: 0
    };
    
    if (selectedOption === 'keep-current') {
        // Mevcut durumu koru - değişiklik yok
        balanceStatus.termAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    changes.termChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: child.points || 0
                    });
                });
            }
        });
        
        balanceStatus.finalAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    changes.finalChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: child.points || 0
                    });
                });
            }
        });
        
        changes.termTotal = changes.termChanges.reduce((sum, change) => sum + change.newValue, 0);
        changes.finalTotal = changes.finalChanges.reduce((sum, change) => sum + change.newValue, 0);
        changes.weightTotal = balanceStatus.totalWeight;
        
    } else if (selectedOption === 'auto-balance') {
        // Otomatik dengeleme - eşit dağılım
        balanceStatus.termAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                const newPoints = distributePointsIntelligently(node.children.length, 100);
                node.children.forEach((child, index) => {
                    changes.termChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: newPoints[index]
                    });
                });
            }
        });
        
        balanceStatus.finalAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                const newPoints = distributePointsIntelligently(node.children.length, 100);
                node.children.forEach((child, index) => {
                    changes.finalChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: newPoints[index]
                    });
                });
            }
        });
        
        changes.termTotal = 100;
        changes.finalTotal = 100;
        changes.weightTotal = 100; // Ağırlıklar da dengelenecek
        
    } else if (selectedOption === 'smart-balance') {
        // Akıllı dengeleme - mevcut oranları koruyarak düzelt
        balanceStatus.termAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                const currentTotal = node.children.reduce((sum, child) => sum + (child.points || 0), 0);
                const factor = currentTotal > 0 ? 100 / currentTotal : 1;
                
                node.children.forEach(child => {
                    const newValue = Math.round((child.points || 0) * factor);
                    changes.termChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: newValue
                    });
                });
                
                // Son düzeltme - toplam tam 100 olsun
                const actualTotal = changes.termChanges.slice(-node.children.length).reduce((sum, change) => sum + change.newValue, 0);
                if (actualTotal !== 100) {
                    const lastChange = changes.termChanges[changes.termChanges.length - 1];
                    lastChange.newValue += (100 - actualTotal);
                }
            }
        });
        
        balanceStatus.finalAnalysis.nodes.forEach(node => {
            if (node.children && node.children.length > 0) {
                const currentTotal = node.children.reduce((sum, child) => sum + (child.points || 0), 0);
                const factor = currentTotal > 0 ? 100 / currentTotal : 1;
                
                node.children.forEach(child => {
                    const newValue = Math.round((child.points || 0) * factor);
                    changes.finalChanges.push({
                        name: child.name,
                        oldValue: child.points || 0,
                        newValue: newValue
                    });
                });
                
                // Son düzeltme - toplam tam 100 olsun
                const actualTotal = changes.finalChanges.slice(-node.children.length).reduce((sum, change) => sum + change.newValue, 0);
                if (actualTotal !== 100) {
                    const lastChange = changes.finalChanges[changes.finalChanges.length - 1];
                    lastChange.newValue += (100 - actualTotal);
                }
            }
        });
        
        changes.termTotal = 100;
        changes.finalTotal = 100;
        changes.weightTotal = 100;
        
    } else if (selectedOption === 'manual-balance') {
        // Manuel düzenleme - kullanıcı kendisi yapacak
        // Sadece mevcut durumu göster
        return calculateBalanceChanges('keep-current', balanceStatus);
    }
    
    return changes;
}

/**
 * Dengeleme opsiyonunu uygular
 * @param {string} selectedOption - Seçilen dengeleme opsionu
 * @param {Object} balanceStatus - Dengeleme durumu
 */
function applyBalanceOption(selectedOption, balanceStatus) {
    if (selectedOption === 'keep-current') {
        // Hiçbir şey yapma
        return;
    }
    
    if (selectedOption === 'manual-balance') {
        // Manuel düzenleme için sadece uyarı ver
        showModernToast('Manuel düzenleme seçildi. Puanları kendiniz ayarlayabilirsiniz.', 'info');
        return;
    }
    
    const changes = calculateBalanceChanges(selectedOption, balanceStatus);
    
    // Yarıyıl içi değişiklikleri uygula
    let termChangeIndex = 0;
    balanceStatus.termAnalysis.nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                if (termChangeIndex < changes.termChanges.length) {
                    child.points = changes.termChanges[termChangeIndex].newValue;
                    termChangeIndex++;
                }
            });
        }
    });
    
    // Yarıyıl sonu değişiklikleri uygula
    let finalChangeIndex = 0;
    balanceStatus.finalAnalysis.nodes.forEach(node => {
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                if (finalChangeIndex < changes.finalChanges.length) {
                    child.points = changes.finalChanges[finalChangeIndex].newValue;
                    finalChangeIndex++;
                }
            });
        }
    });
    
    // Ağırlıkları da dengele (eğer gerekiyorsa)
    if (selectedOption === 'auto-balance' || selectedOption === 'smart-balance') {
        const termNodes = getNodesByCategory('term');
        const finalNodes = getNodesByCategory('final');
        
        // Varsayılan ağırlıklar: %40 term, %60 final
        if (termNodes.length > 0) {
            const termWeight = termNodes.length > 0 ? 40 / termNodes.length : 0;
            termNodes.forEach(node => {
                node.weight = termWeight;
            });
        }
        
        if (finalNodes.length > 0) {
            const finalWeight = finalNodes.length > 0 ? 60 / finalNodes.length : 0;
            finalNodes.forEach(node => {
                node.weight = finalWeight;
            });
        }
    }
    
    // Görünümü güncelle
    renderTree();
    // Değerlendirme sekmesini güncelle - CRITICAL SYNC
    updateAssessmentView();
}

// DOM yüklendiğinde modal'ı başlat
document.addEventListener('DOMContentLoaded', function() {
    initializeEmailModal();
    initializeModernTestOperations();
    initializeModernEventListeners();
    
    // Grup istatistiklerini başlat
    updateGroupStatistics();
    
    // Assessment Sync Butonu Event Listener
    const btnSyncAssessment = document.getElementById('btnSyncAssessment');
    if (btnSyncAssessment) {
        btnSyncAssessment.addEventListener('click', function() {
            console.log('🔄 Manuel assessment sync butonuna tıklandı');
            
            // Veri kontrolü
            if (!APP_STATE.assessmentTree?.length) {
                showModernToast("⚠️ Ders tanımlama verisi bulunamadı! Önce ders tanımlaması yapın.", "warning");
                return;
            }
            
            if (!APP_STATE.studentData?.length) {
                showModernToast("⚠️ Öğrenci verisi bulunamadı! Önce öğrenci listesi yükleyin.", "warning");
                return;
            }
            
            // Sekmeden kontrol 
            const activeTab = document.querySelector('.nav-tab.active');
            const isAssessmentTab = activeTab && activeTab.getAttribute('data-tab') === 'assessment';
            
            if (!isAssessmentTab) {
                showModernToast("ℹ️ Değerlendirme Girişi sekmesine geçiş yapılıyor...", "info");
                // Assessment sekmesine geç
                const assessmentTab = document.querySelector('.nav-tab[data-tab="assessment"]');
                if (assessmentTab) {
                    assessmentTab.click();
                }
                
                // Kısa bir bekleyip güncelle
                setTimeout(() => {
                    updateAssessmentView();
                    showModernToast("✅ Değerlendirme tablosu güncellendi!", "success");
                }, 100);
            } else {
                // Zaten assessment sekmesindeyiz, direkt güncelle
                updateAssessmentView();
                showModernToast("✅ Değerlendirme tablosu güncellendi!", "success");
            }
        });
    }
});

/**
 * ÖÇ Performans Kartı HTML Oluşturucu
 */
function createOCPerformanceHTML(outcomes, studentGrades) {
    if (!outcomes || outcomes.length === 0) {
        return `
        <div class="email-card">
            <div class="card-header">📚 Öğrenme Çıktıları (ÖÇ)</div>
            <div class="card-content">
                <p style="color: #e74c3c;">Bu ders için öğrenme çıktıları tanımlanmamış.</p>
            </div>
        </div>`;
    }

    const performanceItems = outcomes.slice(0, 4).map(outcome => {
        const performance = calculateOCPerformanceFromText(outcome.id, studentGrades, APP_STATE.assessmentTree || []);
        const level = getPerformanceTextLevel(performance);
        const color = performance >= 80 ? '#27ae60' : performance >= 70 ? '#f39c12' : '#e74c3c';
        
        return `
        <div class="performance-item">
            <div class="performance-header">
                <span class="oc-id">${outcome.id}</span>
                <span class="performance-score" style="color: ${color};">%${performance.toFixed(2)}</span>
            </div>
            <div class="performance-level" style="color: ${color};">${level}</div>
            <div class="oc-description">${(outcome.aciklama || '').substring(0, 80)}...</div>
        </div>`;
    }).join('');

    const remainingCount = outcomes.length > 4 ? outcomes.length - 4 : 0;
    
    return `
    <div class="email-card">
        <div class="card-header">📚 Öğrenme Çıktıları Performansı</div>
        <div class="card-content">
            ${performanceItems}
            ${remainingCount > 0 ? `<div class="remaining-count">... ve ${remainingCount} tane daha</div>` : ''}
        </div>
    </div>`;
}

/**
 * PÇ İlişki Kartı HTML Oluşturucu
 */
function createPCRelationHTML(programOutcomes, relationMatrix) {
    const totalPC = programOutcomes.length;
    const strongRelations = Math.floor(totalPC * 0.4);
    const moderateRelations = Math.floor(totalPC * 0.6);
    
    // En güçlü ilişkileri göster
    const topRelations = programOutcomes.slice(0, 3).map(pc => {
        const category = pc.kategori || 'BİLGİ';
        const relation = calculatePCRelationStrength(pc.id, relationMatrix);
        const strength = relation.level;
        const color = strength === 'Güçlü' ? '#27ae60' : strength === 'Orta' ? '#f39c12' : '#e74c3c';
        
        return `
        <div class="pc-relation-item">
            <div class="pc-header">
                <span class="pc-id">${pc.id}</span>
                <span class="pc-category">${category}</span>
            </div>
            <div class="relation-strength" style="color: ${color};">${strength} İlişki</div>
        </div>`;
    }).join('');
    
    return `
    <div class="email-card">
        <div class="card-header">🎯 Program Çıktıları İlişkisi</div>
        <div class="card-content">
            <div class="pc-summary">
                <div class="summary-item">
                    <span class="summary-label">Toplam PÇ:</span>
                    <span class="summary-value">${totalPC}</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Güçlü İlişki:</span>
                    <span class="summary-value" style="color: #27ae60;">${strongRelations}</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Orta İlişki:</span>
                    <span class="summary-value" style="color: #f39c12;">${moderateRelations}</span>
                </div>
            </div>
            ${topRelations}
        </div>
    </div>`;
}

/**
 * Genel Performans Özeti HTML Oluşturucu
 */
function createPerformanceSummaryHTML(avgPerformance) {
    const level = getPerformanceTextLevel(avgPerformance);
    const color = avgPerformance >= 80 ? '#27ae60' : avgPerformance >= 70 ? '#f39c12' : '#e74c3c';
    
    let recommendation = '';
    let icon = '';
    
    if (avgPerformance >= 80) {
        recommendation = 'Mevcut performansınızı koruyun. Başarılı gidiyorsunuz!';
        icon = '🌟';
    } else if (avgPerformance >= 70) {
        recommendation = 'Zayıf alanları geliştirin. Daha fazla çalışma ile daha iyi sonuçlar alabilirsiniz.';
        icon = '📈';
    } else {
        recommendation = 'Temel konuları tekrar edin. Ek destek almayı düşünün.';
        icon = '📚';
    }
    
    return `
    <div class="email-card performance-summary">
        <div class="card-header">📊 Genel Performans Değerlendirmesi</div>
        <div class="card-content">
            <div class="performance-overview">
                <div class="avg-performance">
                    <span class="performance-label">ÖÇ Ortalaması:</span>
                    <span class="performance-value" style="color: ${color}; font-size: 24px; font-weight: bold;">%${avgPerformance.toFixed(2)}</span>
                </div>
                <div class="performance-level-display" style="color: ${color}; font-size: 18px; font-weight: bold;">
                    ${level}
                </div>
            </div>
            <div class="recommendation">
                <div class="recommendation-header">${icon} Öneriler:</div>
                <div class="recommendation-text">${recommendation}</div>
            </div>
        </div>
    </div>`;
}

/**
 * ÖÇ-PÇ Analiz e-postası için HTML formatı
 */
function generateAnalysisHTMLEmail(student) {
    const instructor = getInstructorName();
    const courseInfo = getCourseInfo();
    const courseName = courseInfo.name;
    const courseTerm = courseInfo.term;
    
    const subject = `${courseName} - ÖÇ-PÇ Analizi`;
    
    // Öğrenci verilerini al
    let studentData = APP_STATE.studentData?.find(s => s.studentId === student.studentId);
    if (!studentData) {
        studentData = {
            studentId: student.studentId,
            name: student.name || 'Bilinmeyen',
            surname: student.surname || 'Öğrenci'
        };
    }

    // Veri kaynakları
    const outcomes = APP_STATE.courseData?.dersOgrenmeÇiktilari || [];
    const programOutcomes = APP_STATE.courseData?.programCiktilari || [];
    const relationMatrix = APP_STATE.courseData?.programVeOgrenmeIliskisi?.iliskiTablosu || [];
    const allGradesData = APP_STATE.gradesData || APP_STATE.courseData?.ogrenciNotlari || {};
    const studentGrades = allGradesData[studentData.studentId] || {};
    
    // Gerçek ortalama performans hesabı
    let totalOCPerformance = 0;
    let validOCCount = 0;
    outcomes.forEach(oc => {
        const performance = calculateOCPerformanceFromText(oc.id, studentGrades, APP_STATE.assessmentTree || []);
        totalOCPerformance += performance;
        if (performance > 0) validOCCount++;
    });
    const avgPerformance = validOCCount > 0 ? totalOCPerformance / validOCCount : 0;
    
    // HTML bileşenleri
    const studentInfoHTML = createStudentInfoHTML(studentData, courseName, courseTerm);
    const ocPerformanceHTML = createOCPerformanceHTML(outcomes, studentGrades);
    const pcRelationHTML = createPCRelationHTML(programOutcomes, relationMatrix);
    const performanceSummaryHTML = createPerformanceSummaryHTML(avgPerformance);
    const contactHTML = createContactHTML(instructor);
    
    const body = `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 800px; margin: 0 auto; background-color: #f8f9fa;">
        ${studentInfoHTML}
        ${ocPerformanceHTML}
        ${pcRelationHTML}
        ${performanceSummaryHTML}
        ${contactHTML}
    </div>
    
    <style>
        .email-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 20px 0;
            overflow: hidden;
        }
        
        .card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .card-content {
            padding: 20px;
        }
        
        .performance-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }
        
        .performance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .oc-id {
            font-weight: bold;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .performance-score {
            font-weight: bold;
            font-size: 18px;
        }
        
        .performance-level {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .oc-description {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .pc-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .summary-label {
            display: block;
            color: #7f8c8d;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .summary-value {
            font-weight: bold;
            font-size: 18px;
            color: #2c3e50;
        }
        
        .pc-relation-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border-left: 4px solid #f39c12;
        }
        
        .pc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .pc-id {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .pc-category {
            background: #ecf0f1;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .relation-strength {
            font-weight: bold;
            font-size: 14px;
        }
        
        .performance-summary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .performance-summary .card-content {
            color: white;
        }
        
        .performance-overview {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .avg-performance {
            margin-bottom: 10px;
        }
        
        .performance-label {
            display: block;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .performance-value {
            display: block;
        }
        
        .performance-level-display {
            margin-top: 10px;
        }
        
        .recommendation {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
        }
        
        .recommendation-header {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .recommendation-text {
            line-height: 1.6;
        }
        
        .remaining-count {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
    </style>`;
    
    return { subject, body };
}

/**
 * Tam Dosya formatında rastgele yarıyıl içi değerlendirme oluşturur
 */
function generateRandomTermAssessment() {
    try {
        const activityCount = parseInt(document.getElementById('termActivityCountSlider').value) || 2;
        const componentCount = parseInt(document.getElementById('termComponentsSlider').value) || 3;
        const activityType = document.getElementById('termActivityTypeSelect').value || 'random';
        
                  console.log(`🎲 Tam Dosya formatında rastgele yarıyıl içi değerlendirme oluşturuluyor (${activityCount} etkinlik, ${componentCount} alt bileşen)...`);
        
        generateTamDosyaTermAssessmentWithParams(activityCount, componentCount, activityType);
        
    } catch (error) {
        console.error('❌ V5 rastgele yarıyıl içi değerlendirme oluşturulurken hata:', error);
        showModernToast('V5 rastgele yarıyıl içi değerlendirme oluşturulamadı!', 'error');
    }
}

/**
 * Tam Dosya formatında rastgele yarıyıl sonu değerlendirme oluşturur
 */
function generateRandomFinalAssessment() {
    try {
        const activityCount = parseInt(document.getElementById('finalActivityCountSlider').value) || 1;
        const componentCount = parseInt(document.getElementById('finalComponentsSlider').value) || 5;
        const activityType = document.getElementById('finalActivityTypeSelect').value || 'random';
        
                  console.log(`🎲 Tam Dosya formatında rastgele yarıyıl sonu değerlendirme oluşturuluyor (${activityCount} etkinlik, ${componentCount} alt bileşen)...`);
        
        generateTamDosyaFinalAssessmentWithParams(activityCount, componentCount, activityType);
        
    } catch (error) {
        console.error('❌ V5 rastgele yarıyıl sonu değerlendirme oluşturulurken hata:', error);
        showModernToast('V5 rastgele yarıyıl sonu değerlendirme oluşturulamadı!', 'error');
    }
}

/**
 * Parametreli rastgele değerlendirme oluşturucu
 */
function generateRandomAssessmentWithParams(isTermActivity, componentCount, activityType = 'random') {
    try {
        // JSON dosyasından gelen gerçek etkinlik türleri ve özellikler
        const activityTypeMap = {
            // Yarıyıl İçi Etkinlikler
            'Ara Sınav': { weight: [25, 35], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Laboratuvar Sınavı': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Deney': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Deney Sonrası Quiz': { weight: [5, 15], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Performans': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Quiz': { weight: [5, 15], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Rapor': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Rapor Sunma': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Makale Kritik Etme': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Makale Yazma': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Proje Hazırlama': { weight: [20, 30], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Proje Sunma': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Rehberli Problem Çözümü': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Seminer': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Sözlü Sınav': { weight: [15, 25], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Ödev Problemleri İçin Çalışma': { weight: [10, 20], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            'Proje Tasarımı/Yönetimi': { weight: [20, 30], points: 100, hasSubItems: true, subTypes: ['Rubrik'] },
            
            // Yarıyıl Sonu Etkinlikler
            'Final Sınavı': { weight: [80, 100], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Laboratuvar Ara Sınavı': { weight: [70, 90], points: 100, hasSubItems: true, subTypes: ['Soru'] },
            'Gözlem': { weight: [60, 80], points: 100, hasSubItems: true, subTypes: ['Rubrik'] }
        };
        
        // Gerçekçi değerlendirme türleri - JSON'dan gelen listeler
        const realisticTypes = {
            term: [
                'Ara Sınav', 'Laboratuvar Sınavı', 'Deney', 'Deney Sonrası Quiz', 'Performans', 
                'Quiz', 'Rapor', 'Rapor Sunma', 'Makale Kritik Etme', 'Makale Yazma', 
                'Proje Hazırlama', 'Proje Sunma', 'Rehberli Problem Çözümü', 'Seminer', 
                'Sözlü Sınav', 'Ödev Problemleri İçin Çalışma', 'Proje Tasarımı/Yönetimi'
            ],
            final: [
                'Final Sınavı', 'Laboratuvar Ara Sınavı', 'Makale Yazma', 'Proje Hazırlama', 
                'Proje Sunma', 'Proje Tasarımı/Yönetimi', 'Quiz', 'Rapor', 'Rapor Hazırlama', 
                'Rapor Sunma', 'Seminer', 'Sözlü Sınav', 'Gözlem'
            ]
        };
        
        let selectedActivityType;
        if (activityType === 'random') {
            // Rastgele seçim
        const availableTypes = isTermActivity ? realisticTypes.term : realisticTypes.final;
            selectedActivityType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        } else {
            // Kullanıcının seçtiği tür
            selectedActivityType = activityType;
        }
        
        const randomTypeInfo = {
            name: selectedActivityType,
            ...activityTypeMap[selectedActivityType]
        };
        
        // Mevcut aktiviteleri say ve doğru ID formatını oluştur
        const existingActivities = APP_STATE.assessmentTree.filter(node => 
            isTermActivity ? node.id.startsWith('A') : node.id.startsWith('F')
        );
        const nextNumber = existingActivities.length + 1;
        const newId = isTermActivity ? `A${nextNumber}` : `F${nextNumber}`;
        
        // Mevcut öğrenme çıktılarını kullan (varsa)
        let selectedOutcomes = [];
        if (APP_STATE.learningOutcomes && APP_STATE.learningOutcomes.length > 0) {
            const numOutcomes = Math.floor(Math.random() * 3) + 1; // 1-3 arası
            const shuffledOutcomes = [...APP_STATE.learningOutcomes].sort(() => Math.random() - 0.5);
            selectedOutcomes = shuffledOutcomes.slice(0, numOutcomes).map(outcome => outcome.id);
        } else {
            // Varsayılan öğrenme çıktıları (gerçekçi)
            const defaultOutcomes = ['ÖÇ.1', 'ÖÇ.2', 'ÖÇ.3', 'ÖÇ.4', 'ÖÇ.5', 'ÖÇ.6'];
            const numOutcomes = Math.floor(Math.random() * 3) + 2; // 2-4 arası
            const shuffledOutcomes = [...defaultOutcomes].sort(() => Math.random() - 0.5);
            selectedOutcomes = shuffledOutcomes.slice(0, numOutcomes);
        }
        
        // Gerçekçi ağırlık ve puan hesaplama
        const weightRange = randomTypeInfo.weight;
        const weight = Math.floor(Math.random() * (weightRange[1] - weightRange[0] + 1)) + weightRange[0];
        
        let points;
        if (Array.isArray(randomTypeInfo.points)) {
            points = Math.floor(Math.random() * (randomTypeInfo.points[1] - randomTypeInfo.points[0] + 1)) + randomTypeInfo.points[0];
        } else {
            points = randomTypeInfo.points;
        }
        
        console.log(`  📋 ${randomTypeInfo.name} oluşturuluyor - Ağırlık: ${weight}%, Puan: ${points}`);
        
        // Yeni aktivite oluştur - mevcut sistem formatında
        const newActivity = {
            id: newId,
            name: randomTypeInfo.name,
            type: randomTypeInfo.name,
            weight: weight,
            points: points,
            outcomes: selectedOutcomes,
            description: isTermActivity ? 
                `Yarıyıl içi ${randomTypeInfo.name.toLowerCase()} değerlendirmesi` : 
                `Yarıyıl sonu ${randomTypeInfo.name.toLowerCase()} değerlendirmesi`,
            expanded: true,
            children: []
        };
        
        // Alt bileşenler ekle - kullanıcının belirlediği sayıda
        if (randomTypeInfo.hasSubItems && componentCount > 0) {
            let subTypes = randomTypeInfo.subTypes;
            
            console.log(`    🔹 ${componentCount} alt bileşen ekleniyor...`);
            
            // DÜZELTME: Akıllı puan dağılımı - toplam 100 olacak şekilde
            const basePoints = Math.floor(points / componentCount);
            const remainder = points - (basePoints * componentCount);
            
            // DÜZELTME: Akıllı ağırlık dağılımı - toplam 100 olacak şekilde
            const baseWeight = Math.floor(100 / componentCount);
            const weightRemainder = 100 - (baseWeight * componentCount);
            
            for (let i = 0; i < componentCount; i++) {
                // Alt bileşen türünü gerçekçi şekilde seç
                const subType = subTypes[Math.floor(Math.random() * subTypes.length)];
                
                // Gerçekçi alt bileşen isimleri
                let subName;
                if (subType === 'Soru') {
                    const questionTypes = ['Çoktan Seçmeli', 'Açık Uçlu', 'Kısa Cevaplı', 'Problem', 'Analiz'];
                    subName = `${questionTypes[Math.floor(Math.random() * questionTypes.length)]} Soru ${i + 1}`;
                } else if (subType === 'Test') {
                    subName = `Test Bölümü ${i + 1}`;
                } else if (subType === 'Rubrik') {
                    const rubricTypes = ['Değerlendirme', 'Analiz', 'Sunum', 'Rapor', 'Kod Kalitesi'];
                    subName = `${rubricTypes[Math.floor(Math.random() * rubricTypes.length)]} Rubriği`;
                } else {
                    subName = `${subType} ${i + 1}`;
                }
                
                // DÜZELTME: Kalan puanları ve ağırlıkları ilk bileşenlere dağıt
                const componentPoints = basePoints + (i < remainder ? 1 : 0);
                const componentWeight = baseWeight + (i < weightRemainder ? 1 : 0);
                
                const subItem = {
                    id: `${newId}.${i + 1}`,
                    name: subName,
                    type: subType,
                    weight: componentWeight,
                    points: componentPoints,
                    outcomes: selectedOutcomes.length > 0 ? 
                        [selectedOutcomes[Math.floor(Math.random() * selectedOutcomes.length)]] : [],
                    description: `${subName} için değerlendirme kriteri`,
                    expanded: false,
                    children: []
                };
                
                // Test için gerçekçi detaylar ekle
                if (subType === 'Test') {
                    const questionCount = Math.floor(Math.random() * 20) + 10; // 10-30 soru
                    subItem.testDetails = {
                        totalQuestions: questionCount,
                        correctWeight: Math.floor(Math.random() * 3) + 3, // 3-5 puan
                        wrongPenalty: -(Math.floor(Math.random() * 2) + 1) // -1 veya -2 puan
                    };
                    console.log(`      🧪 Test: ${questionCount} soru, +${subItem.testDetails.correctWeight}/${subItem.testDetails.wrongPenalty} puan`);
                }
                
                newActivity.children.push(subItem);
                console.log(`      ✅ ${subName} (${subItem.points} puan)`);
            }
            
            // DOĞRULAMA: Toplam puan ve ağırlık kontrolü
            const finalTotalPoints = newActivity.children.reduce((sum, child) => sum + child.points, 0);
            const finalTotalWeight = newActivity.children.reduce((sum, child) => sum + child.weight, 0);
            
            console.log(`    📊 Toplam Puan: ${finalTotalPoints}/${points}, Toplam Ağırlık: ${finalTotalWeight}%`);
            
            if (finalTotalPoints !== points) {
                console.warn(`⚠️ Puan uyumsuzluğu düzeltiliyor: ${finalTotalPoints} → ${points}`);
                // Son bileşenin puanını ayarla
                const lastChild = newActivity.children[newActivity.children.length - 1];
                lastChild.points += (points - finalTotalPoints);
            }
            if (finalTotalWeight !== 100) {
                console.warn(`⚠️ Ağırlık uyumsuzluğu düzeltiliyor: ${finalTotalWeight} → 100`);
                // Son bileşenin ağırlığını ayarla
                const lastChild = newActivity.children[newActivity.children.length - 1];
                lastChild.weight += (100 - finalTotalWeight);
            }
        }
        
        // Assessment tree'ye doğru sırada ekle
        if (isTermActivity) {
            // Yarıyıl içi etkinlikleri başa ekle
            const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
            const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
            termActivities.push(newActivity);
            APP_STATE.assessmentTree = [...termActivities, ...finalActivities];
        } else {
            // Yarıyıl sonu etkinlikleri sona ekle
            APP_STATE.assessmentTree.push(newActivity);
        }
        
        // Seçili düğümü yeni aktivite yap
        selectNode(newActivity);
        
        // Arayüzü güncelle
        renderTree();
        updateCategoryWeights();
        updateAssessmentView();
        // updateGroupMappingDisplay(); // Bu fonksiyon şu an mevcut değil, gerekirse eklenecek
        
        const activityTypeText = isTermActivity ? 'yarıyıl içi' : 'yarıyıl sonu';
        console.log(`✅ Rastgele ${activityTypeText} değerlendirme oluşturuldu: ${newActivity.name}`);
        
        return true; // Başarı durumunu döndür
        
    } catch (error) {
        console.error('❌ Rastgele değerlendirme oluşturulurken hata:', error);
        throw error; // Hatayı üst fonksiyona aktar
    }
}

/**
 * Çoklu rastgele yarıyıl içi etkinlik oluşturur (Onay ile)
 */
function generateMultipleRandomTermAssessments() {
    // Mevcut verileri kontrol et
    const hasExistingData = APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0;
    const activityCount = parseInt(document.getElementById('termActivityCountSlider').value) || 2;
    const componentCount = parseInt(document.getElementById('termComponentsSlider').value) || 3;
    const activityType = document.getElementById('termActivityTypeSelect').value;
    
    const warningMessage = hasExistingData 
        ? `Bu işlem mevcut ${APP_STATE.assessmentTree.length} değerlendirme bileşenine ${activityCount} yeni yarıyıl içi etkinlik ekleyecek. Her etkinlikte ${componentCount} soru/rubrik olacak.\n\nDevam etmek istediğinizden emin misiniz?`
        : `${activityCount} adet yarıyıl içi etkinlik oluşturulacak (her birinde ${componentCount} soru/rubrik, tür: ${activityType}).\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    
    showModernConfirm('⭐ Yarıyıl İçi Etkinlik Oluştur', warningMessage, {
            confirmText: 'Evet, Oluştur',
            cancelText: 'İptal',
        confirmClass: 'btn-modern-primary',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
        executeGenerateMultipleRandomTermAssessments();
    });
}

/**
 * Çoklu rastgele yarıyıl içi etkinlik oluşturur (Gerçek işlem)
 */
function executeGenerateMultipleRandomTermAssessments() {
    try {
        const activityCount = parseInt(document.getElementById('termActivityCountSlider').value) || 2;
        const componentCount = parseInt(document.getElementById('termComponentsSlider').value) || 3;
        const activityType = document.getElementById('termActivityTypeSelect').value;
        
        console.log(`🎲 ${activityCount} adet yarıyıl içi etkinlik oluşturuluyor (Tür: ${activityType}, her birinde ${componentCount} alt bileşen)...`);
        
        let successCount = 0;
        
        // Tam Dosya formatında tek seferde çoklu etkinlik oluştur
        try {
            generateTamDosyaTermAssessmentWithParams(activityCount, componentCount, activityType);
            successCount = activityCount;
                          console.log(`✅ ${activityCount} yarıyıl içi etkinlik Tam Dosya formatında oluşturuldu`);
            } catch (error) {
                          console.error(`❌ Tam Dosya yarıyıl içi etkinlikler oluşturulurken hata:`, error);
        }
        
        // Tam Dosya formatında ağırlıklar otomatik normalize edilir
        
        if (successCount === activityCount) {
            showModernToast(`🎉 ${activityCount} adet yarıyıl içi etkinlik başarıyla oluşturuldu! (Her birinde ${componentCount} soru/rubrik)`, 'success', 4000);
        } else if (successCount > 0) {
            showModernToast(`⚠️ ${successCount}/${activityCount} yarıyıl içi etkinlik oluşturuldu. Bazı etkinlikler oluşturulamadı.`, 'warning', 4000);
        } else {
            showModernToast('❌ Yarıyıl içi etkinlik oluşturulamadı!', 'error', 4000);
        }
        
    } catch (error) {
        console.error('❌ Çoklu yarıyıl içi etkinlik oluşturulurken hata:', error);
        showModernToast('Çoklu yarıyıl içi etkinlik oluşturulamadı!', 'error');
    }
}

/**
 * Çoklu rastgele yarıyıl sonu etkinlik oluşturur (Onay ile)
 */
function generateMultipleRandomFinalAssessments() {
    // Mevcut verileri kontrol et
    const hasExistingData = APP_STATE.assessmentTree && APP_STATE.assessmentTree.length > 0;
    const activityCount = parseInt(document.getElementById('finalActivityCountSlider').value) || 1;
    const componentCount = parseInt(document.getElementById('finalComponentsSlider').value) || 5;
    const activityType = document.getElementById('finalActivityTypeSelect').value;
    
    const warningMessage = hasExistingData 
        ? `Bu işlem mevcut ${APP_STATE.assessmentTree.length} değerlendirme bileşenine ${activityCount} yeni yarıyıl sonu etkinlik ekleyecek. Her etkinlikte ${componentCount} soru/rubrik olacak.\n\nDevam etmek istediğinizden emin misiniz?`
        : `${activityCount} adet yarıyıl sonu etkinlik oluşturulacak (her birinde ${componentCount} soru/rubrik, tür: ${activityType}).\n\nBu işlem geri alınamaz. Devam etmek istediğinizden emin misiniz?`;
    
    showModernConfirm('🎯 Yarıyıl Sonu Etkinlik Oluştur', warningMessage, {
            confirmText: 'Evet, Oluştur',
            cancelText: 'İptal',
        confirmClass: 'btn-modern-success',
        cancelClass: 'btn-modern-secondary'
    }).then(() => {
        executeGenerateMultipleRandomFinalAssessments();
    });
}

/**
 * Çoklu rastgele yarıyıl sonu etkinlik oluşturur (Gerçek işlem)
 */
function executeGenerateMultipleRandomFinalAssessments() {
    try {
        const activityCount = parseInt(document.getElementById('finalActivityCountSlider').value) || 1;
        const componentCount = parseInt(document.getElementById('finalComponentsSlider').value) || 5;
        const activityType = document.getElementById('finalActivityTypeSelect').value;
        
        console.log(`🎲 ${activityCount} adet yarıyıl sonu etkinlik oluşturuluyor (Tür: ${activityType}, her birinde ${componentCount} alt bileşen)...`);
        
        let successCount = 0;
        
        // Tam Dosya formatında tek seferde çoklu etkinlik oluştur
        try {
            generateTamDosyaFinalAssessmentWithParams(activityCount, componentCount, activityType);
            successCount = activityCount;
                          console.log(`✅ ${activityCount} yarıyıl sonu etkinlik Tam Dosya formatında oluşturuldu`);
            } catch (error) {
                          console.error(`❌ Tam Dosya yarıyıl sonu etkinlikler oluşturulurken hata:`, error);
        }
        
        // Tam Dosya formatında ağırlıklar otomatik normalize edilir
        
        if (successCount === activityCount) {
            showModernToast(`🎉 ${activityCount} adet yarıyıl sonu etkinlik başarıyla oluşturuldu! (Her birinde ${componentCount} soru/rubrik)`, 'success', 4000);
        } else if (successCount > 0) {
            showModernToast(`⚠️ ${successCount}/${activityCount} yarıyıl sonu etkinlik oluşturuldu. Bazı etkinlikler oluşturulamadı.`, 'warning', 4000);
        } else {
            showModernToast('❌ Yarıyıl sonu etkinlik oluşturulamadı!', 'error', 4000);
        }
        
    } catch (error) {
        console.error('❌ Çoklu yarıyıl sonu etkinlik oluşturulurken hata:', error);
        showModernToast('Çoklu yarıyıl sonu etkinlik oluşturulamadı!', 'error');
    }
}

/**
 * Dual range slider uyarı mesajını günceller
 */
function updateDualRangeWarning(minGroups, maxGroups) {
    const warningDiv = document.getElementById('groupsWarning');
    const warningText = document.getElementById('groupsWarningText');
    
    if (!warningDiv || !warningText) return;
    
    const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
    
    if (studentCount === 0) {
        // Öğrenci yoksa uyarı gösterme
        warningDiv.style.display = 'none';
        return;
    }
    
    if (minGroups > studentCount) {
        // Minimum grup sayısı bile öğrenci sayısından fazlaysa kritik uyarı
        warningText.textContent = `⚠️ Minimum ${minGroups} grup seçildi ancak sadece ${studentCount} öğrenci var. Maksimum ${studentCount} grup oluşturulabilir.`;
        warningDiv.style.display = 'flex';
    } else if (maxGroups > studentCount) {
        // Maksimum grup sayısı öğrenci sayısından fazlaysa uyarı
        warningText.textContent = `⚠️ Maksimum ${maxGroups} grup seçildi ancak sadece ${studentCount} öğrenci var. En fazla ${studentCount} grup oluşturulacak.`;
        warningDiv.style.display = 'flex';
    } else if (maxGroups > Math.ceil(studentCount / 2)) {
        // Önerilen maksimum grup sayısından fazlaysa bilgi ver
        const recommended = Math.ceil(studentCount / 2);
        warningText.textContent = `💡 ${studentCount} öğrenci için önerilen maksimum grup sayısı: ${recommended}. Her grupta en az 2 öğrenci olması önerilir.`;
        warningDiv.style.display = 'flex';
    } else {
        // Normal durumda uyarı gösterme
        warningDiv.style.display = 'none';
    }
}

/**
 * Slider kontrollerini başlatır
 */
/**
 * Initialize thermal slider functionality
 */
function initializeThermalSliders() {
    const thermalSliders = document.querySelectorAll('.thermal-slider, .thermal-range-slider');
    
    thermalSliders.forEach(slider => {
        const thermalType = slider.getAttribute('data-thermal');
        
        // Set initial thermal color
        updateThermalSliderColor(slider, slider.value, thermalType);
        
        // Update color on change
        slider.addEventListener('input', function() {
            updateThermalSliderColor(this, this.value, thermalType);
        });
    });
}

/**
 * Update thermal slider color based on value
 */
function updateThermalSliderColor(slider, value, thermalType) {
    const thumb = slider;
    let color;
    
    switch(thermalType) {
        case 'term':
            // Blue gradient based on complexity (1-8)
            const termPercent = (value - 1) / 7; // 0 to 1
            color = interpolateColor('#3b82f6', '#1e40af', termPercent);
            break;
            
        case 'final':
            // Green gradient based on complexity (1-10)
            const finalPercent = (value - 1) / 9;
            color = interpolateColor('#10b981', '#065f46', finalPercent);
            break;
            
        case 'scoring':
            // Amber/Red gradient based on pass rate (0-100)
            const scoringPercent = value / 100;
            if (scoringPercent < 0.5) {
                color = interpolateColor('#ef4444', '#f59e0b', scoringPercent * 2);
            } else {
                color = interpolateColor('#f59e0b', '#10b981', (scoringPercent - 0.5) * 2);
            }
            break;
            

            
        case 'group-min':
            color = '#10b981'; // Green for min
            break;
            
        case 'group-max':
            color = '#ef4444'; // Red for max
            break;
            
        default:
            color = '#3b82f6';
    }
    
    // Apply color to slider thumb
    const style = document.createElement('style');
    style.textContent = `
        .thermal-slider[data-thermal="${thermalType}"]::-webkit-slider-thumb,
        .thermal-range-slider[data-thermal="${thermalType}"]::-webkit-slider-thumb {
            border-color: ${color} !important;
        }
        .thermal-slider[data-thermal="${thermalType}"]::-moz-range-thumb,
        .thermal-range-slider[data-thermal="${thermalType}"]::-moz-range-thumb {
            border-color: ${color} !important;
        }
    `;
    
    // Remove old style if exists
    const oldStyle = document.querySelector(`style[data-thermal="${thermalType}"]`);
    if (oldStyle) {
        oldStyle.remove();
    }
    
    style.setAttribute('data-thermal', thermalType);
    document.head.appendChild(style);
}

/**
 * Interpolate between two hex colors
 */
function interpolateColor(color1, color2, factor) {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    
    const r = Math.round(c1.r + (c2.r - c1.r) * factor);
    const g = Math.round(c1.g + (c2.g - c1.g) * factor);
    const b = Math.round(c1.b + (c2.b - c1.b) * factor);
    
    return `rgb(${r}, ${g}, ${b})`;
}

/**
 * Convert hex to RGB
 */
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

/**
 * Initialize group and scoring controls
 */
function initializeGroupControls() {
    // Pass Rate slider
    const passRateSlider = document.getElementById('passRateSlider');
    if (passRateSlider) {
        passRateSlider.addEventListener('input', function() {
            updatePassRateIndicators();
        });
    }
    
    // Update student and group counts
    updateGroupStatistics();
    
    // Update pass rate indicators
    updatePassRateIndicators();
}

/**
 * Update pass rate indicators in the UI
 */
function updatePassRateIndicators() {
    try {
        const passRateSlider = document.getElementById('passRateSlider');
        const passRateValue = document.getElementById('passRateValue');
        const rateIndicators = document.querySelectorAll('.rate-indicator');
        
        if (passRateSlider && passRateValue) {
            const passRate = parseInt(passRateSlider.value);
            const failRate = 100 - passRate;
            
            passRateValue.textContent = `${passRate}%`;
            
            // Calculate actual pass/fail counts if student data exists
            const studentCount = APP_STATE.studentData?.length || 0;
            let actualPassCount = 0;
            let actualFailCount = 0;
            
            if (studentCount > 0 && APP_STATE.gradesData) {
                // Count actual passing/failing students based on letter grades
                APP_STATE.studentData.forEach(student => {
                    const studentGrades = APP_STATE.gradesData[student.studentId];
                    if (studentGrades && studentGrades.harfNotu) {
                        const letterGrade = studentGrades.harfNotu;
                        // AA, BA, BB, CB, CC, DC = passing, DD, FD, FF = failing
                        const passingGrades = ['AA', 'BA', 'BB', 'CB', 'CC', 'DC'];
                        if (passingGrades.includes(letterGrade)) {
                            actualPassCount++;
                        } else {
                            actualFailCount++;
                        }
                    }
                });
            }
            
            // Update rate indicators with actual or estimated counts
            rateIndicators.forEach(indicator => {
                if (indicator.classList.contains('pass')) {
                    if (actualPassCount > 0) {
                        const actualPassRate = Math.round((actualPassCount / studentCount) * 100);
                        indicator.innerHTML = `Geçen: <strong>${actualPassCount} (${actualPassRate}%)</strong>`;
                    } else {
                        const estimatedPassCount = Math.round((passRate / 100) * studentCount);
                        indicator.innerHTML = `Geçen: <strong>~${estimatedPassCount} (${passRate}%)</strong>`;
                    }
                } else if (indicator.classList.contains('fail')) {
                    if (actualFailCount > 0) {
                        const actualFailRate = Math.round((actualFailCount / studentCount) * 100);
                        indicator.innerHTML = `Kalan: <strong>${actualFailCount} (${actualFailRate}%)</strong>`;
                    } else {
                        const estimatedFailCount = Math.round((failRate / 100) * studentCount);
                        indicator.innerHTML = `Kalan: <strong>~${estimatedFailCount} (${failRate}%)</strong>`;
                    }
                }
            });
            
            // Ayrıca status badge'leri de güncelle
            const passRateDisplay = document.getElementById('passRateDisplay');
            const failRateDisplay = document.getElementById('failRateDisplay');
            
            if (passRateDisplay) {
                if (actualPassCount > 0) {
                    const actualPassRate = Math.round((actualPassCount / studentCount) * 100);
                    passRateDisplay.textContent = `${actualPassCount} (${actualPassRate}%)`;
                } else {
                    const estimatedPassCount = Math.round((passRate / 100) * studentCount);
                    passRateDisplay.textContent = `${estimatedPassCount} (${passRate}%)`;
                }
            }
            
            if (failRateDisplay) {
                if (actualFailCount > 0) {
                    const actualFailRate = Math.round((actualFailCount / studentCount) * 100);
                    failRateDisplay.textContent = `${actualFailCount} (${actualFailRate}%)`;
                } else {
                    const estimatedFailCount = Math.round((failRate / 100) * studentCount);
                    failRateDisplay.textContent = `${estimatedFailCount} (${failRate}%)`;
                }
            }
            
            // Update thermal color
            updateThermalSliderColor(passRateSlider, passRate, 'scoring');
        }
        
    } catch (error) {
        console.error("Pass rate indicators güncelleme hatası:", error);
    }
}

/**
 * Update group statistics display
 */
function updateGroupStatistics() {
    try {
        const totalStudentsCount = document.getElementById('totalStudentsCount');
        const activeGroupsCount = document.getElementById('activeGroupsCount');
        
        if (totalStudentsCount) {
            const studentCount = APP_STATE.studentData?.length || 0;
            totalStudentsCount.textContent = studentCount;
        }
        
        if (activeGroupsCount) {
            // Count unique groups across all components
            const uniqueGroups = new Set();
            if (APP_STATE.courseData?.grupHaritalari) {
                Object.values(APP_STATE.courseData.grupHaritalari).forEach(component => {
                    if (component.gruplar && component.gruplar.length > 0) {
                        component.gruplar.forEach(group => uniqueGroups.add(group));
                    }
                });
            }
            activeGroupsCount.textContent = uniqueGroups.size;
        }
        
        // Update pass/fail indicators based on current data
        updatePassRateIndicators();
        
    } catch (error) {
        console.error("Grup istatistikleri güncelleme hatası:", error);
    }
}

function initializeAssessmentSliders() {
    // Initialize thermal slider update functionality
    initializeThermalSliders();
    
    // Initialize new group controls
    initializeGroupControls();
    
    // Initialize separate range sliders (enhanced dual range system)
    initializeSeparateRangeSliders();
    
    // Yarıyıl içi slider (compact version)
    const termSlider = document.getElementById('termComponentsSlider');
    const termValue = document.getElementById('termComponentsValue');
    
    if (termSlider && termValue) {
        termSlider.addEventListener('input', function() {
            termValue.textContent = this.value;
            // Update thermal color for compact range
            updateCompactRangeColor(termSlider, this.value, 'term');
        });
    }
    
    // Yarıyıl sonu slider (compact version)
    const finalSlider = document.getElementById('finalComponentsSlider');
    const finalValue = document.getElementById('finalComponentsValue');
    
    if (finalSlider && finalValue) {
        finalSlider.addEventListener('input', function() {
            finalValue.textContent = this.value;
            // Update thermal color for compact range
            updateCompactRangeColor(finalSlider, this.value, 'final');
        });
    }
    
    // Pass rate slider (compact version)
    const passRateSlider = document.getElementById('passRateSlider');
    const passRateValue = document.getElementById('passRateValue');
    const passRateDisplay = document.getElementById('passRateDisplay');
    const failRateDisplay = document.getElementById('failRateDisplay');
    
    if (passRateSlider && passRateValue) {
        passRateSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            const failValue = 100 - value;
            
            // Tüm display'leri güncelle
            passRateValue.textContent = `${value}%`;
            if (passRateDisplay) passRateDisplay.textContent = `${value}%`;
            if (failRateDisplay) failRateDisplay.textContent = `${failValue}%`;
            
            updateCompactRangeColor(passRateSlider, value, 'scoring');
            updatePassRateIndicators();
        });
    }
    
    // Dual range slider'ını başlat (backwards compatibility)
    initializeDualRangeSlider();
}

/**
 * Dual range slider'ını başlatır ve yönetir
 */
function initializeDualRangeSlider() {
    const minSlider = document.getElementById('groupMinSlider');
    const maxSlider = document.getElementById('groupMaxSlider');
    const minValue = document.getElementById('groupMinValue');
    const maxValue = document.getElementById('groupMaxValue');
    const sliderRange = document.getElementById('sliderRange');

    if (!minSlider || !maxSlider || !minValue || !maxValue || !sliderRange) return;

    function updateSliderRange() {
        let min = parseInt(minSlider.value);
        let max = parseInt(maxSlider.value);
        
        // Min > Max olmasını engelle, ama min = max'e izin ver
        if (min > max) {
            if (minSlider === document.activeElement) {
                max = min;
                maxSlider.value = max;
            } else {
                min = max;
                minSlider.value = min;
            }
        }
        
        minValue.textContent = min;
        maxValue.textContent = max;

        // Görsel range güncelle (1-20 aralığı için)
        const percent1 = ((min - 1) / 19) * 100;
        const percent2 = ((max - 1) / 19) * 100;
        
        // Hem eski hem yeni slider sistemlerini destekle
        if (sliderRange) {
            sliderRange.style.left = percent1 + '%';
            sliderRange.style.width = (percent2 - percent1) + '%';
        }
        
        // Compact slider range için de güncelle
        const compactSliderRange = document.querySelector('.compact-slider-range');
        if (compactSliderRange) {
            compactSliderRange.style.left = percent1 + '%';
            compactSliderRange.style.width = (percent2 - percent1) + '%';
        }

        // Uyarı kontrol et
        updateDualRangeWarning(min, max);
    }

    minSlider.addEventListener('input', updateSliderRange);
    maxSlider.addEventListener('input', updateSliderRange);
    
    // İlk değerleri ayarla
    updateSliderRange();
}

// =============================================================================
// 🎯 SEPARATE RANGE SLIDERS - Enhanced Dual Range System
// =============================================================================

/**
 * Initialize separate dual range sliders (enhanced system)
 */
function initializeSeparateRangeSliders() {
    const minSlider = document.getElementById('groupMinSlider');
    const maxSlider = document.getElementById('groupMaxSlider');
    const groupMinDisplay = document.getElementById('groupMinDisplay');
    const groupMaxDisplay = document.getElementById('groupMaxDisplay');
    const groupMinValue = document.getElementById('groupMinValue');
    const groupMaxValue = document.getElementById('groupMaxValue');
    
    if (!minSlider || !maxSlider) return;
    
    function updateSeparateRange() {
        let minVal = parseInt(minSlider.value);
        let maxVal = parseInt(maxSlider.value);
        
        // Auto-adjust logic: min can't be greater than max
        if (minSlider === document.activeElement && minVal > maxVal) {
            // If user is moving min slider and it goes past max, move max too
            maxVal = minVal;
            maxSlider.value = maxVal;
        } else if (maxSlider === document.activeElement && maxVal < minVal) {
            // If user is moving max slider and it goes below min, move min too
            minVal = maxVal;
            minSlider.value = minVal;
        }
        
        // Update all display elements
        if (groupMinDisplay) groupMinDisplay.textContent = minVal;
        if (groupMaxDisplay) groupMaxDisplay.textContent = maxVal;
        if (groupMinValue) groupMinValue.textContent = minVal;
        if (groupMaxValue) groupMaxValue.textContent = maxVal;
        
        // Update thermal colors
        updateThermalSliderColor(minSlider, minVal, 'group-min');
        updateThermalSliderColor(maxSlider, maxVal, 'group-max');
        
        // Update warnings
        updateDualRangeWarning(minVal, maxVal);
    }
    
    // Event listeners
    minSlider.addEventListener('input', updateSeparateRange);
    maxSlider.addEventListener('input', updateSeparateRange);
    
    // Initialize values
    updateSeparateRange();
}

/**
 * Update compact range slider colors based on value
 */
function updateCompactRangeColor(slider, value, type) {
    if (!slider) return;
    
    let color = '#4CAF50'; // Default green
    
    switch (type) {
        case 'term':
            // Blue gradient for term (1-8 range)
            const termFactor = (value - 1) / 7;
            color = interpolateColor('#2196F3', '#1976D2', termFactor);
            break;
            
        case 'final':
            // Green gradient for final (1-10 range)
            const finalFactor = (value - 1) / 9;
            color = interpolateColor('#4CAF50', '#2E7D32', finalFactor);
            break;
            
        case 'scoring':
            // Red to green gradient for scoring (0-100 range)
            const scoreFactor = value / 100;
            if (scoreFactor < 0.5) {
                color = interpolateColor('#F44336', '#FF9800', scoreFactor * 2);
            } else {
                color = interpolateColor('#FF9800', '#4CAF50', (scoreFactor - 0.5) * 2);
            }
            break;
            
        case 'group-min':
            // Cyan gradient for group min (1-20 range)
            const minFactor = (value - 1) / 19;
            color = interpolateColor('#00BCD4', '#0097A7', minFactor);
            break;
            
        case 'group-max':
            // Orange gradient for group max (1-20 range)
            const maxFactor = (value - 1) / 19;
            color = interpolateColor('#FF9800', '#F57C00', maxFactor);
            break;
    }
    
    // Apply color to slider track
    const percent = ((value - slider.min) / (slider.max - slider.min)) * 100;
    slider.style.background = `linear-gradient(to right, ${color} 0%, ${color} ${percent}%, #e0e0e0 ${percent}%, #e0e0e0 100%)`;
}

// =============================================================================
// 🛡️ GÜVENLİK FONKSİYONLARI - Eksik fonksiyonlar için fallback
// =============================================================================

/**
 * Not görünümlerini güncelle - Ana fonksiyon
 */
function updateGradeDisplays() {
    try {
        // Öğrenci not tablosunu güncelle
        if (typeof updateStudentGradesTable === 'function') {
            updateStudentGradesTable();
        }
        
        // Genel istatistikleri güncelle
        updateModernStats();
        
        // Not girişi alanlarını güncelle
        const gradeInputs = document.querySelectorAll('input[type="number"][data-student-id]');
        gradeInputs.forEach(input => {
            const studentId = input.dataset.studentId;
            const activityId = input.dataset.activityId; // componentId değil activityId kullan
            
            if (activityId) {
                const grade = getStudentGrade(studentId, activityId);
                if (grade !== null && grade !== undefined) {
                    input.value = grade;
                }
            }
        });
        
        // Pass/Fail oranlarını güncelle
        if (typeof updatePassFailCounts === 'function') {
            updatePassFailCounts();
        }
        
        console.log('✅ Not görünümleri güncellendi');
    } catch (error) {
        console.error('❌ Not görünümleri güncellenirken hata:', error);
        showModernToast('Not görünümleri güncellenirken hata oluştu!', 'error');
    }
}

console.log('🛡️ Güvenlik fonksiyonları yüklendi');

// GUID sistemi tamamen kaldırıldı

// =============================================================================
// 🌈 RAINBOW THERMAL SLIDER SYSTEM
// =============================================================================

/**
 * Rainbow thermal slider'ları başlat
 */
function initializeRainbowSliders() {
    // Yarıyıl içi slider
    const termSlider = document.getElementById('termComponentsSlider');
    const termValue = document.getElementById('termComponentsValue');
    
    if (termSlider && termValue) {
        termSlider.addEventListener('input', function() {
            termValue.textContent = this.value;
            updateRainbowSliderThumb(termSlider, this.value, 'term');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(termSlider, termSlider.value, 'term');
    }
    
    // Yarıyıl sonu slider
    const finalSlider = document.getElementById('finalComponentsSlider');
    const finalValue = document.getElementById('finalComponentsValue');
    
    if (finalSlider && finalValue) {
        finalSlider.addEventListener('input', function() {
            finalValue.textContent = this.value;
            updateRainbowSliderThumb(finalSlider, this.value, 'final');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(finalSlider, finalSlider.value, 'final');
    }
    
    // Pass rate slider
    const passRateSlider = document.getElementById('passRateSlider');
    const passRateValue = document.getElementById('passRateValue');
    const passRateDisplay = document.getElementById('passRateDisplay');
    const failRateDisplay = document.getElementById('failRateDisplay');
    
    if (passRateSlider && passRateValue) {
        passRateSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            const failValue = 100 - value;
            
            // Tüm display'leri güncelle
            passRateValue.textContent = `${value}%`;
            if (passRateDisplay) passRateDisplay.textContent = `${value}%`;
            if (failRateDisplay) failRateDisplay.textContent = `${failValue}%`;
            
            updateRainbowSliderThumb(passRateSlider, value, 'score');
            updatePassRateIndicators();
            updatePassFailCounts(); // Status badge'leri güncelle
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(passRateSlider, passRateSlider.value, 'score');
    }
    
    // Grup slider'ları - Geliştirilmiş versiyon
    // Term slider'ları
    const termActivityCountSlider = document.getElementById('termActivityCountSlider');
    const termActivityCountValue = document.getElementById('termActivityCountValue');
    const termComponentsSlider = document.getElementById('termComponentsSlider');
    const termComponentsValue = document.getElementById('termComponentsValue');
    
    // Final slider'ları
    const finalActivityCountSlider = document.getElementById('finalActivityCountSlider');
    const finalActivityCountValue = document.getElementById('finalActivityCountValue');
    const finalComponentsSlider = document.getElementById('finalComponentsSlider');
    const finalComponentsValue = document.getElementById('finalComponentsValue');
    
    // Grup slider'ları
    const groupMinSlider = document.getElementById('groupMinSlider');
    const groupMaxSlider = document.getElementById('groupMaxSlider');
    const groupMinValue = document.getElementById('groupMinValue');
    const groupMaxValue = document.getElementById('groupMaxValue');
    
    if (groupMinSlider && groupMinValue && groupMaxSlider && groupMaxValue) {
        // Önceki event listener'ları temizle
        const newMinSlider = groupMinSlider.cloneNode(true);
        const newMaxSlider = groupMaxSlider.cloneNode(true);
        groupMinSlider.parentNode.replaceChild(newMinSlider, groupMinSlider);
        groupMaxSlider.parentNode.replaceChild(newMaxSlider, groupMaxSlider);
        
        // Yeni referansları al
        const minSlider = document.getElementById('groupMinSlider');
        const maxSlider = document.getElementById('groupMaxSlider');
        
        function updateGroupSliders() {
            let minVal = parseInt(minSlider.value);
            let maxVal = parseInt(maxSlider.value);
            
            // Sınır kontrolü
            const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
            const maxAllowed = studentCount > 0 ? Math.max(studentCount, 20) : 20;
            
            minVal = Math.max(1, Math.min(minVal, maxAllowed));
            maxVal = Math.max(1, Math.min(maxVal, maxAllowed));
            
            // Min > Max kontrolü
            if (minVal > maxVal) {
                if (minSlider === document.activeElement) {
                maxVal = minVal;
                } else {
                    minVal = maxVal;
                }
            }
            
            // Değerleri güncelle
            minSlider.value = minVal;
            maxSlider.value = maxVal;
            groupMinValue.textContent = minVal;
            groupMaxValue.textContent = maxVal;
            
            // Slider renklerini güncelle
            updateRainbowSliderThumb(minSlider, minVal, 'group-min');
            updateRainbowSliderThumb(maxSlider, maxVal, 'group-max');
            
            // Uyarıları güncelle
            if (typeof updateDualRangeWarning === 'function') {
            updateDualRangeWarning(minVal, maxVal);
            }
            
            console.log(`🎯 Grup slider'ları güncellendi: Min=${minVal}, Max=${maxVal}, Öğrenci=${studentCount}`);
        }
        
        // Event listener'ları ekle
        minSlider.addEventListener('input', updateGroupSliders);
        maxSlider.addEventListener('input', updateGroupSliders);
        
        // İlk değerleri ayarla
        updateGroupSliders();
    }
    
    // Term Activity Count Slider
    if (termActivityCountSlider && termActivityCountValue) {
        termActivityCountSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            termActivityCountValue.textContent = value;
            updateRainbowSliderThumb(termActivityCountSlider, value, 'term-activity');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(termActivityCountSlider, termActivityCountSlider.value, 'term-activity');
    }
    
    // Term Components Slider
    if (termComponentsSlider && termComponentsValue) {
        termComponentsSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            termComponentsValue.textContent = value;
            updateRainbowSliderThumb(termComponentsSlider, value, 'term');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(termComponentsSlider, termComponentsSlider.value, 'term');
    }
    
    // Final Activity Count Slider
    if (finalActivityCountSlider && finalActivityCountValue) {
        finalActivityCountSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            finalActivityCountValue.textContent = value;
            updateRainbowSliderThumb(finalActivityCountSlider, value, 'final-activity');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(finalActivityCountSlider, finalActivityCountSlider.value, 'final-activity');
    }
    
    // Final Components Slider
    if (finalComponentsSlider && finalComponentsValue) {
        finalComponentsSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            finalComponentsValue.textContent = value;
            updateRainbowSliderThumb(finalComponentsSlider, value, 'final');
        });
        // İlk değeri ayarla
        updateRainbowSliderThumb(finalComponentsSlider, finalComponentsSlider.value, 'final');
    }
    
    console.log('🌈 Rainbow thermal slider\'lar başlatıldı');
}

/**
 * Dual range uyarılarını güncelle
 */
function updateDualRangeWarning(minVal, maxVal) {
    // Grup sayısı uyarıları için basit kontrol
    const studentCount = APP_STATE.studentData ? APP_STATE.studentData.length : 0;
    
    if (studentCount > 0) {
        if (minVal > studentCount) {
            console.warn(`⚠️ Min grup sayısı (${minVal}) öğrenci sayısından (${studentCount}) fazla`);
        }
        if (maxVal > studentCount) {
            console.warn(`⚠️ Max grup sayısı (${maxVal}) öğrenci sayısından (${studentCount}) fazla`);
        }
    }
    
    if (minVal === maxVal) {
        console.log(`ℹ️ Sabit grup sayısı: ${minVal}`);
    } else {
        console.log(`ℹ️ Grup aralığı: ${minVal}-${maxVal}`);
    }
}

/**
 * Rainbow slider thumb rengini güncelle
 */
function updateRainbowSliderThumb(slider, value, type) {
    if (!slider) return;
    
    let color = '#007bff'; // Default blue
    
    switch (type) {
        case 'term':
            // Blue to Red gradient for term (1-8 range)
            const termFactor = (value - 1) / 7;
            color = interpolateRainbowColor([
                '#4a90e2', '#50c878', '#ffd700', '#ff8c00', '#ff4500'
            ], termFactor);
            break;
            
        case 'final':
            // Cyan to Red gradient for final (1-10 range)
            const finalFactor = (value - 1) / 9;
            color = interpolateRainbowColor([
                '#00bcd4', '#4caf50', '#8bc34a', '#ffeb3b', '#ff9800', '#f44336'
            ], finalFactor);
            break;
            
        case 'score':
            // Red to Green gradient for scoring (0-100 range)
            const scoreFactor = value / 100;
            color = interpolateRainbowColor([
                '#f44336', '#ff5722', '#ff9800', '#ffc107', '#8bc34a', '#4caf50'
            ], scoreFactor);
            break;
            
        case 'group-min':
            // Pink to Blue gradient for group min (1-20 range)
            const minFactor = (value - 1) / 19;
            color = interpolateRainbowColor([
                '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3'
            ], minFactor);
            break;
            
        case 'group-max':
            // Orange to Purple gradient for group max (1-20 range)
            const maxFactor = (value - 1) / 19;
            color = interpolateRainbowColor([
                '#ff9800', '#ff5722', '#f44336', '#e91e63', '#9c27b0'
            ], maxFactor);
            break;
            
        case 'term-activity':
            // Blue to Green gradient for term activity (1-100 range)
            const termActivityFactor = (value - 1) / 99;
            color = interpolateRainbowColor([
                '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a'
            ], termActivityFactor);
            break;
            
        case 'final-activity':
            // Purple to Cyan gradient for final activity (1-100 range)
            const finalActivityFactor = (value - 1) / 99;
            color = interpolateRainbowColor([
                '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4'
            ], finalActivityFactor);
            break;
    }
    
    // Thumb rengini güncelle
    slider.style.setProperty('--thumb-color', color);
    
    // CSS custom property ile thumb rengini ayarla
    const style = document.createElement('style');
    style.textContent = `
        #${slider.id}::-webkit-slider-thumb {
            border-color: ${color} !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 0 0 1px ${color} !important;
        }
        #${slider.id}::-moz-range-thumb {
            border-color: ${color} !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), 0 0 0 1px ${color} !important;
        }
    `;
    
    // Eski style'ı kaldır ve yenisini ekle
    const oldStyle = document.getElementById(`${slider.id}-style`);
    if (oldStyle) oldStyle.remove();
    
    style.id = `${slider.id}-style`;
    document.head.appendChild(style);
}

/**
 * Rainbow renk interpolasyonu
 */
function interpolateRainbowColor(colors, factor) {
    if (factor <= 0) return colors[0];
    if (factor >= 1) return colors[colors.length - 1];
    
    const scaledFactor = factor * (colors.length - 1);
    const index = Math.floor(scaledFactor);
    const nextIndex = Math.min(index + 1, colors.length - 1);
    const localFactor = scaledFactor - index;
    
    return interpolateColor(colors[index], colors[nextIndex], localFactor);
}

/**
 * Pass rate indicator'larını güncelle
 */
// İkinci updatePassRateIndicators fonksiyonu kaldırıldı - gelişmiş versiyon korundu

// DOMContentLoaded event'inde rainbow slider'ları başlat
document.addEventListener('DOMContentLoaded', function() {
    // Diğer başlatma işlemlerinden sonra rainbow slider'ları başlat
    setTimeout(() => {
        initializeRainbowSliders();
    }, 100);
});

// =====================================================
// AĞIRLIK DENGELEME SİSTEMİ
// =====================================================

/**
 * Yarıyıl içi etkinliklerin ağırlıklarını dengeler
 */
function balanceTermWeights() {
    try {
        const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
        
        if (termActivities.length === 0) return;
        
        console.log(`⚖️ ${termActivities.length} yarıyıl içi etkinliğin ağırlıkları dengeleniyor...`);
        
        // Eşit ağırlık dağılımı
        const baseWeight = Math.floor(100 / termActivities.length);
        const remainder = 100 - (baseWeight * termActivities.length);
        
        termActivities.forEach((activity, index) => {
            const oldWeight = activity.weight;
            const newWeight = baseWeight + (index < remainder ? 1 : 0);
            activity.weight = newWeight;
            console.log(`  📊 ${activity.id} (${activity.name}): ${oldWeight}% → ${newWeight}%`);
        });
        
        // Arayüzü güncelle
        renderTree();
        updateCategoryWeights();
        updateAssessmentView(); 
        
        console.log(`✅ Yarıyıl içi ağırlık dengeleme tamamlandı`);
        
    } catch (error) {
        console.error('❌ Yarıyıl içi ağırlık dengeleme hatası:', error);
    }
}

/**
 * Yarıyıl sonu etkinliklerin ağırlıklarını dengeler
 */
function balanceFinalWeights() {
    try {
        const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
        
        if (finalActivities.length === 0) return;
        
        console.log(`⚖️ ${finalActivities.length} yarıyıl sonu etkinliğin ağırlıkları dengeleniyor...`);
        
        // Eşit ağırlık dağılımı
        const baseWeight = Math.floor(100 / finalActivities.length);
        const remainder = 100 - (baseWeight * finalActivities.length);
        
        finalActivities.forEach((activity, index) => {
            const oldWeight = activity.weight;
            const newWeight = baseWeight + (index < remainder ? 1 : 0);
            activity.weight = newWeight;
            console.log(`  📊 ${activity.id} (${activity.name}): ${oldWeight}% → ${newWeight}%`);
        });
        
        // Arayüzü güncelle
        renderTree();
        updateCategoryWeights();
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        console.log(`✅ Yarıyıl sonu ağırlık dengeleme tamamlandı`);
        
    } catch (error) {
        console.error('❌ Yarıyıl sonu ağırlık dengeleme hatası:', error);
    }
}

// =============================================================================
// HIZLI AĞIRLIK DÜZELTİCİ - CONSOLE İÇİN KULLANIM
// =============================================================================

/**
 * Mevcut ağırlıkları hızlıca düzeltir
 * Console'da çalıştırmak için: quickFixWeights()
 */
function quickFixWeights() {
    console.log('🔧 Mevcut ağırlıkları düzeltiliyor...');
    
    // Yarıyıl içi ağırlıklarını dengele
    const termActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('A'));
    if (termActivities.length > 0) {
        const baseWeight = Math.floor(100 / termActivities.length);
        const remainder = 100 - (baseWeight * termActivities.length);
        
        termActivities.forEach((activity, index) => {
            const oldWeight = activity.weight;
            const newWeight = baseWeight + (index < remainder ? 1 : 0);
            activity.weight = newWeight;
            console.log(`  📊 Yarıyıl İçi ${activity.id}: ${oldWeight}% → ${newWeight}%`);
        });
    }
    
    // Yarıyıl sonu ağırlıklarını dengele
    const finalActivities = APP_STATE.assessmentTree.filter(node => node.id.startsWith('F'));
    if (finalActivities.length > 0) {
        const baseWeight = Math.floor(100 / finalActivities.length);
        const remainder = 100 - (baseWeight * finalActivities.length);
        
        finalActivities.forEach((activity, index) => {
            const oldWeight = activity.weight;
            const newWeight = baseWeight + (index < remainder ? 1 : 0);
            activity.weight = newWeight;
            console.log(`  📊 Yarıyıl Sonu ${activity.id}: ${oldWeight}% → ${newWeight}%`);
        });
    }
    
    // Arayüzü güncelle
    renderTree();
    updateCategoryWeights();
    // Değerlendirme sekmesini güncelle - CRITICAL SYNC
    updateAssessmentView();
    
    console.log('✅ Ağırlık dengeleme tamamlandı!');
    showModernToast('🔧 Mevcut ağırlıklar düzeltildi!', 'success', 3000);
}

/**
 * Toast sistemini test et
 */
function testToastSystem() {
    console.log('🧪 Toast sistemi test ediliyor...');
    
    // Toast elementinin varlığını kontrol et
    const toastElement = document.getElementById('modernToast');
    const messageElement = document.getElementById('modernToastMessage');
    
    if (!toastElement) {
        console.error('❌ modernToast elementi bulunamadı!');
        return;
    }
    
    if (!messageElement) {
        console.error('❌ modernToastMessage elementi bulunamadı!');
        return;
    }
    
    console.log('✅ Toast elementleri bulundu');
    console.log('Toast element:', toastElement);
    console.log('Message element:', messageElement);
    
    // Test mesajları gönder
    setTimeout(() => {
        console.log('🔥 Success toast gönderiliyor...');
        showModernToast('Test başarılı mesajı!', 'success', 3000);
    }, 1000);
    
    setTimeout(() => {
        console.log('⚠️ Warning toast gönderiliyor...');
        showModernToast('Test uyarı mesajı!', 'warning', 3000);
    }, 2000);
    
    setTimeout(() => {
        console.log('❌ Error toast gönderiliyor...');
        showModernToast('Test hata mesajı!', 'error', 3000);
    }, 3000);
}


/**
 * v5 formatı için grup değişikliği işleme - öğrenci grup değiştirdiğinde çağrılır
 */
function handleGroupChangeV5(studentId, componentId, newGroupId) {
    console.log(`🔄 v5 Grup değişikliği - Öğrenci: ${studentId}, Bileşen: ${componentId}, Yeni Grup: ${newGroupId}`);
    
    try {
        // v5 formatında grup bilgisini güncelle
        if (!APP_STATE.studentComponentGroups) APP_STATE.studentComponentGroups = {};
        if (!APP_STATE.studentComponentGroups[studentId]) APP_STATE.studentComponentGroups[studentId] = {};
        
        APP_STATE.studentComponentGroups[studentId][componentId] = newGroupId;
        
        // gradesData'daki grup bilgilerini de güncelle
        if (!APP_STATE.gradesData[studentId]) APP_STATE.gradesData[studentId] = {};
        if (!APP_STATE.gradesData[studentId].grupBilgileri) APP_STATE.gradesData[studentId].grupBilgileri = {};
        
        APP_STATE.gradesData[studentId].grupBilgileri[componentId] = newGroupId;
        
        // UI'ı güncelle
        updateStudentCalculatedGrade(studentId);
        updateAssessmentGradeSummary(studentId);
        updateStudentSummary(studentId);
        
        console.log(`✅ v5 Grup bilgisi güncellendi: ${studentId} → ${componentId} → ${newGroupId}`);
        
    } catch (error) {
        console.error("v5 grup değişikliği işlenirken hata oluştu:", error);
    }
}

// =============================================================================
// PUAN TEST İŞLEMLERİ - PUANLARI EŞİTLEME VE KARIŞTIRMA
// =============================================================================

/**
 * Tüm soru ve rubrik puanlarını eşitler
 * Değerlendirme unsurlarındaki tüm sorular ve rubrikler eşit puan alır
 * ÖZEL: Sınav toplamının 100 olmasını garanti eder
 */
function equalizeAllPoints() {
    try {
        console.log('⚖️ Tüm puanlar eşitleniyor...');
        
        let totalChanges = 0;
        let totalActivities = 0;
        
        // Tüm etkinlikleri gez
        APP_STATE.assessmentTree.forEach(activity => {
            if (activity.children && activity.children.length > 0) {
                console.log(`📝 ${activity.name} etkinliği işleniyor...`);
                
                // Etkinliğin toplam puanını al
                const activityTotalPoints = activity.points || 100;
                const itemCount = activity.children.length;
                
                if (itemCount > 0) {
                    // Mevcut puanları kontrol et
                    const currentPoints = activity.children.map(item => item.points || 0);
                    const allPointsSame = currentPoints.every(point => point === currentPoints[0]);
                    
                    // Sadece puanlar farklıysa eşitle
                    if (!allPointsSame || currentPoints[0] !== Math.floor(activityTotalPoints / itemCount)) {
                        // Eşit dağılım hesapla
                        const equalPoints = Math.floor(activityTotalPoints / itemCount);
                        const remainder = activityTotalPoints - (equalPoints * itemCount);
                        
                        console.log(`  🔢 Toplam puan: ${activityTotalPoints}, Öğe sayısı: ${itemCount}, Eşit puan: ${equalPoints}, Kalan: ${remainder}`);
                        console.log(`  📊 Mevcut dağılım: [${currentPoints.join(', ')}]`);
                        
                        let activityChanges = 0;
                        // Her soru/rubriğe eşit puan ver
                        activity.children.forEach((item, index) => {
                            const oldPoints = item.points;
                            // İlk 'remainder' kadar öğeye 1 fazla puan ver
                            const newPoints = equalPoints + (index < remainder ? 1 : 0);
                            
                            if (oldPoints !== newPoints) {
                                item.points = newPoints;
                                totalChanges++;
                                activityChanges++;
                                console.log(`    🔄 ${item.name}: ${oldPoints} → ${newPoints} puan`);
                            }
                        });
                        
                        if (activityChanges > 0) {
                            totalActivities++;
                        }
                        
                        // ✅ TOPLAM KONTROL: Etkinlik toplamının doğru olduğunu kontrol et
                        const calculatedTotal = activity.children.reduce((sum, item) => sum + (item.points || 0), 0);
                        if (calculatedTotal !== activityTotalPoints) {
                            console.warn(`⚠️ TOPLAM PUAN HATASI: ${activity.name} - Hedef: ${activityTotalPoints}, Hesaplanan: ${calculatedTotal}`);
                            
                            // Son öğeye farkı ekle/çıkar
                            const difference = activityTotalPoints - calculatedTotal;
                            if (activity.children.length > 0) {
                                const lastItem = activity.children[activity.children.length - 1];
                                lastItem.points = (lastItem.points || 0) + difference;
                                console.log(`    🔧 DÜZELTME: ${lastItem.name} puanı ${difference > 0 ? '+' : ''}${difference} ayarlandı → ${lastItem.points}`);
                            }
                        }
                        
                        // ✅ KONTROL: Nihai toplam doğrulama
                        const finalTotal = activity.children.reduce((sum, item) => sum + (item.points || 0), 0);
                        const finalPoints = activity.children.map(item => item.points || 0);
                        console.log(`    ✅ Nihai Kontrol: ${activity.name} toplam = ${finalTotal} (Hedef: ${activityTotalPoints})`);
                        console.log(`    📊 Yeni dağılım: [${finalPoints.join(', ')}]`);
                    } else {
                        console.log(`  ✅ ${activity.name} puanları zaten eşit (${currentPoints[0]} puan)`);
                    }
                }
            }
        });
        
        if (totalChanges > 0) {
            // Arayüzü güncelle
            renderTree();
            updateCategoryWeights();
            // Değerlendirme sekmesini güncelle - CRITICAL SYNC
            updateAssessmentView();
            
            console.log(`✅ Puan eşitleme tamamlandı. ${totalActivities} etkinlikte ${totalChanges} değişiklik yapıldı.`);
            showModernToast(`⚖️ ${totalActivities} etkinlikte ${totalChanges} soru/rubrik puanı eşitlendi! Toplam puan korundu.`, 'success', 3000);
        } else {
            console.log('ℹ️ Eşitlenecek puan bulunamadı.');
            showModernToast('ℹ️ Tüm puanlar zaten eşit durumda!', 'info', 3000);
        }
        
    } catch (error) {
        console.error('❌ Puan eşitleme hatası:', error);
        showModernToast('❌ Puan eşitleme sırasında hata oluştu!', 'error', 3000);
    }
}

/**
 * Tüm soru ve rubrik puanlarını karıştırır
 * Mevcut puanları alır ve rastgele olarak yeniden dağıtır
 */
function shuffleAllPoints() {
    try {
        console.log('🎲 Tüm puanlar karıştırılıyor...');
        
        // Debug: Ağaç durumunu kontrol et
        console.log('🔍 DEBUG: APP_STATE.assessmentTree durumu:', APP_STATE.assessmentTree);
        console.log('🔍 DEBUG: Ağaç uzunluğu:', APP_STATE.assessmentTree.length);
        
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            console.warn('⚠️ Değerlendirme ağacı boş veya tanımsız!');
            showModernToast('⚠️ Önce değerlendirme kriterleri oluşturun!', 'warning', 3000);
            return;
        }
        
        let totalChanges = 0;
        let totalShuffles = 0;
        
        // Tüm etkinlikleri gez
        APP_STATE.assessmentTree.forEach((activity, actIndex) => {
            console.log(`🔍 DEBUG: ${actIndex}. etkinlik inceleniyor:`, activity);
            if (activity.children && activity.children.length > 1) {
                console.log(`📝 ${activity.name} etkinliği işleniyor...`);
                
                // Mevcut puanları topla
                const currentPoints = activity.children.map(item => item.points || 0);
                const originalPoints = [...currentPoints]; // Orijinal sırayı koru
                
                // Eğer tüm puanlar aynıysa, önce farklı puanlar ata
                const allPointsSame = currentPoints.every(point => point === currentPoints[0]);
                if (allPointsSame && currentPoints.length > 1) {
                    console.log(`  ⚠️ Tüm puanlar aynı (${currentPoints[0]}), önce farklı puanlar atanıyor...`);
                    
                    // Toplam puanı koru
                    const totalPoints = currentPoints.reduce((sum, point) => sum + point, 0);
                    const itemCount = currentPoints.length;
                    
                    // Farklı puanlar oluştur (minimum 1 puan)
                    const newPoints = [];
                    let remainingPoints = totalPoints;
                    
                    for (let i = 0; i < itemCount - 1; i++) {
                        // Her öğeye rastgele puan ver (1 ile kalan puanın yarısı arasında)
                        const maxForThis = Math.max(1, Math.floor(remainingPoints / (itemCount - i) * 1.5));
                        const minForThis = Math.max(1, Math.floor(remainingPoints / (itemCount - i) * 0.5));
                        const randomPoints = Math.floor(Math.random() * (maxForThis - minForThis + 1)) + minForThis;
                        
                        newPoints.push(Math.min(randomPoints, remainingPoints - (itemCount - i - 1)));
                        remainingPoints -= newPoints[i];
                    }
                    
                    // Son öğeye kalan puanı ver
                    newPoints.push(Math.max(1, remainingPoints));
                    
                    // Yeni puanları ata
                    currentPoints.splice(0, currentPoints.length, ...newPoints);
                    console.log(`  🎯 Farklı puanlar atandı: [${currentPoints.join(', ')}]`);
                }
                
                // Puanları karıştır (Fisher-Yates shuffle algoritması)
                for (let i = currentPoints.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentPoints[i], currentPoints[j]] = [currentPoints[j], currentPoints[i]];
                }
                
                console.log(`  🔄 Orijinal: [${originalPoints.join(', ')}] → Karıştırılmış: [${currentPoints.join(', ')}]`);
                
                // Karıştırılan puanları ata
                let activityChanges = 0;
                activity.children.forEach((item, index) => {
                    const oldPoints = item.points;
                    const newPoints = currentPoints[index];
                    
                    if (oldPoints !== newPoints) {
                        item.points = newPoints;
                        totalChanges++;
                        activityChanges++;
                        console.log(`    🎯 ${item.name}: ${oldPoints} → ${newPoints} puan`);
                    }
                });
                
                if (activityChanges > 0) {
                    totalShuffles++;
                }
            } else if (activity.children && activity.children.length === 1) {
                console.log(`  ⚠️ ${activity.name} etkinliğinde tek öğe var, karıştırılamaz.`);
            }
        });
        
        if (totalChanges > 0) {
            // Arayüzü güncelle
            renderTree();
            updateCategoryWeights();
            // Değerlendirme sekmesini güncelle - CRITICAL SYNC
            updateAssessmentView();
            // Değerlendirme tablolarını güncelle
            
            console.log(`✅ Puan karıştırma tamamlandı. ${totalShuffles} etkinlikte ${totalChanges} değişiklik yapıldı.`);
            showModernToast(`🎲 ${totalShuffles} etkinlikte ${totalChanges} soru/rubrik puanı karıştırıldı!`, 'success', 3000);
        } else {
            console.log('ℹ️ Karıştırılacak puan bulunamadı.');
            showModernToast('ℹ️ Karıştırılacak çoklu puan bulunamadı!', 'info', 3000);
        }
        
    } catch (error) {
        console.error('❌ Puan karıştırma hatası:', error);
        showModernToast('❌ Puan karıştırma sırasında hata oluştu!', 'error', 3000);
    }
}

/**
 * Belirli bir etkinlikteki puanları eşitler
 * @param {string} activityId - Etkinlik ID'si
 */
function equalizeActivityPoints(activityId) {
    try {
        const activity = findNodeById(activityId);
        if (!activity || !activity.children || activity.children.length === 0) {
            console.warn(`⚠️ ${activityId} etkinliği bulunamadı veya alt öğesi yok.`);
            return;
        }
        
        console.log(`⚖️ ${activity.name} etkinliğinin puanları eşitleniyor...`);
        
        const activityTotalPoints = activity.points || 100;
        const itemCount = activity.children.length;
        const equalPoints = Math.floor(activityTotalPoints / itemCount);
        const remainder = activityTotalPoints - (equalPoints * itemCount);
        
        let changes = 0;
        activity.children.forEach((item, index) => {
            const oldPoints = item.points;
            const newPoints = equalPoints + (index < remainder ? 1 : 0);
            
            if (oldPoints !== newPoints) {
                item.points = newPoints;
                changes++;
                console.log(`  🔄 ${item.name}: ${oldPoints} → ${newPoints} puan`);
            }
        });
        
        if (changes > 0) {
            renderTree();

            // Değerlendirme sekmesini güncelle - CRITICAL SYNC
            updateAssessmentView();
            console.log(`✅ ${activity.name} etkinliğinde ${changes} puan eşitlendi.`);
            showModernToast(`⚖️ ${activity.name} puanları eşitlendi!`, 'success', 2000);
        }
        
    } catch (error) {
        console.error('❌ Etkinlik puan eşitleme hatası:', error);
    }
}

/**
 * Belirli bir etkinlikteki puanları karıştırır
 * @param {string} activityId - Etkinlik ID'si
 */
function shuffleActivityPoints(activityId) {
    try {
        const activity = findNodeById(activityId);
        if (!activity || !activity.children || activity.children.length <= 1) {
            console.warn(`⚠️ ${activityId} etkinliği bulunamadı veya karıştırılacak yeterli öğe yok.`);
            return;
        }
        
        console.log(`🎲 ${activity.name} etkinliğinin puanları karıştırılıyor...`);
        
        const currentPoints = activity.children.map(item => item.points || 0);
        const originalPoints = [...currentPoints];
        
        // Fisher-Yates shuffle
        for (let i = currentPoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [currentPoints[i], currentPoints[j]] = [currentPoints[j], currentPoints[i]];
        }
        
        let changes = 0;
        activity.children.forEach((item, index) => {
            const oldPoints = item.points;
            const newPoints = currentPoints[index];
            
            if (oldPoints !== newPoints) {
                item.points = newPoints;
                changes++;
                console.log(`  🎯 ${item.name}: ${oldPoints} → ${newPoints} puan`);
            }
        });
        
        if (changes > 0) {
            renderTree();
            // Değerlendirme sekmesini güncelle - CRITICAL SYNC
            updateAssessmentView();
            console.log(`✅ ${activity.name} etkinliğinde ${changes} puan karıştırıldı.`);
            showModernToast(`🎲 ${activity.name} puanları karıştırıldı!`, 'success', 2000);
        }
        
    } catch (error) {
        console.error('❌ Etkinlik puan karıştırma hatası:', error);
    }
}

/**
 * Debug amaçlı - mevcut ağaç yapısını ve puanları konsola yazdırır
 */
function debugAssessmentTree() {
    console.log("🔍 === AĞAÇ YAPISI DEBUG BİLGİSİ ===");
    console.log("Ağaç uzunluğu:", APP_STATE.assessmentTree?.length || 0);
    
    if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
        console.log("❌ Ağaç boş veya tanımsız!");
        return;
    }
    
    APP_STATE.assessmentTree.forEach((activity, index) => {
        console.log(`📁 ${index + 1}. ETKİNLİK: ${activity.name}`);
        console.log(`   ID: ${activity.id}`);
        console.log(`   Puan: ${activity.points}`);
        console.log(`   Alt öğe sayısı: ${activity.children?.length || 0}`);
        
        if (activity.children && activity.children.length > 0) {
            activity.children.forEach((child, childIndex) => {
                console.log(`   └── ${childIndex + 1}. ${child.name}: ${child.points} puan`);
            });
            
            const totalChildPoints = activity.children.reduce((sum, child) => sum + (child.points || 0), 0);
            console.log(`   📊 Alt öğe toplamı: ${totalChildPoints}`);
            
            const allSame = activity.children.every(child => child.points === activity.children[0].points);
            console.log(`   ⚖️ Tüm puanlar eşit mi: ${allSame ? "EVET" : "HAYIR"}`);
        }
    });
    
    console.log("🔍 === DEBUG BİLGİSİ SONU ===");
}

// Konsola erişim için global olarak ekle
window.debugAssessmentTree = debugAssessmentTree;


/**
 * Tüm input alanlarına maksimum puan bilgisi ekleyen birleşik fonksiyon
 * Hem Öğrenci Notları hem de Değerlendirme Girişi sekmelerinde çalışır
 */
function addMaxPointsToAllRows() {
    console.log('🔧 Değerlendirme Girişi sekmesindeki input alanlarına maksimum puan bilgisi ekleniyor...');
    
    // Sadece Değerlendirme Girişi sekmesi için (assessment-table içindeki input'lar)
    const assessmentInputs = document.querySelectorAll('.assessment-table input[type="number"]');
    console.log('📊 Assessment table input sayısı:', assessmentInputs.length);
    
    assessmentInputs.forEach((input, index) => {
        const maxValue = parseFloat(input.max) || 0;
        
        if (maxValue > 0) {
            // Maksimum puan bilgisi spanini kontrol et/ekle
            let maxInfoSpan = input.parentElement.querySelector('.max-points-info');
            if (!maxInfoSpan) {
                maxInfoSpan = document.createElement('span');
                maxInfoSpan.className = 'max-points-info';
                maxInfoSpan.style.cssText = 'font-size: 10px; color: #666; margin-left: 5px; font-weight: bold; display: block;';
                input.parentElement.appendChild(maxInfoSpan);
            }
            
            maxInfoSpan.textContent = '(max: ' + maxValue + ')';
            console.log(`✅ Assessment input ${index + 1}: max ${maxValue} eklendi`);
        }
    });
    
    console.log(`🏁 Toplam ${assessmentInputs.length} input için maksimum puan bilgileri güncellendi`);
}

// Global erişim için
window.addMaxPointsToAllRows = addMaxPointsToAllRows;

/**
 * DOM değişikliklerini izleyerek yeni input alanlarına maksimum puan bilgisi ekleyen observer
 */
let maxPointsObserver = null;

function initMaxPointsObserver() {
    // Önceki observer'ı temizle
    if (maxPointsObserver) {
        maxPointsObserver.disconnect();
    }
    
    // Yeni observer oluştur
    maxPointsObserver = new MutationObserver((mutations) => {
        let hasNewInputs = false;
        
        mutations.forEach((mutation) => {
            // Yeni eklenen node'ları kontrol et
            mutation.addedNodes.forEach((node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    // Assessment table içindeki input elemanları
                    if (node.matches && node.matches('.assessment-table input[type="number"]')) {
                        hasNewInputs = true;
                    }
                    // İçinde assessment table input'ları olan konteynerlar
                    else if (node.querySelectorAll) {
                        const inputs = node.querySelectorAll('.assessment-table input[type="number"]');
                        if (inputs.length > 0) {
                            hasNewInputs = true;
                        }
                    }
                }
            });
        });
        
        // Yeni input'lar varsa maksimum puan bilgilerini ekle
        if (hasNewInputs) {
            setTimeout(() => {
                addMaxPointsToAllRows();
            }, 50);
        }
    });
    
    // Observer'ı başlat - assessmentContainer'ı izle
    const container = document.getElementById('assessmentContainer');
    if (container) {
        maxPointsObserver.observe(container, {
            childList: true,
            subtree: true
        });
        console.log('👁️ Assessment container için maksimum puan observer başlatıldı');
    } else {
        console.log('⚠️ assessmentContainer bulunamadı, document.body izleniyor');
        // Fallback: tüm document body'yi izle
        maxPointsObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
    }
}

// Global erişim için
window.initMaxPointsObserver = initMaxPointsObserver;



// Maksimum puan observer'ını sayfa yüklendiğinde başlat
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Sayfa yüklendi, maksimum puan observer başlatılıyor...');
    initMaxPointsObserver();
});

// Manual test fonksiyonları
function testMaxPointsManually() {
    console.log('🧪 Manuel test başlatılıyor...');
    
    // 1. Assessment Container kontrol
    const container = document.getElementById('assessmentContainer');
    console.log('📦 Assessment Container var mı?', !!container);
    if (container) {
        console.log('📦 Assessment Container innerHTML uzunluğu:', container.innerHTML.length);
    }
    
    // 2. Assessment table input elemanları kontrol
    const inputs = document.querySelectorAll('.assessment-table input[type="number"]');
    console.log('🎯 Assessment input sayısı:', inputs.length);
    
    // 3. Maksimum puan fonksiyonunu zorla çağır
    if (typeof addMaxPointsToAllRows === 'function') {
        console.log('✅ addMaxPointsToAllRows fonksiyonu mevcut');
        addMaxPointsToAllRows();
    } else {
        console.log('❌ addMaxPointsToAllRows fonksiyonu mevcut değil');
    }
    
    // 4. Observer'ı zorla başlat
    if (typeof initMaxPointsObserver === 'function') {
        console.log('✅ initMaxPointsObserver fonksiyonu mevcut');
        initMaxPointsObserver();
    } else {
        console.log('❌ initMaxPointsObserver fonksiyonu mevcut değil');
    }
}

// Global erişim için
window.testMaxPointsManually = testMaxPointsManually;



// Daha güçlü DOM ready handler
function forceInitMaxPoints() {
    console.log('🚀 Değerlendirme Girişi için maksimum puan başlatıcısı çalışıyor...');
    
    // Observer'ı başlat
    if (typeof initMaxPointsObserver === 'function') {
        initMaxPointsObserver();
    }
    
    // Hemen maksimum puanları ekle
    if (typeof addMaxPointsToAllRows === 'function') {
        addMaxPointsToAllRows();
    }
    
    // 2 saniye sonra tekrar kontrol et
    setTimeout(() => {
        console.log('🔄 2 saniye sonra tekrar kontrol...');
        if (typeof addMaxPointsToAllRows === 'function') {
            addMaxPointsToAllRows();
        }
    }, 2000);
}

// Global erişim
window.forceInitMaxPoints = forceInitMaxPoints;

// Sayfa tamamen yüklendiğinde zorla başlat
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', forceInitMaxPoints);
} else {
    // Sayfa zaten yüklü
    forceInitMaxPoints();
}

// =====================================================
// GELİŞMİŞ DEĞİŞİKLİK TAKİP SİSTEMİ
// =====================================================

// Global değişken: Son güncelleme zamanını takip et
let lastAssessmentTreeHash = '';
let assessmentChangeTracker = null;

/**
 * Değerlendirme ağacı değişiklik takip sistemi
 * Değerlendirme bileşenlerinde değişiklik olduğunda otomatik tabloyu yeniden oluşturur
 */
function initializeAssessmentChangeTracking() {
    try {
        console.log('🔄 Değerlendirme değişiklik takip sistemi başlatılıyor...');
        
        // İlk hash'i hesapla
        updateAssessmentTreeHash();
        
        // Önceki tracker'ı temizle
        if (assessmentChangeTracker) {
            clearInterval(assessmentChangeTracker);
        }
        
        // Her 1000ms'de bir değişiklik kontrolü yap (performanslı)
        assessmentChangeTracker = setInterval(checkForAssessmentChanges, 1000);
        
        console.log('✅ Değerlendirme değişiklik takip sistemi aktif');
    } catch (error) {
        console.error('Değerlendirme değişiklik takip sistemi başlatılamadı:', error);
    }
}

/**
 * Değerlendirme ağacının mevcut durumunun hash'ini hesapla
 */
function updateAssessmentTreeHash() {
    try {
        // Önemli alanları içeren basitleştirilmiş ağaç yapısı oluştur
        const simplifiedTree = createSimplifiedAssessmentTree();
        lastAssessmentTreeHash = generateHashFromObject(simplifiedTree);
    } catch (error) {
        console.warn("Assessment tree hash hesaplanamadı:", error);
        lastAssessmentTreeHash = '';
    }
}

/**
 * Değerlendirme ağacının basitleştirilmiş versiyonunu oluştur (sadece önemli alanlar)
 */
function createSimplifiedAssessmentTree() {
    if (!APP_STATE.assessmentTree || !Array.isArray(APP_STATE.assessmentTree)) return {};
    
    const simplified = APP_STATE.assessmentTree.map(node => ({
        id: node.id,
        name: node.name || '',
        type: node.type || '',
        weight: node.weight || 0,
        points: node.points || 0,
        outcomes: Array.isArray(node.outcomes) ? node.outcomes.sort().join(',') : (node.outcomes || ''),
        description: node.description || '',
        children: node.children ? node.children.map(child => ({
            id: child.id,
            name: child.name || '',
            type: child.type || '',
            weight: child.weight || 0,
            points: child.points || 0,
            outcomes: Array.isArray(child.outcomes) ? child.outcomes.sort().join(',') : (child.outcomes || ''),
            description: child.description || '',
            // Test detayları da dahil et
            testDetails: child.testDetails ? {
                totalQuestions: child.testDetails.totalQuestions || 0,
                correctWeight: child.testDetails.correctWeight || 0,
                wrongPenalty: child.testDetails.wrongPenalty || 0
            } : null
        })) : []
    }));
    
    // Grup bilgilerini de dahil et
    const groupMappings = APP_STATE.courseData?.grupHaritalari || {};
    
    return {
        tree: simplified,
        gruplar: groupMappings,
        termWeight: APP_STATE.termWeight,
        finalWeight: APP_STATE.finalWeight,
        studentCount: APP_STATE.studentData ? APP_STATE.studentData.length : 0
    };
}

/**
 * Nesne için basit hash hesapla
 */
function generateHashFromObject(obj) {
    try {
        const str = JSON.stringify(obj, Object.keys(obj).sort());
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 32 bit integer'a dönüştür
        }
        return hash.toString();
    } catch (error) {
        console.warn('Hash hesaplanırken hata:', error);
        return Date.now().toString(); // Fallback
    }
}

/**
 * Değerlendirme ağacında değişiklik kontrolü yap
 */
function checkForAssessmentChanges() {
    try {
        // Sadece değerlendirme sekmesi aktif ise kontrol et
        if (APP_STATE.currentActiveTabId !== 'assessment') {
            return;
        }
        
        // Öğrenci verisi yoksa kontrol etme
        if (!APP_STATE.studentData || APP_STATE.studentData.length === 0) {
            return;
        }
        
        // Değerlendirme ağacı yoksa kontrol etme
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            return;
        }
        
        const currentHash = generateHashFromObject(createSimplifiedAssessmentTree());
        
        if (currentHash !== lastAssessmentTreeHash && lastAssessmentTreeHash !== '') {
            console.log("🔄 Değerlendirme yapısında değişiklik tespit edildi, tabloyu yeniden oluşturuyor...");
            lastAssessmentTreeHash = currentHash;
            
            // Kısa gecikme ile değerlendirme görünümünü güncelle
            setTimeout(() => {
                updateAssessmentView();
                showModernToast("📊 Değerlendirme tablosu değişiklikler nedeniyle yenilendi.", "info");
            }, 100);
        } else if (lastAssessmentTreeHash === '') {
            // İlk kez hash hesaplanıyor
            lastAssessmentTreeHash = currentHash;
        }
    } catch (error) {
        console.warn("Değerlendirme değişiklik kontrolünde hata:", error);
    }
}

/**
 * Manuel güncelleme tetikleme fonksiyonu (ağaç operasyonları sonrası çağrılacak)
 */
function triggerAssessmentTableRefresh(reason = "Manuel güncelleme") {
    try {
        console.log(`🔄 ${reason} - Değerlendirme tablosu yenileniyor...`);
        
        // Hash'i güncelle
        updateAssessmentTreeHash();
        
        // Değerlendirme görünümünü güncelle (eğer değerlendirme sekmesi aktifse)
        if (APP_STATE.currentActiveTabId === 'assessment' && APP_STATE.studentData && APP_STATE.studentData.length > 0) {
            updateAssessmentView();
        }
        
        // Kullanıcıya bilgi ver
        showModernToast(`📊 Değerlendirme tablosu güncellendi: ${reason}`, "success");
    } catch (error) {
        console.error("Manuel değerlendirme tablosu güncellemesinde hata:", error);
        showModernToast("❌ Değerlendirme tablosu güncellenirken hata oluştu!", "error");
    }
}

/**
 * Değerlendirme değişiklik takip sistemini durdur
 */
function stopAssessmentChangeTracking() {
    if (assessmentChangeTracker) {
        clearInterval(assessmentChangeTracker);
        assessmentChangeTracker = null;
        console.log('🛑 Değerlendirme değişiklik takip sistemi durduruldu');
    }
}

// Global erişim için fonksiyonları window'a ekle
window.initializeAssessmentChangeTracking = initializeAssessmentChangeTracking;
window.triggerAssessmentTableRefresh = triggerAssessmentTableRefresh;
window.stopAssessmentChangeTracking = stopAssessmentChangeTracking;
window.updateAssessmentTreeHash = updateAssessmentTreeHash;

// Sistem başlatıcısı
function initializeEnhancedAssessmentSystem() {
    console.log('🚀 Gelişmiş değerlendirme sistemi başlatılıyor...');
    
    // Değişiklik takip sistemini başlat
    initializeAssessmentChangeTracking();
    
    console.log('✅ Gelişmiş değerlendirme sistemi aktif!');
    console.log('📋 Özellikler:');
    console.log('   - Otomatik değerlendirme tablosu yenileme');
    console.log('   - Etkinlik adı, türü, ağırlığı değişiklik takibi');
    console.log('   - Soru/Rubrik ekleme/silme takibi');
    console.log('   - Grup haritalama değişiklik takibi');
    console.log('   - ÖÇ değişiklik takibi');
    console.log('   - Test detayları değişiklik takibi');
}

// Sayfa tamamen yüklendiğinde gelişmiş sistemi başlat
document.addEventListener('DOMContentLoaded', function() {
    // Kısa gecikme ile başlat (diğer sistemlerin yüklenmesini bekle)
    setTimeout(initializeEnhancedAssessmentSystem, 1000);
});

// Eğer sayfa zaten yüklü ise hemen başlat
if (document.readyState === 'complete') {
    setTimeout(initializeEnhancedAssessmentSystem, 500);
}

// Global test fonksiyonu
window.testAssessmentChangeSystem = function() {
    console.log('🧪 Değerlendirme değişiklik sistemi test ediliyor...');
    console.log('📊 Mevcut hash:', lastAssessmentTreeHash);
    console.log('🔄 Tracker aktif:', !!assessmentChangeTracker);
    console.log('📋 Assessment tree uzunluğu:', APP_STATE.assessmentTree ? APP_STATE.assessmentTree.length : 0);
    console.log('👥 Öğrenci sayısı:', APP_STATE.studentData ? APP_STATE.studentData.length : 0);
    console.log('🎯 Aktif sekme:', APP_STATE.currentActiveTabId);
    
    // Manuel tetikleme testi
    triggerAssessmentTableRefresh("Test amaçlı manuel tetikleme");
};

// =====================================================
// HIZLI VE BASİT GÜNCELLEME SİSTEMİ
// =====================================================

/**
 * Anında değerlendirme tablosu güncelleme
 */
function instantAssessmentRefresh(reason = "Değişiklik") {
    if (APP_STATE.currentActiveTabId === 'assessment' && 
        APP_STATE.studentData && 
        APP_STATE.studentData.length > 0 && 
        APP_STATE.assessmentTree && 
        APP_STATE.assessmentTree.length > 0) {
        
        console.log(`⚡ Anında güncelleme: ${reason}`);
        updateAssessmentView();
        return true;
    }
    return false;
}

/**
 * Tüm kritik DOM değişikliklerini yakala
 */
function attachInstantUpdateListeners() {
    // Tüm click event'leri
    document.addEventListener('click', function(e) {
        if (e.target.closest('#treeContainer')) {
            setTimeout(() => instantAssessmentRefresh("Tıklama işlemi"), 250);
        }
    });
    
    // Tüm form değişiklikleri
    document.addEventListener('change', function(e) {
        if (e.target.closest('#treeContainer')) {
            setTimeout(() => instantAssessmentRefresh("Form değişikliği"), 100);
        }
    });
    
    // Input yazma (debounced)
    let typingTimer;
    document.addEventListener('input', function(e) {
        if (e.target.closest('#treeContainer')) {
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => instantAssessmentRefresh("Metin girişi"), 400);
        }
    });
    
    console.log('✅ Anında güncelleme dinleyicileri aktif!');
}

// Global fonksiyon
window.forceAssessmentRefresh = function() {
    if (instantAssessmentRefresh("Manuel zorlama")) {
        showModernToast("🔄 Değerlendirme tablosu yenilendi!", "success");
    } else {
        showModernToast("⚠️ Değerlendirme sekmesi aktif değil veya veri eksik!", "warning");
    }
};

// Hemen başlat
if (document.readyState === 'complete') {
    setTimeout(attachInstantUpdateListeners, 300);
} else {
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(attachInstantUpdateListeners, 600);
    });
}

// GUID sistemi tamamen kaldırıldı


//Index.html den taşındı 
   // =====================================================
    // TAŞIMA BUTONLARI DÜZELTMESİ
    // =====================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            // renderNode fonksiyonunu genişlet
            if (typeof window.renderNode === 'function') {
                const originalRenderNode = window.renderNode;
                
                window.renderNode = function(node, parentElement, level) {
                    originalRenderNode(node, parentElement, level);
                    
                    // Alt öğeler için taşıma butonlarını ekle
                    const isSubItem = node.id.includes('.');
                    if (isSubItem) {
                        setTimeout(() => addMoveButtonsToNode(node.id), 50);
                    }
                };
            }
            
            // renderTree fonksiyonunu genişlet
            if (typeof window.renderTree === 'function') {
                const originalRenderTree = window.renderTree;
                
                window.renderTree = function() {
                    originalRenderTree();
                    setTimeout(() => {
                        addMoveButtonsToAllSubItems();
                    }, 100);
                };
            }
        }, 500);
    });
    
    /**
     * Düğüme taşıma butonları ekle
     */
    function addMoveButtonsToNode(nodeId) {
        const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
        if (!nodeElement) return;
        
        const buttonGroup = nodeElement.querySelector('.button-group');
        if (!buttonGroup) return;
        
        // Eğer taşıma butonları zaten varsa ekleme
        if (buttonGroup.querySelector('.btn-move-up')) return;
        
        // Taşıma butonlarını oluştur
        const moveUpBtn = document.createElement('button');
        moveUpBtn.className = 'btn btn-move-up btn-small';
        moveUpBtn.setAttribute('data-node-id', nodeId);
        moveUpBtn.title = 'Yukarı taşı';
        moveUpBtn.innerHTML = `
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
            ↑
        `;
        
        const moveDownBtn = document.createElement('button');
        moveDownBtn.className = 'btn btn-move-down btn-small';
        moveDownBtn.setAttribute('data-node-id', nodeId);
        moveDownBtn.title = 'Aşağı taşı';
        moveDownBtn.innerHTML = `
            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
            ↓
        `;
        
        // Event listener'ları ekle
        moveUpBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const node = findNodeById(nodeId);
            if (node && typeof moveItemUp === 'function') {
                moveItemUp(node);
            }
        });
        
        moveDownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const node = findNodeById(nodeId);
            if (node && typeof moveItemDown === 'function') {
                moveItemDown(node);
            }
        });
        
        // Butonları button-group'un başına ekle
        buttonGroup.insertBefore(moveUpBtn, buttonGroup.firstChild);
        buttonGroup.insertBefore(moveDownBtn, moveUpBtn.nextSibling);
    }
    
    /**
     * Tüm alt öğelere taşıma butonları ekle
     */
    function addMoveButtonsToAllSubItems() {
        if (typeof APP_STATE !== 'undefined' && APP_STATE.assessmentTree) {
            APP_STATE.assessmentTree.forEach(rootNode => {
                if (rootNode.children) {
                    rootNode.children.forEach(childNode => {
                        addMoveButtonsToNode(childNode.id);
                    });
                }
            });
        }
    }
    
    // Manuel test fonksiyonu
    window.testMoveButtons = function() {
        console.log('🧪 Taşıma butonları test ediliyor...');
        addMoveButtonsToAllSubItems();
        if (typeof showModernToast === 'function') {
            showModernToast('🔄 Taşıma butonları eklendi!', 'success');
        }
    };
    
    // Global fonksiyonları ekle
    window.addMoveButtonsToNode = addMoveButtonsToNode;
    window.addMoveButtonsToAllSubItems = addMoveButtonsToAllSubItems;


    // GUID sistemi tamamen kaldırıldı


        // =====================================================
    // SÜRÜKLE BIRAK SİSTEMİ
    // =====================================================
    
    let draggedNode = null;
    let draggedElement = null;
    
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            initializeDragAndDrop();
        }, 2500);
    });
    
    /**
     * Sürükle bırak sistemini başlat
     */
    function initializeDragAndDrop() {
        // Mevcut renderNode fonksiyonunu genişlet
        if (typeof window.renderNode === 'function') {
            const originalRenderNode = window.renderNode;
            
            window.renderNode = function(node, parentElement, level) {
                originalRenderNode(node, parentElement, level);
                
                // Alt öğeler için sürükle bırak özelliği ekle
                const isSubItem = node.id.includes('.');
                if (isSubItem) {
                    setTimeout(() => addDragAndDropToNode(node.id), 100);
                }
            };
        }
    }
    
    /**
     * Düğüme sürükle bırak özelliği ekle
     */
    function addDragAndDropToNode(nodeId) {
        const nodeElement = document.querySelector(`[data-id="${nodeId}"]`);
        if (!nodeElement) return;
        
        // Sürüklenebilir yap
        nodeElement.draggable = true;
        nodeElement.style.cursor = 'move';
        
        // Drag event'leri
        nodeElement.addEventListener('dragstart', handleDragStart);
        nodeElement.addEventListener('dragover', handleDragOver);
        nodeElement.addEventListener('drop', handleDrop);
        nodeElement.addEventListener('dragend', handleDragEnd);
        nodeElement.addEventListener('dragenter', handleDragEnter);
        nodeElement.addEventListener('dragleave', handleDragLeave);
        
        // Visual feedback için sınıf ekle
        nodeElement.classList.add('draggable-item');
    }
    
    /**
     * Sürükleme başladığında
     */
    function handleDragStart(e) {
        draggedElement = e.target.closest('.tree-node');
        const nodeId = draggedElement.dataset.id;
        draggedNode = findNodeById ? findNodeById(nodeId) : null;
        
        draggedElement.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', draggedElement.outerHTML);
        
        console.log('🔥 Sürükleme başladı:', nodeId);
    }
    
    /**
     * Sürükleme bittiğinde
     */
    function handleDragEnd(e) {
        if (draggedElement) {
            draggedElement.classList.remove('dragging');
        }
        
        // Tüm drop zone stillerini temizle
        document.querySelectorAll('.drop-zone').forEach(el => {
            el.classList.remove('drop-zone');
        });
        
        draggedNode = null;
        draggedElement = null;
    }
    
    /**
     * Sürüklenirken üzerine gelindiğinde
     */
    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }
    
    /**
     * Drop zone'a girildiğinde
     */
    function handleDragEnter(e) {
        const targetElement = e.target.closest('.tree-node');
        if (targetElement && targetElement !== draggedElement) {
            const targetNodeId = targetElement.dataset.id;
            const isSubItem = targetNodeId.includes('.');
            
            // Sadece aynı parent altındaki alt öğeler için drop zone yap
            if (isSubItem && draggedNode) {
                const draggedParentId = draggedNode.id.split('.')[0];
                const targetParentId = targetNodeId.split('.')[0];
                
                if (draggedParentId === targetParentId) {
                    targetElement.classList.add('drop-zone');
                }
            }
        }
    }
    
    /**
     * Drop zone'dan çıkıldığında
     */
    function handleDragLeave(e) {
        const targetElement = e.target.closest('.tree-node');
        if (targetElement) {
            targetElement.classList.remove('drop-zone');
        }
    }
    
    /**
     * Bırakıldığında
     */
    function handleDrop(e) {
        e.preventDefault();
        
        const targetElement = e.target.closest('.tree-node');
        if (!targetElement || !draggedNode || targetElement === draggedElement) return;
        
        const targetNodeId = targetElement.dataset.id;
        const targetNode = findNodeById ? findNodeById(targetNodeId) : null;
        
        if (!targetNode) return;
        
        // Aynı parent altında mı kontrol et
        const draggedParentId = draggedNode.id.split('.')[0];
        const targetParentId = targetNode.id.split('.')[0];
        
        if (draggedParentId !== targetParentId) {
            showModernToast('Sadece aynı bileşen içindeki sorular taşınabilir!', 'warning');
            return;
        }
        
        // Parent node'u bul
        const parentNode = findParentNode ? findParentNode(draggedNode.id) : null;
        if (!parentNode) return;
        
        // Mevcut pozisyonları bul
        const draggedIndex = parentNode.children.findIndex(child => child.id === draggedNode.id);
        const targetIndex = parentNode.children.findIndex(child => child.id === targetNode.id);
        
        if (draggedIndex === -1 || targetIndex === -1) return;
        
        // Öğeleri yeniden sırala
        const [movedItem] = parentNode.children.splice(draggedIndex, 1);
        parentNode.children.splice(targetIndex, 0, movedItem);
        
        // ID'leri yeniden düzenle
        if (typeof reorderAllIds === 'function') {
            reorderAllIds(parentNode);
        }
        
        // Görünümü güncelle
        if (typeof renderTree === 'function') {
            renderTree();
        }
        
        if (typeof updateAssessmentView === 'function') {
            updateAssessmentView();
        }
        
        showModernToast(`"${draggedNode.name}" başarıyla taşındı!`, 'success');
        
        console.log('✅ Sürükle bırak tamamlandı:', draggedNode.id, '->', targetNode.id);
    }
    
    // Global fonksiyonlar
    window.initializeDragAndDrop = initializeDragAndDrop;
    window.addDragAndDropToNode = addDragAndDropToNode;
    
    // CSS stilleri ekle
    const dragDropStyles = document.createElement('style');
    dragDropStyles.textContent = `
        .draggable-item {
            transition: all 0.2s ease;
        }
        
        .dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .drop-zone {
            border: 2px dashed #3498db !important;
            background-color: rgba(52, 152, 219, 0.1) !important;
            transform: scale(1.02);
        }
        
        .tree-node[draggable="true"]:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .tree-node[draggable="true"]::before {
            content: "⋮⋮";
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #bdc3c7;
            font-weight: bold;
            font-size: 12px;
            line-height: 1;
        }
    `;
    document.head.appendChild(dragDropStyles);

    
    // GUID sistemi tamamen kaldırıldı


    // =====================================================
    // ID SİSTEMİ DÜZELTMESİ
    // =====================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            // addQuestionToNode fonksiyonunu genişlet
            if (typeof window.addQuestionToNode === 'function') {
                const originalAddQuestionToNode = window.addQuestionToNode;
                
                window.addQuestionToNode = function(parentNode, questionType = 'Soru', description = '') {
                    if (!parentNode) return;
                    
                    try {
                        if (!parentNode.children) {
                            parentNode.children = [];
                        }
                        
                        // YENİ: Sıralı ID üretimi kullan
                        const newId = generateSequentialId ? generateSequentialId(parentNode) : `${parentNode.id}.${parentNode.children.length + 1}`;
                        
                        // Öğrenme çıktıları varsa ilk öğrenme çıktısını atayalım
                        const outcome = parentNode.outcomes && parentNode.outcomes.length > 0 ? [parentNode.outcomes[0]] : [];
                        
                        // Varsayılan puanı 3 olarak ayarla
                        const defaultPoints = 3;
                        
                        const newNode = {
                            id: newId,
                            name: `${questionType}`,
                            type: questionType,
                            weight: 0, // Ağırlık otomatik hesaplanacak
                            points: defaultPoints,
                            outcomes: outcome,
                            description: description || 'Değerlendirme sorusu',
                            expanded: true,
                            children: []
                        };
                        
                        parentNode.children.push(newNode);
                        parentNode.expanded = true;
                        
                        // YENİ: ID'leri yeniden düzenle
                        if (typeof reorderAllIds === 'function') {
                            reorderAllIds(parentNode);
                        }
                        
                        // Ağırlığı hesapla
                        if (typeof updateSubItemWeight === 'function') {
                            updateSubItemWeight(newNode);
                        }
                        
                        if (typeof selectNode === 'function') {
                            selectNode(newNode);
                        }
                        
                        if (typeof renderTree === 'function') {
                            renderTree();
                        }
                        
                        // Değerlendirme sekmesini güncelle
                        if (typeof updateAssessmentView === 'function') {
                            updateAssessmentView();
                        }
                        
                        if (typeof showModernToast === 'function') {
                            showModernToast(`"${questionType}" sorusu eklendi.`);
                        }
                        
                        // Ağırlıkları yeniden değerlendir
                        if (typeof checkAndOfferRedistribution === 'function') {
                            checkAndOfferRedistribution(parentNode);
                        }
                        
                    } catch (error) {
                        console.error("Soru eklenirken hata oluştu:", error);
                        if (typeof showModernToast === 'function') {
                            showModernToast("Soru eklenemedi!", "error");
                        }
                    }
                };
            }
            
            // deleteNode fonksiyonunu genişlet
            if (typeof window.deleteNode === 'function') {
                const originalDeleteNode = window.deleteNode;
                
                window.deleteNode = function(nodeId) {
                    // Orijinal fonksiyonu çağır
                    originalDeleteNode(nodeId);
                    
                    // ID'leri yeniden düzenle
                    setTimeout(() => {
                        if (!nodeId.includes('.')) return; // Sadece alt öğeler için
                        
                        const parentId = nodeId.substring(0, nodeId.lastIndexOf('.'));
                        const parentNode = findNodeById ? findNodeById(parentId) : null;
                        
                        if (parentNode && typeof reorderAllIds === 'function') {
                            reorderAllIds(parentNode);
                            
                            if (typeof renderTree === 'function') {
                                renderTree();
                            }
                            
                            if (typeof updateAssessmentView === 'function') {
                                updateAssessmentView();
                            }
                        }
                    }, 100);
                };
            }
        }, 1000);
    });

    // =====================================================
    // VERİ KORUMA SİSTEMİ - ÖĞRENCİ NOTLARI
    // =====================================================
    
    /**
     * Öğrenci notlarında ID değişikliklerini migrasyon et
     * @param {Object} idMigrationMap - ID değişiklik haritası (eskiID -> yeniID)
     */
    function migrateGradesData(idMigrationMap) {
        if (!APP_STATE.gradesData || Object.keys(idMigrationMap).length === 0) return;
        
        console.log('🔄 Öğrenci notları migrasyon başlatılıyor...', idMigrationMap);
        
        // Her öğrenci için
        Object.keys(APP_STATE.gradesData).forEach(studentId => {
            const studentGrades = APP_STATE.gradesData[studentId];
            if (!studentGrades || typeof studentGrades !== 'object') return;
            
            // Migrasyon edilecek notları sakla
            const notesToMigrate = {};
            
            // Migrasyon haritasındaki her ID değişikliği için
            Object.entries(idMigrationMap).forEach(([oldId, newId]) => {
                // Direkt not kontrolü
                if (studentGrades.hasOwnProperty(oldId)) {
                    notesToMigrate[newId] = studentGrades[oldId];
                    delete studentGrades[oldId];
                    console.log(`✅ Öğrenci ${studentId}: ${oldId} -> ${newId} (Değer: ${notesToMigrate[newId]})`);
                }
                
                // Ham puanlar migrasyon
                if (studentGrades.hamPuanlar) {
                    const oldQuestionNum = oldId.split('.').pop();
                    const newQuestionNum = newId.split('.').pop();
                    
                    if (studentGrades.hamPuanlar.hasOwnProperty(oldQuestionNum)) {
                        studentGrades.hamPuanlar[newQuestionNum] = studentGrades.hamPuanlar[oldQuestionNum];
                        delete studentGrades.hamPuanlar[oldQuestionNum];
                        console.log(`✅ Ham puan migrasyon: ${oldQuestionNum} -> ${newQuestionNum}`);
                    }
                }
                
                // Grup bazlı notlar migrasyon
                if (studentGrades.grupBazliNotlar) {
                    Object.keys(studentGrades.grupBazliNotlar).forEach(groupName => {
                        const groupGrades = studentGrades.grupBazliNotlar[groupName];
                        if (groupGrades.hasOwnProperty(oldId)) {
                            groupGrades[newId] = groupGrades[oldId];
                            delete groupGrades[oldId];
                            console.log(`✅ Grup bazlı not migrasyon: Grup ${groupName}, ${oldId} -> ${newId}`);
                        }
                    });
                }
                
                // Üst düğüm yapısı migrasyon
                const oldParentId = oldId.split('.')[0];
                const newParentId = newId.split('.')[0];
                
                if (studentGrades[oldParentId] && typeof studentGrades[oldParentId] === 'object' && oldParentId === newParentId) {
                    const parentGrades = studentGrades[oldParentId];
                    if (parentGrades.hasOwnProperty(oldId)) {
                        parentGrades[newId] = parentGrades[oldId];
                        delete parentGrades[oldId];
                        
                        // Kısa ID de güncelle
                        const oldShortId = oldId.split('.').pop();
                        const newShortId = newId.split('.').pop();
                        if (parentGrades.hasOwnProperty(oldShortId)) {
                            parentGrades[newShortId] = parentGrades[oldShortId];
                            delete parentGrades[oldShortId];
                        }
                        
                        console.log(`✅ Parent yapısı migrasyon: ${oldParentId}[${oldId}] -> ${newParentId}[${newId}]`);
                    }
                }
            });
            
            // Yeni notları ekle
            Object.entries(notesToMigrate).forEach(([newId, value]) => {
                studentGrades[newId] = value;
            });
        });
        
        console.log('✅ Öğrenci notları migrasyon tamamlandı!');
        showModernToast(`📊 ${Object.keys(idMigrationMap).length} soru/rubrik ID'si değiştirildi, notlar korundu!`, "success");
    }
    
    /**
     * reorderAllIds fonksiyonunu veri koruma ile genişlet
     */
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            if (typeof window.reorderAllIds === 'function') {
                const originalReorderAllIds = window.reorderAllIds;
                
                window.reorderAllIds = function(parentNode) {
                    if (!parentNode || !parentNode.children) return;
                    
                    // ID değişiklik haritası
                    const idMigrationMap = {};
                    
                    parentNode.children.forEach((child, index) => {
                        const oldId = child.id;
                        const newId = `${parentNode.id}.${index + 1}`;
                        
                        if (oldId !== newId) {
                            idMigrationMap[oldId] = newId;
                        }
                    });
                    
                    // Orijinal fonksiyonu çağır
                    originalReorderAllIds(parentNode);
                    
                    // Öğrenci notlarını migrasyon et
                    if (Object.keys(idMigrationMap).length > 0) {
                        migrateGradesData(idMigrationMap);
                    }
                };
            }
        }, 1500);
    });
    
    /**
     * deleteNode fonksiyonunu veri koruma uyarısı ilegenişlet
     */
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            if (typeof window.deleteNode === 'function') {
                const originalDeleteNode = window.deleteNode;
                
                window.deleteNode = function(nodeId) {
                    if (!nodeId) return;
                    
                    // Öğrenci notları var mı kontrol et
                    const hasGrades = checkIfNodeHasGrades(nodeId);
                    
                    if (hasGrades) {
                        // Ekstra uyarı ver
                        showModernConfirm(
                            "⚠️ DİKKAT! Notlı Soru/Rubrik Silme",
                            "Bu soru/rubrik için öğrenci notları girilmiş.\n\nSilme işlemi yapılırsa:\n• Bu soruya ait notlar kalıcı olarak silinecek\n• Diğer soruların notları korunacak\n• ID'ler yeniden düzenlenecek\n\nDevam etmek istediğinizden emin misiniz?",
                            function() {
                                // Orijinal fonksiyonu çağır
                                originalDeleteNode(nodeId);
                            }
                        );
                        return;
                    }
                    
                    // Orijinal fonksiyonu çağır
                    originalDeleteNode(nodeId);
                };
            }
        }, 1500);
    });
    
    /**
     * Düğümün not verisi olup olmadığını kontrol et
     */
    function checkIfNodeHasGrades(nodeId) {
        if (!APP_STATE.gradesData) return false;
        
        return Object.keys(APP_STATE.gradesData).some(studentId => {
            const studentGrades = APP_STATE.gradesData[studentId];
            if (!studentGrades) return false;
            
            // Direkt not kontrolü
            if (studentGrades.hasOwnProperty(nodeId)) return true;
            
            // Ham puanlar kontrolü
            if (studentGrades.hamPuanlar) {
                const questionNum = nodeId.split('.').pop();
                if (studentGrades.hamPuanlar.hasOwnProperty(questionNum)) return true;
            }
            
            // Grup bazlı notlar kontrolü
            if (studentGrades.grupBazliNotlar) {
                return Object.values(studentGrades.grupBazliNotlar).some(groupGrades => 
                    groupGrades.hasOwnProperty(nodeId)
                );
            }
            
            return false;
        });
    }
    
    // Global fonksiyonlar
    window.migrateGradesData = migrateGradesData;
    window.checkIfNodeHasGrades = checkIfNodeHasGrades;
    
    // Test fonksiyonu
    window.testGradeMigration = function() {
        console.log('🧪 Not migrasyon sistemi test ediliyor...');
        const testMap = {'A1.2': 'A1.3', 'A1.3': 'A1.4'};
        migrateGradesData(testMap);
    };

    // =====================================================
    // GRUP HARİTALAMA HATA DÜZELTMESİ
    // =====================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            if (typeof window.updateGroupMappingForId === 'function') {
                const originalUpdateGroupMappingForId = window.updateGroupMappingForId;
                
                window.updateGroupMappingForId = function(oldId, newId) {
                    if (!APP_STATE.courseData || !APP_STATE.courseData.grupHaritalari) return;
                    
                    Object.keys(APP_STATE.courseData.grupHaritalari).forEach(groupName => {
                        const activities = APP_STATE.courseData.grupHaritalari[groupName];
                        
                        Object.keys(activities).forEach(activityId => {
                            const questionList = activities[activityId];
                            
                            // DÜZELTME: questionList'in array olup olmadığını kontrol et
                            if (Array.isArray(questionList)) {
                                const index = questionList.indexOf(oldId);
                                if (index !== -1) {
                                    questionList[index] = newId;
                                }
                            } else {
                                console.warn(`Grup haritalama problemi: ${groupName}.${activityId} array değil:`, questionList);
                            }
                        });
                    });
                };
            }
        }, 2000);
    });

// =====================================================
// YENİ GRUP YÖNETİMİ SİSTEMİ
// =====================================================

/**
 * Bir etkinlik için grup haritalama bilgisi oluştur
 * @param {string} activityId - Etkinlik ID'si
 * @returns {Object} - Grup haritalama bilgisi
 */
function createGroupMappingForActivity(activityId) {
    const activity = APP_STATE.assessmentTree.find(node => node.id === activityId);
    if (!activity || !activity.children) {
        return {
            gruplar: ["A"],
            haritalar: {
                "A": {}
            }
        };
    }
    
    // Mevcut grup haritalama bilgisini al
    const existingMapping = APP_STATE.courseData?.grupHaritalari?.[activityId];
    
    if (existingMapping) {
        return existingMapping;
    }
    
    // Default haritalama oluştur - her etkinlik en az A grubu var
    const mappings = {
        "A": {}
    };
    
    // Tüm soruları A grubunda sırayla ekle
    activity.children.forEach((child, index) => {
        mappings.A[(index + 1).toString()] = child.id;
    });
    
    return {
        gruplar: ["A"],
        haritalar: mappings
    };
}

/**
 * Değerlendirme verilerinden grup haritalama bilgilerini yükle
 * @param {Object} jsonData - JSON verisi
 */
function loadGroupMappingsFromAssessmentData(jsonData) {
    console.log("🚀 === loadGroupMappingsFromAssessmentData BAŞLADI ===");
    console.log("📄 Fonksiyon çağrıldı, parametre tipi:", typeof jsonData);
    console.log("📄 JSON data var mı:", !!jsonData);
    
    try {
        console.log("🔍 loadGroupMappingsFromAssessmentData başlatıldı...");
        console.log("📄 Gelen JSON data keys:", Object.keys(jsonData));
        
        if (!APP_STATE.courseData) APP_STATE.courseData = {};
        if (!APP_STATE.courseData.grupHaritalari) APP_STATE.courseData.grupHaritalari = {};
        
        // v5 format için özel işlem - dersDegerlendirme içindeki etkinlikleri kontrol et
        const dersDegerlendirme = jsonData.dersDegerlendirme;
        console.log("📊 dersDegerlendirme var mı:", !!dersDegerlendirme);
        
        if (dersDegerlendirme) {
            // Yarıyıl içi etkinlikler
            if (dersDegerlendirme.yariyilIciEtkinlikleri) {
                console.log("🔍 Yarıyıl içi etkinlikler bulundu:", dersDegerlendirme.yariyilIciEtkinlikleri.length);
                dersDegerlendirme.yariyilIciEtkinlikleri.forEach(activity => {
                    console.log(`🔍 Etkinlik kontrol ediliyor: ${activity.id}`, activity);
                    if (activity.grupBilgileri) {
                        APP_STATE.courseData.grupHaritalari[activity.id] = activity.grupBilgileri;
                        console.log(`✅ Grup bilgileri yüklendi: ${activity.id}`, activity.grupBilgileri);
                    } else {
                        console.log(`⚠️ ${activity.id} için grup bilgisi bulunamadı`);
                    }
                });
            } else {
                console.log("⚠️ Yarıyıl içi etkinlikler bulunamadı");
            }
            
            // Yarıyıl sonu etkinlikler
            if (dersDegerlendirme.yariyilSonuEtkinlikleri) {
                console.log("🔍 Yarıyıl sonu etkinlikler bulundu:", dersDegerlendirme.yariyilSonuEtkinlikleri.length);
                dersDegerlendirme.yariyilSonuEtkinlikleri.forEach(activity => {
                    console.log(`🔍 Etkinlik kontrol ediliyor: ${activity.id}`, activity);
                    if (activity.grupBilgileri) {
                        APP_STATE.courseData.grupHaritalari[activity.id] = activity.grupBilgileri;
                        console.log(`✅ Grup bilgileri yüklendi: ${activity.id}`, activity.grupBilgileri);
                    } else {
                        console.log(`⚠️ ${activity.id} için grup bilgisi bulunamadı`);
                    }
                });
            } else {
                console.log("⚠️ Yarıyıl sonu etkinlikler bulunamadı");
            }
        }
        
        // SADECE öğrenci grup bilgilerini yükle - mapping bilgilerini etkinlik verilerinden al
        if (jsonData.ogrenciNotlari) {
            console.log("🔍 Öğrenci grup bilgileri yükleniyor...");
            
            // Öğrenci grup bilgilerini yükle
            Object.keys(jsonData.ogrenciNotlari).forEach(studentId => {
                const studentGrades = jsonData.ogrenciNotlari[studentId];
                if (studentGrades.grupBilgileri) {
                    // v5 formatında grup bilgilerini studentComponentGroups'a yükle
                    if (!APP_STATE.studentComponentGroups) APP_STATE.studentComponentGroups = {};
                    if (!APP_STATE.studentComponentGroups[studentId]) APP_STATE.studentComponentGroups[studentId] = {};
                    
                    Object.keys(studentGrades.grupBilgileri).forEach(activityId => {
                        APP_STATE.studentComponentGroups[studentId][activityId] = studentGrades.grupBilgileri[activityId];
                    });
                    console.log(`✅ Öğrenci grup bilgileri yüklendi: ${studentId}`, studentGrades.grupBilgileri);
                }
            });
        }
        
        console.log("🎯 Tüm grup haritalama bilgileri yüklendi:", APP_STATE.courseData.grupHaritalari);
        console.log("👥 Öğrenci grup atamaları (v5 format):", APP_STATE.studentComponentGroups);
        
        // Debug: Her bileşen için grup bilgilerini detaylı yazdır
        Object.keys(APP_STATE.courseData.grupHaritalari || {}).forEach(componentId => {
            const component = APP_STATE.courseData.grupHaritalari[componentId];
            console.log(`📊 ${componentId} grup detayları:`, {
                gruplar: component.gruplar,
                haritalar: component.haritalar,
                mappingCount: Object.keys(component.haritalar || {}).length
            });
        });
        
        console.log("✅ loadGroupMappingsFromAssessmentData tamamlandı");
    } catch (error) {
        console.error("❌ Grup haritalama bilgileri yüklenirken hata oluştu:", error);
    }
}

/**
 * Öğrenci notlarını yeni yapıya göre yükle - v5 formatını tam destekler
 * @param {Object} jsonData - JSON verisi
 */
function loadStudentGradesNewFormat(jsonData) {
    try {
        if (!jsonData.ogrenciNotlari) return;
        
        // Not verilerini temizle
        APP_STATE.gradesData = {};
        
        Object.keys(jsonData.ogrenciNotlari).forEach(studentId => {
            const studentGrades = jsonData.ogrenciNotlari[studentId];
            
            if (!APP_STATE.gradesData[studentId]) {
                APP_STATE.gradesData[studentId] = {};
            }
            
            // Her etkinlik için notları yükle
            Object.keys(studentGrades).forEach(activityId => {
                if (activityId === 'grupBilgileri') return; // Grup bilgilerini atla
                
                const activityGrades = studentGrades[activityId];
                if (typeof activityGrades === 'object') {
                    // v5 Format: Pozisyon bazlı notlar (1, 2, 3, 4, 5...)
                    // Hem pozisyon bilgisini hem de soru ID bilgisini koru
                    APP_STATE.gradesData[studentId][activityId] = {};
                    
                    Object.keys(activityGrades).forEach(questionOrder => {
                        const gradeInfo = activityGrades[questionOrder];
                        if (gradeInfo && typeof gradeInfo === 'object' && gradeInfo.soruId && gradeInfo.puan !== undefined) {
                            // v5 Format: Pozisyon bazlı yapıyı koru
                            APP_STATE.gradesData[studentId][activityId][questionOrder] = {
                                puan: gradeInfo.puan,
                                soruId: gradeInfo.soruId
                            };
                            
                            // Geriye uyumluluk için soru ID'si ile de kaydet
                            APP_STATE.gradesData[studentId][gradeInfo.soruId] = gradeInfo.puan;
                        }
                    });
                }
            });
            
            // Grup bilgilerini v5 formatından yükle
            if (studentGrades.grupBilgileri) {
                // v5 formatında grup bilgilerini studentComponentGroups'a yükle
                if (!APP_STATE.studentComponentGroups) APP_STATE.studentComponentGroups = {};
                if (!APP_STATE.studentComponentGroups[studentId]) APP_STATE.studentComponentGroups[studentId] = {};
                
                Object.keys(studentGrades.grupBilgileri).forEach(activityId => {
                    APP_STATE.studentComponentGroups[studentId][activityId] = studentGrades.grupBilgileri[activityId];
                });
                
                // Ayrıca gradesData'ya da kaydet (v5 format uyumluluğu için)
                APP_STATE.gradesData[studentId].grupBilgileri = studentGrades.grupBilgileri;
            }
        });
        
                        console.log("✅ Öğrenci notları Tam Dosya formatında tam olarak yüklendi");
        console.log("📊 Yüklenen öğrenci sayısı:", Object.keys(APP_STATE.gradesData).length);
    } catch (error) {
        console.error("Öğrenci notları yüklenirken hata oluştu:", error);
    }
}

/**
 * Tam dosya formatında yarıyıl içi etkinlik oluşturma fonksiyonu
 */
function generateTamDosyaTermAssessmentWithParams(activityCount, componentCount, activityType) {
    try {
        showModernToast(`📚 Tam dosya formatında ${activityCount} yarıyıl içi etkinlik oluşturuluyor...`, 'info', 3000);
        
        // Tam dosya formatına uygun etkinlik türleri
        const activityTypes = [
            'Ara Sınav', 'Quiz', 'Ev Ödevi', 'Proje Hazırlama', 'Laboratuvar', 'Proje Sunma', 
            'Rapor', 'Deney', 'Performans', 'Makale Kritik Etme', 'Seminer', 'Sözlü Sınav'
        ];
        
        // Tam dosya formatına uygun öğrenme çıktıları
        const learningOutcomes = ['ÖÇ.1', 'ÖÇ.2', 'ÖÇ.3', 'ÖÇ.4', 'ÖÇ.5', 'ÖÇ.6', 'ÖÇ.7'];
        
        // Yeni V5 formatında etkinlikler oluştur
        const newActivities = [];
        let totalWeight = 0;
        
        // Mevcut A etkinlik sayısını bul
        const existingTermActivities = APP_STATE.courseData?.dersDegerlendirme?.yariyilIciEtkinlikleri || [];
        let startIndex = existingTermActivities.length + 1;
        
        for (let i = 0; i < activityCount; i++) {
            const selectedType = activityType === 'random' ? 
                activityTypes[Math.floor(Math.random() * activityTypes.length)] : 
                activityType;
            
            const weight = Math.floor(Math.random() * 30) + 15; // 15-45 arası ağırlık
            totalWeight += weight;
            
            // V5 formatında soru/rubrik detayları oluştur
            const details = [];
            const componentWeight = Math.floor(100 / componentCount);
            
            for (let j = 1; j <= componentCount; j++) {
                const isRubric = Math.random() > 0.6; // %40 rubrik, %60 soru
                details.push({
                    id: `A${startIndex + i}.${j}`,
                    isim: isRubric ? `Rubrik ${j}` : `Soru ${j}`,
                    tip: isRubric ? 'Rubrik' : 'Soru',
                    agirlik: componentWeight,
                    puan: Math.floor(Math.random() * 20) + 10, // 10-30 puan arası
                    ogrenmeÇiktilari: [learningOutcomes[Math.floor(Math.random() * learningOutcomes.length)]],
                    aciklama: isRubric ? 
                        `Rubrik değerlendirme kriteri` : 
                        `Değerlendirme sorusu`
                });
            }
            
            // V5 formatında grup bilgileri oluştur (A ve B grupları)
            const groupMappings = {
                "A": {},
                "B": {}
            };
            
            // A grubu için sıralı mapping
            for (let pos = 1; pos <= componentCount; pos++) {
                groupMappings.A[pos.toString()] = `A${startIndex + i}.${pos}`;
            }
            
            // B grubu için karışık mapping
            const shuffledPositions = Array.from({length: componentCount}, (_, idx) => idx + 1);
            for (let k = shuffledPositions.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [shuffledPositions[k], shuffledPositions[j]] = [shuffledPositions[j], shuffledPositions[k]];
            }
            
            for (let pos = 1; pos <= componentCount; pos++) {
                groupMappings.B[pos.toString()] = `A${startIndex + i}.${shuffledPositions[pos - 1]}`;
            }
            
            // V5 formatında etkinlik oluştur
            newActivities.push({
                id: `A${startIndex + i}`,
                etkinlik: selectedType,
                sayi: 1,
                katkiYuzdesi: weight,
                detaylar: details,
                grupBilgileri: {
                    gruplar: ["A", "B"],
                    haritalar: groupMappings
                }
            });
        }
        
        // Ağırlıkları normalize et (toplam 100 olacak şekilde)
        if (totalWeight > 0) {
            const normalizationFactor = 100 / totalWeight;
            newActivities.forEach(activity => {
                activity.katkiYuzdesi = Math.round(activity.katkiYuzdesi * normalizationFactor);
            });
        }
        
        // V5 formatında APP_STATE'i güncelle
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = { 
                dersDegerlendirme: { 
                    yariyilIciEtkinlikleri: [],
                    yariyilSonuEtkinlikleri: []
                },
                ogrenciNotlari: {}
            };
        }
        if (!APP_STATE.courseData.dersDegerlendirme) {
            APP_STATE.courseData.dersDegerlendirme = { 
                yariyilIciEtkinlikleri: [],
                yariyilSonuEtkinlikleri: []
            };
        }
        if (!APP_STATE.courseData.dersDegerlendirme.yariyilIciEtkinlikleri) {
            APP_STATE.courseData.dersDegerlendirme.yariyilIciEtkinlikleri = [];
        }
        
        // Mevcut etkinliklere V5 formatında ekle
        APP_STATE.courseData.dersDegerlendirme.yariyilIciEtkinlikleri.push(...newActivities);
        
        // courseData referansını güncelle
        if (typeof courseData !== 'undefined') {
            courseData = APP_STATE.courseData;
        }
        
        // courseData'dan assessmentTree'ye dönüştür
        convertCourseDataToAssessmentTree();
        
        // UI güncellemeleri
        updateAssessmentView();
        renderTree();
        updateCategoryWeights();
        updateAssessmentView();
        
        const summary = `✅ Tam Dosya formatında ${activityCount} yarıyıl içi etkinlik oluşturuldu!\n` +
                       `📝 Her etkinlikte ${componentCount} soru/rubrik\n` +
                       `🎯 Etkinlik türü: ${activityType}\n` +
                       `🎲 A ve B grupları otomatik oluşturuldu\n` +
                       `⚖️ Ağırlıklar otomatik normalize edildi`;
        
        console.log('✅ Tam Dosya formatında yarıyıl içi etkinlik oluşturma tamamlandı');
        showModernToast(summary, 'success', 5000);
        
    } catch (error) {
        console.error('❌ Tam Dosya yarıyıl içi etkinlik oluşturulurken hata:', error);
        showModernToast('Tam Dosya yarıyıl içi etkinlik oluşturulamadı!', 'error');
    }
}

/**
 * courseData'dan assessmentTree'ye dönüştürme fonksiyonu
 */
function convertCourseDataToAssessmentTree() {
    try {
        console.log('🔄 courseData assessmentTree\'ye dönüştürülüyor...');
        
        if (!APP_STATE.courseData?.dersDegerlendirme) {
            console.warn('⚠️ courseData.dersDegerlendirme bulunamadı');
            return;
        }
        
        const newAssessmentTree = [];
        
        // Yarıyıl içi etkinlikleri dönüştür
        const termActivities = APP_STATE.courseData.dersDegerlendirme.yariyilIciEtkinlikleri || [];
        termActivities.forEach(activity => {
            const treeNode = {
                id: activity.id,
                name: activity.etkinlik,
                type: activity.etkinlik,
                weight: activity.katkiYuzdesi,
                points: 100, // Varsayılan
                outcomes: [], // Çocukların outcomes'larından al
                description: `${activity.etkinlik} (${activity.sayi} adet)`,
                expanded: true,
                children: []
            };
            
            // Alt detayları ekle
            if (activity.detaylar) {
                activity.detaylar.forEach(detail => {
                    treeNode.children.push({
                        id: detail.id,
                        name: detail.isim,
                        type: detail.tip,
                        weight: detail.agirlik,
                        points: detail.puan,
                        outcomes: detail.ogrenmeÇiktilari || [],
                        description: detail.aciklama || '',
                        expanded: false,
                        children: []
                    });
                });
                
                // Outcomes'ları çocuklardan topla
                treeNode.outcomes = [...new Set(
                    treeNode.children.flatMap(child => child.outcomes || [])
                )];
            }
            
            newAssessmentTree.push(treeNode);
        });
        
        // Yarıyıl sonu etkinlikleri dönüştür
        const finalActivities = APP_STATE.courseData.dersDegerlendirme.yariyilSonuEtkinlikleri || [];
        finalActivities.forEach(activity => {
            const treeNode = {
                id: activity.id,
                name: activity.etkinlik,
                type: activity.etkinlik,
                weight: activity.katkiYuzdesi,
                points: 100, // Varsayılan
                outcomes: [], // Çocukların outcomes'larından al
                description: `${activity.etkinlik} (${activity.sayi} adet)`,
                expanded: true,
                children: []
            };
            
            // Alt detayları ekle
            if (activity.detaylar) {
                activity.detaylar.forEach(detail => {
                    treeNode.children.push({
                        id: detail.id,
                        name: detail.isim,
                        type: detail.tip,
                        weight: detail.agirlik,
                        points: detail.puan,
                        outcomes: detail.ogrenmeÇiktilari || [],
                        description: detail.aciklama || '',
                        expanded: false,
                        children: []
                    });
                });
                
                // Outcomes'ları çocuklardan topla
                treeNode.outcomes = [...new Set(
                    treeNode.children.flatMap(child => child.outcomes || [])
                )];
            }
            
            newAssessmentTree.push(treeNode);
        });
        
        // APP_STATE.assessmentTree'yi güncelle
        APP_STATE.assessmentTree = newAssessmentTree;
        
        console.log('✅ courseData başarıyla assessmentTree\'ye dönüştürüldü:', newAssessmentTree.length, 'etkinlik');
        
    } catch (error) {
        console.error('❌ courseData assessmentTree\'ye dönüştürülürken hata:', error);
        showModernToast('Veri dönüştürme hatası!', 'error');
    }
}

/**
 * Tam dosya formatında yarıyıl sonu etkinlik oluşturma fonksiyonu
 */
function generateTamDosyaFinalAssessmentWithParams(activityCount, componentCount, activityType) {
    try {
        showModernToast(`🎯 Tam dosya formatında ${activityCount} yarıyıl sonu etkinlik oluşturuluyor...`, 'info', 3000);
        
        // Tam dosya formatına uygun yarıyıl sonu etkinlik türleri
        const finalActivityTypes = [
            'Final Sınavı', 'Laboratuvar Ara Sınavı', 'Makale Yazma', 'Proje Hazırlama', 
            'Proje Sunma', 'Proje Tasarımı/Yönetimi', 'Quiz', 'Rapor', 'Rapor Hazırlama', 
            'Rapor Sunma', 'Seminer', 'Sözlü Sınav', 'Gözlem'
        ];
        
        // Tam dosya formatına uygun öğrenme çıktıları
        const learningOutcomes = ['ÖÇ.1', 'ÖÇ.2', 'ÖÇ.3', 'ÖÇ.4', 'ÖÇ.5', 'ÖÇ.6', 'ÖÇ.7'];
        
        // Yeni V5 formatında etkinlikler oluştur
        const newActivities = [];
        let totalWeight = 0;
        
        // Mevcut F etkinlik sayısını bul
        const existingFinalActivities = APP_STATE.courseData?.dersDegerlendirme?.yariyilSonuEtkinlikleri || [];
        let startIndex = existingFinalActivities.length + 1;
        
        for (let i = 0; i < activityCount; i++) {
            const selectedType = activityType === 'random' ? 
                finalActivityTypes[Math.floor(Math.random() * finalActivityTypes.length)] : 
                activityType;
            
            const weight = Math.floor(Math.random() * 40) + 40; // 40-80 arası ağırlık (final için)
            totalWeight += weight;
            
            // V5 formatında soru/rubrik detayları oluştur
            const details = [];
            const componentWeight = Math.floor(100 / componentCount);
            
            for (let j = 1; j <= componentCount; j++) {
                const isRubric = Math.random() > 0.7; // %30 rubrik, %70 soru (final için)
                details.push({
                    id: `F${startIndex + i}.${j}`,
                    isim: isRubric ? `Rubrik ${j}` : `Soru ${j}`,
                    tip: isRubric ? 'Rubrik' : 'Soru',
                    agirlik: componentWeight,
                    puan: Math.floor(Math.random() * 25) + 15, // 15-40 puan arası (final için)
                    ogrenmeÇiktilari: [learningOutcomes[Math.floor(Math.random() * learningOutcomes.length)]],
                    aciklama: isRubric ? 
                        `Final rubrik değerlendirme kriteri` : 
                        `Final değerlendirme sorusu`
                });
            }
            
            // V5 formatında grup bilgileri oluştur (A ve B grupları)
            const groupMappings = {
                "A": {},
                "B": {}
            };
            
            // A grubu için sıralı mapping
            for (let pos = 1; pos <= componentCount; pos++) {
                groupMappings.A[pos.toString()] = `F${startIndex + i}.${pos}`;
            }
            
            // B grubu için karışık mapping
            const shuffledPositions = Array.from({length: componentCount}, (_, idx) => idx + 1);
            for (let k = shuffledPositions.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [shuffledPositions[k], shuffledPositions[j]] = [shuffledPositions[j], shuffledPositions[k]];
            }
            
            for (let pos = 1; pos <= componentCount; pos++) {
                groupMappings.B[pos.toString()] = `F${startIndex + i}.${shuffledPositions[pos - 1]}`;
            }
            
            // V5 formatında etkinlik oluştur
            newActivities.push({
                id: `F${startIndex + i}`,
                etkinlik: selectedType,
                sayi: 1,
                katkiYuzdesi: weight,
                detaylar: details,
                grupBilgileri: {
                    gruplar: ["A", "B"],
                    haritalar: groupMappings
                }
            });
        }
        
        // Ağırlıkları normalize et (toplam 100 olacak şekilde)
        if (totalWeight > 0) {
            const normalizationFactor = 100 / totalWeight;
            newActivities.forEach(activity => {
                activity.katkiYuzdesi = Math.round(activity.katkiYuzdesi * normalizationFactor);
            });
        }
        
        // V5 formatında APP_STATE'i güncelle
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = { 
                dersDegerlendirme: { 
                    yariyilIciEtkinlikleri: [],
                    yariyilSonuEtkinlikleri: []
                },
                ogrenciNotlari: {}
            };
        }
        if (!APP_STATE.courseData.dersDegerlendirme) {
            APP_STATE.courseData.dersDegerlendirme = { 
                yariyilIciEtkinlikleri: [],
                yariyilSonuEtkinlikleri: []
            };
        }
        if (!APP_STATE.courseData.dersDegerlendirme.yariyilSonuEtkinlikleri) {
            APP_STATE.courseData.dersDegerlendirme.yariyilSonuEtkinlikleri = [];
        }
        
        // Mevcut etkinliklere V5 formatında ekle
        APP_STATE.courseData.dersDegerlendirme.yariyilSonuEtkinlikleri.push(...newActivities);
        
        // courseData referansını güncelle
        if (typeof courseData !== 'undefined') {
            courseData = APP_STATE.courseData;
        }
        
        // courseData'dan assessmentTree'ye dönüştür
        convertCourseDataToAssessmentTree();
        
        // UI güncellemeleri
        updateAssessmentView();
        renderTree();
        updateCategoryWeights();
        
        const summary = `✅ Tam Dosya formatında ${activityCount} yarıyıl sonu etkinlik oluşturuldu!\n` +
                       `📝 Her etkinlikte ${componentCount} soru/rubrik\n` +
                       `🎯 Etkinlik türü: ${activityType}\n` +
                       `🎲 A ve B grupları otomatik oluşturuldu\n` +
                       `⚖️ Ağırlıklar otomatik normalize edildi`;
        
        console.log('✅ Tam Dosya formatında yarıyıl sonu etkinlik oluşturma tamamlandı');
        showModernToast(summary, 'success', 5000);
        
    } catch (error) {
        console.error('❌ Tam Dosya yarıyıl sonu etkinlik oluşturulurken hata:', error);
        showModernToast('Tam Dosya yarıyıl sonu etkinlik oluşturulamadı!', 'error');
    }
}

/**
 * JSON formatının Tam Dosya (not girişi yapılmış) olup olmadığını kontrol eder
 */
function isTamDosyaFormat(jsonData) {
    // Tam dosya format kontrol kriterleri
    const hasTamDosyaStructure = jsonData.dersDegerlendirme && 
                                jsonData.dersDegerlendirme.yariyilIciEtkinlikleri &&
                                Array.isArray(jsonData.dersDegerlendirme.yariyilIciEtkinlikleri) &&
                                jsonData.dersDegerlendirme.yariyilIciEtkinlikleri.some(activity => 
                                    activity.grupBilgileri || activity.detaylar
                                );
    
    const hasTamDosyaGrades = jsonData.ogrenciNotlari && 
                             typeof jsonData.ogrenciNotlari === 'object' &&
                             Object.values(jsonData.ogrenciNotlari).some(student => 
                                 student && typeof student === 'object' && 
                                 (student.grupBilgileri || student.etkinlikNotlari)
                             );
    
    console.log("🔍 Tam Dosya Format kontrolü:", {
        hasTamDosyaStructure,
        hasTamDosyaGrades,
        isTamDosya: hasTamDosyaStructure || hasTamDosyaGrades
    });
    
    return hasTamDosyaStructure || hasTamDosyaGrades;
}

/**
 * Temel dosya format için default grup sistemi oluşturur
 */
function createDefaultGroupSystemForTemelDosya() {
    try {
        console.log("🎯 Temel dosya format için default grup sistemi oluşturuluyor...");
        
        if (!APP_STATE.assessmentTree || APP_STATE.assessmentTree.length === 0) {
            console.log("⚠️ Assessment tree boş, önce ağaç oluşturuluyor...");
            return;
        }
        
        // CourseData yapısını hazırla
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = {};
        }
        if (!APP_STATE.courseData.grupHaritalari) {
            APP_STATE.courseData.grupHaritalari = {};
        }
        if (!APP_STATE.courseData.ogrenciNotlari) {
            APP_STATE.courseData.ogrenciNotlari = {};
        }
        
        let totalMappingsCreated = 0;
        let componentsProcessed = 0;
        
        // Assessment tree'deki her bileşen için grup sistemi oluştur
        function processNode(node) {
            if (!node || !node.id) return;
            
            console.log(`🔧 Bileşen işleniyor: ${node.id} - ${node.name}`);
            
            // Bu bileşen için grup bilgisi oluştur
            if (!APP_STATE.courseData.grupHaritalari[node.id]) {
                APP_STATE.courseData.grupHaritalari[node.id] = {
                    gruplar: ['A'],
                    haritalar: {
                        'A': {}
                    }
                };
                console.log(`✅ ${node.id} için A grubu oluşturuldu`);
                componentsProcessed++;
            }
            
            // Alt bileşenleri varsa onları A grubuna sırayla ata
            if (node.children && Array.isArray(node.children) && node.children.length > 0) {
                const groupMapping = APP_STATE.courseData.grupHaritalari[node.id].haritalar['A'];
                
                node.children.forEach((child, index) => {
                    const position = (index + 1).toString();
                    const questionId = child.id;
                    
                    // Position: QuestionId formatında mapping oluştur
                    groupMapping[position] = questionId;
                    totalMappingsCreated++;
                    
                    console.log(`  📍 ${questionId} → A:${position}`);
                });
                
                console.log(`✅ ${node.id} için ${node.children.length} soru A grubuna atandı`);
            }
            
            // Alt düğümleri de işle
            if (node.children && Array.isArray(node.children)) {
                node.children.forEach(child => processNode(child));
            }
        }
        
        // Tüm assessment tree'yi işle
        APP_STATE.assessmentTree.forEach(rootNode => processNode(rootNode));
        
        // Öğrenciler için grup ataması
        if (APP_STATE.studentData && Array.isArray(APP_STATE.studentData)) {
            APP_STATE.studentData.forEach(student => {
                // Her öğrenciyi A grubuna ata
                if (!student.grup || student.grup === '') {
                    student.grup = 'A';
                }
                
                // CourseData'da öğrenci not yapısı oluştur
                if (!APP_STATE.courseData.ogrenciNotlari[student.studentId]) {
                    APP_STATE.courseData.ogrenciNotlari[student.studentId] = {
                        grupBilgileri: {}
                    };
                }
                
                // Her bileşen için öğrenciyi A grubuna ata
                Object.keys(APP_STATE.courseData.grupHaritalari).forEach(componentId => {
                    APP_STATE.courseData.ogrenciNotlari[student.studentId].grupBilgileri[componentId] = 'A';
                });
            });
            
            console.log(`✅ ${APP_STATE.studentData.length} öğrenci A grubuna atandı`);
        }
        
        // Grup sistemini başlat
        initializeGroupSystem();
        
        // UI güncellemeleri
        updateStudentTable();
        updateGroupSelectors();
        updateAssessmentView();
        updateAllInlineGroupInputs();
        
        console.log(`\n📊 DEFAULT GRUP SİSTEMİ RAPORU:`);
        console.log(`   ✅ İşlenen bileşen: ${componentsProcessed}`);
        console.log(`   📍 Oluşturulan mapping: ${totalMappingsCreated}`);
        console.log(`   👥 A grubuna atanan öğrenci: ${APP_STATE.studentData?.length || 0}`);
        
        showModernToast(`Default grup sistemi oluşturuldu: ${componentsProcessed} bileşen, ${totalMappingsCreated} soru mapping'i`, "success");
        
    } catch (error) {
        console.error("❌ Default grup sistemi oluşturulurken hata:", error);
        showModernToast("Default grup sistemi oluşturulamadı!", "error");
    }
}

/**
 * Yeni eklenen etkinlik için otomatik grup ataması
 */
function assignDefaultGroupsToNewActivity(activityNode) {
    try {
        if (!activityNode || !activityNode.id) {
            console.log("⚠️ Geçersiz etkinlik node'u, grup ataması yapılamıyor");
            return;
        }
        
        console.log(`🎯 Yeni etkinlik için grup ataması: ${activityNode.id} - ${activityNode.name}`);
        
        // CourseData yapısını hazırla
        if (!APP_STATE.courseData) {
            APP_STATE.courseData = {};
        }
        if (!APP_STATE.courseData.grupHaritalari) {
            APP_STATE.courseData.grupHaritalari = {};
        }
        
        // Bu etkinlik için grup bilgisi oluştur
        APP_STATE.courseData.grupHaritalari[activityNode.id] = {
            gruplar: ['A'],
            haritalar: {
                'A': {}
            }
        };
        
        console.log(`✅ ${activityNode.id} için A grubu oluşturuldu`);
        
        // Alt bileşenleri varsa onları A grubuna sırayla ata
        if (activityNode.children && Array.isArray(activityNode.children) && activityNode.children.length > 0) {
            // Grup mapping'ini kontrol et ve oluştur
            if (!APP_STATE.courseData.grupHaritalari[activityNode.id].haritalar) {
                APP_STATE.courseData.grupHaritalari[activityNode.id].haritalar = {};
            }
            if (!APP_STATE.courseData.grupHaritalari[activityNode.id].haritalar['A']) {
                APP_STATE.courseData.grupHaritalari[activityNode.id].haritalar['A'] = {};
            }
            
            const groupMapping = APP_STATE.courseData.grupHaritalari[activityNode.id].haritalar['A'];
            
            activityNode.children.forEach((child, index) => {
                const position = (index + 1).toString();
                const questionId = child.id;
                
                // Position: QuestionId formatında mapping oluştur
                groupMapping[position] = questionId;
                
                console.log(`  📍 ${questionId} → A:${position}`);
            });
            
            console.log(`✅ ${activityNode.id} için ${activityNode.children.length} soru A grubuna atandı`);
        }
        
        // Mevcut öğrenciler için bu etkinlikte A grubu ataması
        if (APP_STATE.studentData && Array.isArray(APP_STATE.studentData)) {
            APP_STATE.studentData.forEach(student => {
                // CourseData'da öğrenci yapısını kontrol et
                if (!APP_STATE.courseData.ogrenciNotlari) {
                    APP_STATE.courseData.ogrenciNotlari = {};
                }
                if (!APP_STATE.courseData.ogrenciNotlari[student.studentId]) {
                    APP_STATE.courseData.ogrenciNotlari[student.studentId] = {
                        grupBilgileri: {}
                    };
                }
                
                // Bu etkinlik için öğrenciyi A grubuna ata
                APP_STATE.courseData.ogrenciNotlari[student.studentId].grupBilgileri[activityNode.id] = 'A';
            });
            
            console.log(`✅ ${APP_STATE.studentData.length} öğrenci ${activityNode.id} etkinliği için A grubuna atandı`);
        }
        
        // UI güncellemeleri
        updateAssessmentView();
        updateAllInlineGroupInputs();
        
        const mappingCount = activityNode.children ? activityNode.children.length : 0;
        showModernToast(`${activityNode.name} için A grubu oluşturuldu (${mappingCount} soru atandı)`, "success");
        
    } catch (error) {
        console.error("❌ Yeni etkinlik için grup ataması yapılırken hata:", error);
        showModernToast("Yeni etkinlik grup ataması başarısız!", "error");
    }
}

/**
 * Yeni eklenen alt bileşen için otomatik mapping ataması
 */
function assignDefaultMappingToNewComponent(parentId, newComponent) {
    try {
        if (!parentId || !newComponent || !newComponent.id) {
            console.log("⚠️ Geçersiz parametreler, mapping ataması yapılamıyor");
            return;
        }
        
        console.log(`🎯 Yeni bileşen için mapping ataması: ${newComponent.id} → ${parentId}`);
        
        // CourseData yapısını kontrol et
        if (!APP_STATE.courseData?.grupHaritalari?.[parentId]?.haritalar?.['A']) {
            console.log("⚠️ Parent etkinlik için A grubu bulunamadı, önce grup oluşturuluyor");
            
            // Parent için grup sistemi oluştur
            if (!APP_STATE.courseData) APP_STATE.courseData = {};
            if (!APP_STATE.courseData.grupHaritalari) APP_STATE.courseData.grupHaritalari = {};
            if (!APP_STATE.courseData.grupHaritalari[parentId]) {
                APP_STATE.courseData.grupHaritalari[parentId] = {
                    gruplar: ['A'],
                    haritalar: { 'A': {} }
                };
            }
        }
        
        const groupMapping = APP_STATE.courseData.grupHaritalari[parentId].haritalar['A'];
        
        // Mevcut en yüksek pozisyonu bul
        const existingPositions = Object.keys(groupMapping).map(pos => parseInt(pos)).filter(pos => !isNaN(pos));
        const nextPosition = existingPositions.length > 0 ? Math.max(...existingPositions) + 1 : 1;
        
        // Yeni bileşeni sıradaki pozisyona ata
        groupMapping[nextPosition.toString()] = newComponent.id;
        
        console.log(`✅ ${newComponent.id} → A:${nextPosition} atandı`);
        
        // UI güncellemeleri
        updateAssessmentView();
        updateAllInlineGroupInputs();
        
        showModernToast(`${newComponent.name} A:${nextPosition} pozisyonuna atandı`, "success");
        
    } catch (error) {
        console.error("❌ Yeni bileşen mapping ataması yapılırken hata:", error);
        showModernToast("Yeni bileşen mapping ataması başarısız!", "error");
    }
}

// Global fonksiyonlar
window.createGroupMappingForActivity = createGroupMappingForActivity;
window.loadGroupMappingsFromAssessmentData = loadGroupMappingsFromAssessmentData;
window.loadStudentGradesNewFormat = loadStudentGradesNewFormat;
window.generateTamDosyaTermAssessmentWithParams = generateTamDosyaTermAssessmentWithParams;
window.generateTamDosyaFinalAssessmentWithParams = generateTamDosyaFinalAssessmentWithParams;
window.isTamDosyaFormat = isTamDosyaFormat;
window.createDefaultGroupSystemForTemelDosya = createDefaultGroupSystemForTemelDosya;
window.assignDefaultGroupsToNewActivity = assignDefaultGroupsToNewActivity;
window.assignDefaultMappingToNewComponent = assignDefaultMappingToNewComponent;

// =====================================================
// ETKİNLİK SEÇENEK MODAL EVENT LISTENERS
// =====================================================

// Event Listeners
document.addEventListener('DOMContentLoaded', function() {
    // Etkinlik seçenek kartları
    const activityModal = document.getElementById('activityOptionsModal');
    if (activityModal) {
        activityModal.addEventListener('click', function(e) {
            const card = e.target.closest('.activity-option-card');
            if (card) {
                selectActivityOption(card);
            }
            
            // Count butonları
            if (e.target.classList.contains('count-btn')) {
                const target = e.target.dataset.target;
                const delta = e.target.classList.contains('plus') ? 1 : -1;
                updateCountValue(target, delta);
                
                // Puan alanını kontrol et
                updatePointsFieldVisibility();
            }
            
            // Modern close butonları
            if (e.target.classList.contains('modern-close')) {
                closeActivityOptionsModal();
            }
        });
    }
    
    // Apply butonu
    const applyBtn = document.getElementById('applyActivityOptions');
    if (applyBtn) {
        applyBtn.addEventListener('click', applyActivityOptions);
    }
    
    // Boş bırak butonu
    const emptyBtn = document.getElementById('emptyActivityOption');
    if (emptyBtn) {
        emptyBtn.addEventListener('click', function() {
            applyEmptyOption();
            closeActivityOptionsModal();
        });
    }
    
    // Count input'ları için limit kontrolü ve puan alanı kontrolü
    ['questionCount', 'rubricCount'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener('input', function() {
                const value = parseInt(this.value);
                if (value < 1) this.value = 1;
                if (value > 50) this.value = 50;
                
                // Puan alanını kontrol et
                updatePointsFieldVisibility();
            });
            
            // Sayfa yüklendiğinde de kontrol et
            setTimeout(() => {
                updatePointsFieldVisibility();
            }, 100);
        }
    });
    
    // Puan input'ları için limit kontrolü
    ['questionDefaultPoints', 'rubricDefaultPoints'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener('input', function() {
                const value = parseInt(this.value);
                if (value < 1) this.value = 1;
                if (value > 100) this.value = 100;
            });
        }
    });
    
    // ÖÇ seçim event listener'ları
    const outcomesSelect = document.getElementById('activityOutcomesSelect');
    if (outcomesSelect) {
        outcomesSelect.addEventListener('change', updateActivityOutcomesPreview);
    }
    
    // ÖÇ hızlı aksiyon butonları
    const selectAllBtn = document.getElementById('selectAllActivityOutcomes');
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', selectAllActivityOutcomes);
    }
    
    const randomSelectBtn = document.getElementById('randomSelectActivityOutcomes');
    if (randomSelectBtn) {
        randomSelectBtn.addEventListener('click', randomSelectActivityOutcomes);
    }
    
    const clearAllBtn = document.getElementById('clearAllActivityOutcomes');
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', clearAllActivityOutcomes);
    }
});

// =====================================================
// ETKİNLİK MODAL ÖÇ SEÇİM FONKSİYONLARI
// =====================================================

/**
 * Etkinlik modal ÖÇ seçim alanını doldur
 */
function populateActivityOutcomesSelect() {
    const select = document.getElementById('activityOutcomesSelect');
    if (!select) {
        console.warn('ÖÇ select elementi bulunamadı');
        return;
    }
    
    // Debug: APP_STATE durumunu kontrol et
    console.log('APP_STATE.courseData:', APP_STATE.courseData);
    
    if (!APP_STATE.courseData) {
        console.warn('CourseData bulunamadı');
        select.innerHTML = '<option disabled>Önce ders JSON dosyası yükleyin</option>';
        return;
    }
    
    // Farklı ÖÇ alanlarını kontrol et
    let outcomes = null;
    if (APP_STATE.courseData.dersOgrenmeÇiktilari) {
        outcomes = APP_STATE.courseData.dersOgrenmeÇiktilari;
    } else if (APP_STATE.courseData.ogrenimCiktilari) {
        outcomes = APP_STATE.courseData.ogrenimCiktilari;
    } else if (APP_STATE.courseData.learningOutcomes) {
        outcomes = APP_STATE.courseData.learningOutcomes;
    } else if (APP_STATE.courseData.outcomes) {
        outcomes = APP_STATE.courseData.outcomes;
    }
    
    console.log('Bulunan ÖÇler:', outcomes);
    
    // Mevcut seçimleri temizle
    select.innerHTML = '';
    
    if (!outcomes || !Array.isArray(outcomes) || outcomes.length === 0) {
        select.innerHTML = '<option disabled>ÖÇ bulunamadı</option>';
        console.warn('ÖÇ verisi bulunamadı veya boş');
        return;
    }
    
    // ÖÇ'leri ekle
    outcomes.forEach((outcome, index) => {
        const option = document.createElement('option');
        
        // Farklı veri formatlarını destekle
        if (outcome.id && outcome.aciklama) {
            // JSON formatı: {id: "ÖÇ.1", aciklama: "..."}
            option.value = outcome.id;
            option.textContent = `${outcome.id} - ${outcome.aciklama}`;
        } else if (outcome.kod && outcome.baslik) {
            option.value = outcome.kod;
            option.textContent = `${outcome.kod} - ${outcome.baslik}`;
        } else if (outcome.code && outcome.title) {
            option.value = outcome.code;
            option.textContent = `${outcome.code} - ${outcome.title}`;
        } else if (outcome.id && outcome.name) {
            option.value = outcome.id;
            option.textContent = `${outcome.id} - ${outcome.name}`;
        } else if (typeof outcome === 'string') {
            option.value = outcome;
            option.textContent = outcome;
        } else {
            // Fallback
            option.value = `ÖÇ.${index + 1}`;
            option.textContent = `ÖÇ.${index + 1} - ${outcome.description || outcome.aciklama || outcome.baslik || outcome.title || 'Ogrenme Ciktisi'}`;
        }
        
        select.appendChild(option);
    });
    
    console.log(`✅ ${outcomes.length} adet ÖÇ yüklendi`);
    
    // Önizlemeyi güncelle
    updateActivityOutcomesPreview();
}

/**
 * Puan alanlarının görünürlüğünü güncelle
 */
function updatePointsFieldVisibility() {
    // Soru puan alanı kontrolü
    const questionCount = parseInt(document.getElementById('questionCount')?.value || 1);
    const questionPointsGroup = document.getElementById('questionPointsGroup');
    const questionPointsInput = document.getElementById('questionDefaultPoints');
    const questionPointsInfo = document.getElementById('questionPointsInfo');
    
    if (questionPointsGroup && questionPointsInput && questionPointsInfo) {
        if (questionCount > 1) {
            // Birden fazla soru - puan alanını devre dışı bırak ve bilgi göster
            questionPointsInput.disabled = true;
            questionPointsGroup.classList.add('disabled');
            questionPointsInfo.style.display = 'block';
        } else {
            // Tek soru - puan alanını aktif et ve bilgiyi gizle
            questionPointsInput.disabled = false;
            questionPointsGroup.classList.remove('disabled');
            questionPointsInfo.style.display = 'none';
        }
    }
    
    // Rubrik puan alanı kontrolü
    const rubricCount = parseInt(document.getElementById('rubricCount')?.value || 1);
    const rubricPointsGroup = document.getElementById('rubricPointsGroup');
    const rubricPointsInput = document.getElementById('rubricDefaultPoints');
    const rubricPointsInfo = document.getElementById('rubricPointsInfo');
    
    if (rubricPointsGroup && rubricPointsInput && rubricPointsInfo) {
        if (rubricCount > 1) {
            // Birden fazla rubrik - puan alanını devre dışı bırak ve bilgi göster
            rubricPointsInput.disabled = true;
            rubricPointsGroup.classList.add('disabled');
            rubricPointsInfo.style.display = 'block';
        } else {
            // Tek rubrik - puan alanını aktif et ve bilgiyi gizle
            rubricPointsInput.disabled = false;
            rubricPointsGroup.classList.remove('disabled');
            rubricPointsInfo.style.display = 'none';
        }
    }
}

/**
 * Seçili ÖÇ'lerin önizlemesini güncelle
 */
function updateActivityOutcomesPreview() {
    const select = document.getElementById('activityOutcomesSelect');
    const previewContainer = document.getElementById('selectedOutcomesPreview');
    
    if (!select || !previewContainer) return;
    
    const selectedOptions = Array.from(select.selectedOptions);
    
    if (selectedOptions.length === 0) {
        previewContainer.innerHTML = '<span class="no-selection">Henüz seçim yapılmadı</span>';
        return;
    }
    
    // Seçili ÖÇ'leri tag olarak göster
    previewContainer.innerHTML = selectedOptions
        .map(option => `<span class="outcome-preview-tag">${option.value}</span>`)
        .join('');
}

/**
 * Tüm ÖÇ'leri seç
 */
function selectAllActivityOutcomes() {
    const select = document.getElementById('activityOutcomesSelect');
    if (!select) return;
    
    Array.from(select.options).forEach(option => {
        option.selected = true;
    });
    
    updateActivityOutcomesPreview();
    showModernToast("Tüm ÖÇler seçildi!", "success");
}

/**
 * Rastgele ÖÇ seç (1-3 adet)
 */
function randomSelectActivityOutcomes() {
    const select = document.getElementById('activityOutcomesSelect');
    if (!select || select.options.length === 0) return;
    
    // Önce tüm seçimleri temizle
    Array.from(select.options).forEach(option => {
        option.selected = false;
    });
    
    // Rastgele 1-3 adet seç
    const optionsArray = Array.from(select.options);
    const randomCount = Math.floor(Math.random() * 3) + 1; // 1-3 arası
    const selectedCount = Math.min(randomCount, optionsArray.length);
    
    // Rastgele seçim yap
    const shuffled = optionsArray.sort(() => 0.5 - Math.random());
    for (let i = 0; i < selectedCount; i++) {
        shuffled[i].selected = true;
    }
    
    updateActivityOutcomesPreview();
    showModernToast(`${selectedCount} adet ÖÇ rastgele seçildi!`, "success");
}

/**
 * Tüm ÖÇ seçimlerini temizle
 */
function clearAllActivityOutcomes() {
    const select = document.getElementById('activityOutcomesSelect');
    if (!select) return;
    
    Array.from(select.options).forEach(option => {
        option.selected = false;
    });
    
    updateActivityOutcomesPreview();
    showModernToast("ÖÇ seçimleri temizlendi!", "info");
}

/**
 * Seçili ÖÇ'leri al
 * @returns {Array} Seçili ÖÇ kodları
 */
function getSelectedActivityOutcomes() {
    const select = document.getElementById('activityOutcomesSelect');
    if (!select) return [];
    
    return Array.from(select.selectedOptions).map(option => option.value);
}


/**
 * Rastgele ağırlık dağılımı oluştur
 * @param {number} count - Öğe sayısı
 * @returns {Array} - Ağırlık dizisi (toplamı 100)
 */
function generateRandomWeights(count) {
    if (count === 1) return [100];
    
    // Rastgele sayılar üret
    let weights = [];
    for (let i = 0; i < count - 1; i++) {
        weights.push(Math.random());
    }
    
    // Sırala
    weights.sort((a, b) => a - b);
    
    // Aralıklara çevir
    let intervals = [];
    intervals.push(weights[0]);
    for (let i = 1; i < weights.length; i++) {
        intervals.push(weights[i] - weights[i-1]);
    }
    intervals.push(1 - weights[weights.length - 1]);
    
    // 100'e çevir ve yuvarla
    let result = intervals.map(w => Math.max(1, Math.round(w * 100)));
    
    // Toplamı 100 yap
    let total = result.reduce((a, b) => a + b, 0);
    if (total !== 100) {
        let diff = 100 - total;
        // Farkı en büyük değere ekle/çıkar
        let maxIndex = result.indexOf(Math.max(...result));
        result[maxIndex] += diff;
        result[maxIndex] = Math.max(1, result[maxIndex]);
    }
    
    return result;
}


// Puan input'ları için limit kontrolü
document.addEventListener('DOMContentLoaded', function() {
    ['questionDefaultPoints', 'rubricDefaultPoints'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener('input', function() {
                const value = parseInt(this.value);
                if (value < 1) this.value = 1;
                if (value > 100) this.value = 100;
            });
        }
    });
    
    // Status badge'leri ilk yüklemede güncelle (slider formatını kullan)
    setTimeout(() => {
        updatePassFailCounts();
    }, 100);
});

// =====================================================
// ETKİNLİK TAŞIMA FONKSİYONLARI
// =====================================================

/**
 * Etkinliği yukarı taşı
 * @param {string} activityId - Taşınacak etkinlik ID'si
 */
async function moveActivityUp(activityId) {
    try {
        const node = findNodeById(activityId);
        if (!node) {
            showModernToast("Etkinlik bulunamadı!", "error");
            return;
        }
        
        // Ana ağaçta mevcut sırasını bul
        const currentIndex = APP_STATE.assessmentTree.findIndex(n => n.id === activityId);
        
        if (currentIndex <= 0) {
            showModernToast("Bu etkinlik zaten en üstte!", "warning");
            return;
        }
        
        // Aynı kategorideki önceki etkinliği bul
        const isTermActivity = activityId.startsWith('A');
        let previousIndex = -1;
        for (let i = currentIndex - 1; i >= 0; i--) {
            const nodeAtIndex = APP_STATE.assessmentTree[i];
            if ((isTermActivity && nodeAtIndex.id.startsWith('A')) || 
                (!isTermActivity && nodeAtIndex.id.startsWith('F'))) {
                previousIndex = i;
                break;
            }
        }
        
        if (previousIndex === -1) {
            showModernToast("Bu etkinlik kategorisinde zaten en üstte!", "warning");
            return;
        }
        
        // Onay al
        const confirmed = await showModernConfirm(
            'Etkinlik Taşıma Onayı',
            `${getComponentDisplayName(activityId)} etkinliğini yukarı taşımak istediğinizden emin misiniz?\\n\\nBu işlem etkinliğin sırasını değiştirecek ve ID'lerini yeniden düzenleyecektir.`,
            {
                confirmText: 'Evet, Taşı',
                cancelText: 'İptal',
                headerClass: 'info-action',
                iconClass: 'info'
            }
        );
        
        if (!confirmed) return;
        
        // Grup haritalamalarını kaydet
        const movedActivity = APP_STATE.assessmentTree[currentIndex];
        const savedMappings = {};
        saveNodeGroupMappings(movedActivity, savedMappings);
        
        // Ana ağaçta sıraları değiştir
        APP_STATE.assessmentTree.splice(currentIndex, 1);
        APP_STATE.assessmentTree.splice(previousIndex, 0, movedActivity);
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        showModernToast(`${getComponentDisplayName(activityId)} etkinliği yukarı taşındı!`, "success");
        
    } catch (error) {
        console.error("Etkinlik yukarı taşınırken hata:", error);
        showModernToast("Etkinlik taşınırken hata oluştu!", "error");
    }
}

/**
 * Etkinliği aşağı taşı
 * @param {string} activityId - Taşınacak etkinlik ID'si
 */
async function moveActivityDown(activityId) {
    try {
        const node = findNodeById(activityId);
        if (!node) {
            showModernToast("Etkinlik bulunamadı!", "error");
            return;
        }
        
        // Ana ağaçta mevcut sırasını bul
        const currentIndex = APP_STATE.assessmentTree.findIndex(n => n.id === activityId);
        
        if (currentIndex >= APP_STATE.assessmentTree.length - 1) {
            showModernToast("Bu etkinlik zaten en altta!", "warning");
            return;
        }
        
        // Aynı kategorideki sonraki etkinliği bul
        const isTermActivity = activityId.startsWith('A');
        let nextIndex = -1;
        for (let i = currentIndex + 1; i < APP_STATE.assessmentTree.length; i++) {
            const nodeAtIndex = APP_STATE.assessmentTree[i];
            if ((isTermActivity && nodeAtIndex.id.startsWith('A')) || 
                (!isTermActivity && nodeAtIndex.id.startsWith('F'))) {
                nextIndex = i;
                break;
            }
        }
        
        if (nextIndex === -1) {
            showModernToast("Bu etkinlik kategorisinde zaten en altta!", "warning");
            return;
        }
        
        // Onay al
        const confirmed = await showModernConfirm(
            'Etkinlik Taşıma Onayı',
            `${getComponentDisplayName(activityId)} etkinliğini aşağı taşımak istediğinizden emin misiniz?\\n\\nBu işlem etkinliğin sırasını değiştirecek ve ID'lerini yeniden düzenleyecektir.`,
            {
                confirmText: 'Evet, Taşı',
                cancelText: 'İptal',
                headerClass: 'info-action',
                iconClass: 'info'
            }
        );
        
        if (!confirmed) return;
        
        // Grup haritalamalarını kaydet
        const movedActivity = APP_STATE.assessmentTree[currentIndex];
        const savedMappings = {};
        saveNodeGroupMappings(movedActivity, savedMappings);
        
        // Ana ağaçta sıraları değiştir
        APP_STATE.assessmentTree.splice(currentIndex, 1);
        APP_STATE.assessmentTree.splice(nextIndex, 0, movedActivity);
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        showModernToast(`${getComponentDisplayName(activityId)} etkinliği aşağı taşındı!`, "success");
        
    } catch (error) {
        console.error("Etkinlik aşağı taşınırken hata:", error);
        showModernToast("Etkinlik taşınırken hata oluştu!", "error");
    }
}

/**
 * Etkinlik ID'lerini yeniden düzenle
 * @param {Array} categoryNodes - Kategori düğümleri
 * @param {boolean} isTermActivity - Yarıyıl içi etkinlik mi
 */
async function reassignActivityIds(categoryNodes, isTermActivity) {
    const prefix = isTermActivity ? 'A' : 'F';
    
    console.log(`🔄 ID yeniden düzenleme başlıyor: ${prefix} kategorisi, ${categoryNodes.length} etkinlik`);
    
    // Eski ID'leri ve grup haritalamalarını sakla
    const oldToNewIdMap = {};
    const savedGroupMappings = {};
    
    // Önce tüm eski ID'leri ve grup haritalamalarını kaydet
    categoryNodes.forEach((node, index) => {
        const oldId = node.id;
        const newId = `${prefix}${index + 1}`;
        oldToNewIdMap[oldId] = newId;
        
        console.log(`📝 ID mapping: ${oldId} → ${newId}`);
        
        // Bu düğüm ve alt düğümlerinin grup haritalamalarını kaydet
        saveNodeGroupMappings(node, savedGroupMappings);
    });
    
    // ID'leri güncelle
    categoryNodes.forEach((node, index) => {
        const newId = `${prefix}${index + 1}`;
        updateNodeIdRecursive(node, newId);
    });
    
    // Grup haritalamalarını yeni ID'lerle geri yükle
    restoreGroupMappings(savedGroupMappings, oldToNewIdMap);
    
    // Ana ağacı güncelle
    updateAssessmentTreeAfterReassign(categoryNodes, isTermActivity);
    
    console.log(`✅ ID yeniden düzenleme tamamlandı: ${prefix} kategorisi`);
    
    // ID mapping'leri döndür
    return oldToNewIdMap;
}

/**
 * Düğüm ve alt düğümlerinin grup haritalamalarını kaydet (YENİ FORMAT)
 */
function saveNodeGroupMappings(node, savedMappings) {
    if (!APP_STATE.courseData?.grupHaritalari) return;
    
    console.log(`💾 saveNodeGroupMappings çağrıldı: ${node.id}`);
    
    // Yeni format: grupHaritalari[activityId] = { gruplar: [], haritalar: {} }
    if (APP_STATE.courseData.grupHaritalari[node.id]) {
        savedMappings[node.id] = JSON.parse(JSON.stringify(APP_STATE.courseData.grupHaritalari[node.id]));
        console.log(`✅ Grup haritalama kaydedildi: ${node.id}`, savedMappings[node.id]);
    }
    
    // Alt düğümler için recursive kaydetme
    if (node.children && node.children.length > 0) {
        node.children.forEach(child => {
            saveNodeGroupMappings(child, savedMappings);
        });
    }
}

/**
 * Grup haritalamalarını yeni ID'lerle geri yükle
 */
function restoreGroupMappings(savedMappings, oldToNewIdMap) {
    if (!APP_STATE.courseData?.grupHaritalari || !savedMappings || !oldToNewIdMap) return;
    
    console.log(`🔄 restoreGroupMappings başlıyor...`);
    console.log(`📊 Kayıtlı haritalamalar:`, Object.keys(savedMappings));
    console.log(`📊 ID Mapping:`, oldToNewIdMap);
    
    // Önce eski ID'lere ait tüm haritalamları temizle
    Object.keys(oldToNewIdMap).forEach(oldId => {
        if (APP_STATE.courseData.grupHaritalari[oldId]) {
            delete APP_STATE.courseData.grupHaritalari[oldId];
            console.log(`🗑️ Eski haritalama silindi: ${oldId}`);
        }
    });
    
    // Yeni ID'lerle haritalamları geri yükle
    Object.keys(savedMappings).forEach(oldId => {
        const newId = oldToNewIdMap[oldId];
        if (newId && savedMappings[oldId]) {
            // Yeni ID için haritalamayı kopyala
            APP_STATE.courseData.grupHaritalari[newId] = JSON.parse(JSON.stringify(savedMappings[oldId]));
            
            // CRITICAL: Alt soru ID'lerini de güncelle
            if (savedMappings[oldId].haritalar) {
                Object.keys(savedMappings[oldId].haritalar).forEach(groupName => {
                    const groupMapping = savedMappings[oldId].haritalar[groupName];
                    const updatedGroupMapping = {};
                    
                    // Her sıra numarası için yeni soru ID'sini hesapla
                    Object.keys(groupMapping).forEach(position => {
                        const oldQuestionId = groupMapping[position];
                        
                        // Eski soru ID'sinden yeni soru ID'sine çevir
                        if (oldQuestionId.startsWith(oldId + '.')) {
                            const questionNumber = oldQuestionId.split('.').pop();
                            const newQuestionId = `${newId}.${questionNumber}`;
                            updatedGroupMapping[position] = newQuestionId;
                            console.log(`📝 Soru ID güncellendi: ${oldQuestionId} → ${newQuestionId}`);
                        } else {
                            updatedGroupMapping[position] = oldQuestionId;
                        }
                    });
                    
                    APP_STATE.courseData.grupHaritalari[newId].haritalar[groupName] = updatedGroupMapping;
                });
            }
            
            console.log(`✅ Grup haritalama geri yüklendi: ${oldId} → ${newId}`, APP_STATE.courseData.grupHaritalari[newId]);
        }
    });
}

/**
 * ID yeniden düzenlemeden sonra ana ağacı güncelle
 */
function updateAssessmentTreeAfterReassign(updatedCategoryNodes, isTermActivity) {
    // Diğer kategorinin düğümlerini al
    const otherCategoryNodes = APP_STATE.assessmentTree.filter(node => 
        isTermActivity ? node.id.startsWith('F') : node.id.startsWith('A')
    );
    
    // Ana ağacı yeniden oluştur
    APP_STATE.assessmentTree = [
        ...(isTermActivity ? updatedCategoryNodes : otherCategoryNodes),
        ...(isTermActivity ? otherCategoryNodes : updatedCategoryNodes)
    ];
    
    console.log(`🔄 Ana ağaç güncellendi. Toplam etkinlik: ${APP_STATE.assessmentTree.length}`);
}

/**
 * Tüm etkinlik ve alt bileşen ID'lerini yeniden düzenle
 * Bu fonksiyon taşıma işlemlerinden sonra çağrılır
 */
async function reorganizeAllIds() {
    console.log('🎯 Kapsamlı ID yeniden düzenleme başlıyor...');
    
    try {
        // Tüm grup haritalamalarını kaydet
        const savedMappings = {};
        APP_STATE.assessmentTree.forEach(node => {
            saveNodeGroupMappings(node, savedMappings);
        });
        
        // ID mapping'lerini topla
        const oldToNewIdMap = {};
        
        // Yarıyıl içi etkinlikleri yeniden düzenle (A1, A2, A3...)
        const termActivities = APP_STATE.assessmentTree.filter(node => 
            node.id.startsWith('A') || node.id.startsWith('A_TEMP_')
        );
        termActivities.forEach((node, index) => {
            const oldId = node.id;
            const newId = `A${index + 1}`;
            oldToNewIdMap[oldId] = newId;
            
            // Ana etkinlik ID'sini güncelle
            updateNodeIdRecursive(node, newId);
            
            console.log(`📝 Yarıyıl İçi: ${oldId} → ${newId}`);
        });
        
        // Yarıyıl sonu etkinlikleri yeniden düzenle (F1, F2, F3...)
        const finalActivities = APP_STATE.assessmentTree.filter(node => 
            node.id.startsWith('F') || node.id.startsWith('F_TEMP_')
        );
        finalActivities.forEach((node, index) => {
            const oldId = node.id;
            const newId = `F${index + 1}`;
            oldToNewIdMap[oldId] = newId;
            
            // Ana etkinlik ID'sini güncelle
            updateNodeIdRecursive(node, newId);
            
            console.log(`📝 Yarıyıl Sonu: ${oldId} → ${newId}`);
        });
        
        // Ana ağacı yeniden sırala (A etkinlikleri önce, F etkinlikleri sonra)
        APP_STATE.assessmentTree = [
            ...termActivities,
            ...finalActivities
        ];
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        console.log('✅ Kapsamlı ID yeniden düzenleme tamamlandı');
        console.log('📊 ID Mapping:', oldToNewIdMap);
        
        return oldToNewIdMap;
        
    } catch (error) {
        console.error('❌ ID yeniden düzenleme hatası:', error);
        throw error;
    }
}

/**
 * Düğüm ID'sini recursively güncelle
 * @param {Object} node - Düğüm
 * @param {string} newId - Yeni ID
 */
function updateNodeIdRecursive(node, newId) {
    // Ana düğümün ID'sini güncelle
    node.id = newId;
    
    // Alt düğümlerin ID'lerini güncelle
    if (node.children && node.children.length > 0) {
        node.children.forEach((child, index) => {
            const newChildId = `${newId}.${index + 1}`;
            updateNodeIdRecursive(child, newChildId);
        });
    }
}

// =====================================================
// SÜRÜKLE-BIRAK FONKSİYONLARI
// =====================================================

/**
 * Ana etkinlikler ve alt bileşenler için sürükle-bırak özelliği ekle
 */
function enableDragAndDrop() {
    // Önceki event listener'ları temizle
    document.querySelectorAll('.tree-node').forEach(nodeElement => {
        nodeElement.removeEventListener('dragstart', handleDragStart);
        nodeElement.removeEventListener('dragover', handleDragOver);
        nodeElement.removeEventListener('drop', handleDrop);
        nodeElement.removeEventListener('dragend', handleDragEnd);
        nodeElement.removeEventListener('dragenter', handleDragEnter);
        nodeElement.removeEventListener('dragleave', handleDragLeave);
        nodeElement.removeEventListener('dragstart', handleComponentDragStart);
        nodeElement.removeEventListener('dragend', handleComponentDragEnd);
    });
    
    // Tüm düğümleri kontrol et
    document.querySelectorAll('.tree-node').forEach(nodeElement => {
        const nodeId = nodeElement.dataset.id;
        if (!nodeId) return;
        
        const isMainActivity = (nodeId.startsWith('A') || nodeId.startsWith('F')) && !nodeId.includes('.');
        const isSubComponent = nodeId.includes('.'); // Alt bileşen (A1.1, F1.2 gibi)
        
        // Ana etkinlikler için sürükle-bırak
        if (isMainActivity) {
            nodeElement.draggable = true;
            nodeElement.classList.add('draggable-activity');
            
            // Ana etkinlik drag event listeners
            nodeElement.addEventListener('dragstart', handleDragStart);
            nodeElement.addEventListener('dragend', handleDragEnd);
            
            // Ana etkinlikler drop hedefi olabilir
            nodeElement.addEventListener('dragover', handleDragOver);
            nodeElement.addEventListener('drop', handleDrop);
            nodeElement.addEventListener('dragenter', handleDragEnter);
            nodeElement.addEventListener('dragleave', handleDragLeave);
        }
        
        // Alt bileşenler için sürükle-bırak
        if (isSubComponent) {
            nodeElement.draggable = true;
            nodeElement.classList.add('draggable-component');
            
            // Alt bileşen drag event listeners
            nodeElement.addEventListener('dragstart', handleComponentDragStart);
            nodeElement.addEventListener('dragend', handleComponentDragEnd);
            
            // Alt bileşenler de drop hedefi olabilir (aynı parent altında)
            nodeElement.addEventListener('dragover', handleDragOver);
            nodeElement.addEventListener('drop', handleComponentDrop);
            nodeElement.addEventListener('dragenter', handleComponentDragEnter);
            nodeElement.addEventListener('dragleave', handleDragLeave);
        }
    });
}

/**
 * Drag start event handler
 */
function handleDragStart(e) {
    const nodeElement = e.currentTarget;
    const nodeId = nodeElement.dataset.id;
    
    currentDraggedId = nodeId;
    e.dataTransfer.setData('text/plain', nodeId);
    e.dataTransfer.effectAllowed = 'move';
    
    nodeElement.classList.add('dragging');
    
    console.log(`🎯 Sürükleme başladı: ${nodeId}`);
}

// Global değişkenler - sürüklenen element ID'leri
let currentDraggedId = null;
let currentDraggedComponentId = null;

/**
 * Drag enter event handler
 */
function handleDragEnter(e) {
    e.preventDefault();
    const nodeElement = e.currentTarget;
    const targetId = nodeElement.dataset.id;
    
    if (canDropOn(currentDraggedId, targetId)) {
        nodeElement.classList.add('drag-over-valid');
        nodeElement.classList.remove('drag-over-invalid');
    } else {
        nodeElement.classList.add('drag-over-invalid');
        nodeElement.classList.remove('drag-over-valid');
    }
}

/**
 * Drag over event handler
 */
function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

/**
 * Drag leave event handler
 */
function handleDragLeave(e) {
    const nodeElement = e.currentTarget;
    // Sadece element'ten tamamen çıkıldığında temizle
    if (!nodeElement.contains(e.relatedTarget)) {
        nodeElement.classList.remove('drag-over-valid', 'drag-over-invalid');
    }
}

/**
 * Drop event handler
 */
async function handleDrop(e) {
    e.preventDefault();
    
    const draggedId = e.dataTransfer.getData('text/plain');
    const targetElement = e.currentTarget;
    const targetId = targetElement.dataset.id;
    
    // Cleanup tüm drag sınıfları
    document.querySelectorAll('.drag-over-valid, .drag-over-invalid, .dragging').forEach(el => {
        el.classList.remove('drag-over-valid', 'drag-over-invalid', 'dragging');
    });
    
    console.log(`🎯 Drop işlemi: ${draggedId} → ${targetId}`);
    
    if (!draggedId || !targetId || draggedId === targetId) {
        console.log('❌ Geçersiz drop işlemi');
        return;
    }
    
    if (!canDropOn(draggedId, targetId)) {
        showModernToast("Bu etkinlik burada taşınamaz!", "warning");
        return;
    }
    
    // Farklı kategoriler arasında taşıma kontrolü
    const draggedIsTermActivity = draggedId.startsWith('A');
    const targetIsTermActivity = targetId.startsWith('A');
    
    if (draggedIsTermActivity !== targetIsTermActivity) {
        // Kategoriler arası taşıma
        await moveActivityBetweenCategories(draggedId, targetId);
    } else {
        // Aynı kategori içinde taşıma
        await moveActivityWithinCategory(draggedId, targetId);
    }
}

/**
 * Drag end event handler
 */
function handleDragEnd(e) {
    const nodeElement = e.currentTarget;
    nodeElement.classList.remove('dragging');
    
    // Tüm drag sınıflarını temizle
    document.querySelectorAll('.drag-over-valid, .drag-over-invalid').forEach(el => {
        el.classList.remove('drag-over-valid', 'drag-over-invalid');
    });
    
    // Global değişkeni temizle
    currentDraggedId = null;
    
    console.log('🎯 Sürükleme sona erdi');
}

// =====================================================
// ALT BİLEŞEN SÜRÜKLE-BIRAK FONKSİYONLARI
// =====================================================

/**
 * Alt bileşen drag start event handler
 */
function handleComponentDragStart(e) {
    const nodeElement = e.currentTarget;
    const nodeId = nodeElement.dataset.id;
    
    currentDraggedComponentId = nodeId;
    e.dataTransfer.setData('text/plain', nodeId);
    e.dataTransfer.effectAllowed = 'move';
    
    nodeElement.classList.add('dragging');
    
    console.log(`🎯 Alt bileşen sürükleme başladı: ${nodeId}`);
}

/**
 * Alt bileşen drag end event handler
 */
function handleComponentDragEnd(e) {
    const nodeElement = e.currentTarget;
    nodeElement.classList.remove('dragging');
    currentDraggedComponentId = null;
    
    // Tüm drag-over sınıflarını temizle
    document.querySelectorAll('.drag-over-valid, .drag-over-invalid').forEach(el => {
        el.classList.remove('drag-over-valid', 'drag-over-invalid');
    });
    
    console.log('🎯 Alt bileşen sürükleme tamamlandı');
}

/**
 * Alt bileşen drag enter event handler
 */
function handleComponentDragEnter(e) {
    e.preventDefault();
    const nodeElement = e.currentTarget;
    const targetId = nodeElement.dataset.id;
    
    if (canDropComponentOn(currentDraggedComponentId, targetId)) {
        nodeElement.classList.add('drag-over-valid');
        nodeElement.classList.remove('drag-over-invalid');
    } else {
        nodeElement.classList.add('drag-over-invalid');
        nodeElement.classList.remove('drag-over-valid');
    }
}

/**
 * Alt bileşen drop event handler
 */
async function handleComponentDrop(e) {
    e.preventDefault();
    
    const draggedId = e.dataTransfer.getData('text/plain');
    const targetElement = e.currentTarget;
    const targetId = targetElement.dataset.id;
    
    // Cleanup tüm drag sınıfları
    document.querySelectorAll('.drag-over-valid, .drag-over-invalid, .dragging').forEach(el => {
        el.classList.remove('drag-over-valid', 'drag-over-invalid', 'dragging');
    });
    
    console.log(`🎯 Alt bileşen drop işlemi: ${draggedId} → ${targetId}`);
    
    if (!draggedId || !targetId || draggedId === targetId) {
        console.log('❌ Geçersiz alt bileşen drop işlemi');
        return;
    }
    
    if (!canDropComponentOn(draggedId, targetId)) {
        showModernToast("Bu bileşen burada taşınamaz!", "warning");
        return;
    }
    
    // Parent ID'lerini kontrol et
    const draggedParent = draggedId.substring(0, draggedId.lastIndexOf('.'));
    const targetParent = targetId.substring(0, targetId.lastIndexOf('.'));
    
    try {
        if (draggedParent === targetParent) {
            // Aynı parent altında taşıma
            await moveComponentWithinParent(draggedId, targetId);
        } else {
            // Farklı etkinlikler arasında taşıma
            await moveComponentBetweenActivities(draggedId, targetId);
        }
    } catch (error) {
        console.error('❌ Alt bileşen taşıma hatası:', error);
        showModernToast("Alt bileşen taşınırken hata oluştu!", "error");
    }
}

/**
 * Belirli bir etkinliğin başka bir etkinlik üzerine bırakılıp bırakılamayacağını kontrol et
 */
function canDropOn(draggedId, targetId) {
    if (!draggedId || !targetId || draggedId === targetId) {
        return false;
    }
    
    const draggedIsMainActivity = !draggedId.includes('.');
    const targetIsMainActivity = !targetId.includes('.');
    
    // Ana etkinlikler sadece ana etkinlikler üzerine taşınabilir
    if (draggedIsMainActivity && targetIsMainActivity) {
        const draggedIsValid = draggedId.startsWith('A') || draggedId.startsWith('F');
        const targetIsValid = targetId.startsWith('A') || targetId.startsWith('F');
        return draggedIsValid && targetIsValid;
    }
    
    return false; // Ana etkinlikler için diğer durumlar geçersiz
}

/**
 * Alt bileşenlerin taşınıp taşınamayacağını kontrol et
 */
function canDropComponentOn(draggedId, targetId) {
    if (!draggedId || !targetId || draggedId === targetId) {
        return false;
    }
    
    // Sürüklenen alt bileşen, hedef alt bileşen olmalı
    if (!draggedId.includes('.') || !targetId.includes('.')) {
        return false;
    }
    
    // Her iki bileşen de geçerli ID formatında olmalı (A1.1, F2.3 gibi)
    const draggedIsValid = (draggedId.startsWith('A') || draggedId.startsWith('F'));
    const targetIsValid = (targetId.startsWith('A') || targetId.startsWith('F'));
    
    return draggedIsValid && targetIsValid;
}

/**
 * Etkinliği kategoriler arasında taşı
 */
async function moveActivityBetweenCategories(draggedId, targetId) {
    const confirmed = await showModernConfirm(
        'Kategori Değiştirme Onayı',
        `${getComponentDisplayName(draggedId)} etkinliğini ${draggedId.startsWith('A') ? 'Yarıyıl Sonu' : 'Yarıyıl İçi'} kategorisine taşımak istediğinizden emin misiniz?\\n\\nBu işlem etkinliğin kategorisini değiştirecek ve ID'sini yeniden düzenleyecektir.`,
        {
            confirmText: 'Evet, Taşı',
            cancelText: 'İptal',
            headerClass: 'warning-action',
            iconClass: 'warning'
        }
    );
    
    if (!confirmed) return;
    
    console.log(`🔄 Kategori değiştirme: ${draggedId} → ${targetId} kategorisi`);
    
    try {
        const draggedNode = findNodeById(draggedId);
        if (!draggedNode) {
            showModernToast("Taşınacak etkinlik bulunamadı!", "error");
            return;
        }
        
        // Grup haritalamalarını kaydet
        const savedMappings = {};
        saveNodeGroupMappings(draggedNode, savedMappings);
        
        // Ana ağaçtan düğümü çıkar
        const draggedIndex = APP_STATE.assessmentTree.findIndex(n => n.id === draggedId);
        if (draggedIndex === -1) {
            showModernToast("Etkinlik ana ağaçta bulunamadı!", "error");
            return;
        }
        
        APP_STATE.assessmentTree.splice(draggedIndex, 1);
        
        // Etkinliğin hedef kategorisini belirle ve geçici ID ata
        const draggedIsTermActivity = draggedId.startsWith('A');
        const targetIsTermActivity = targetId.startsWith('A');
        
        // Eğer kategori değişiyorsa, etkinliğin prefix'ini değiştir
        if (draggedIsTermActivity !== targetIsTermActivity) {
            const newPrefix = targetIsTermActivity ? 'A' : 'F';
            const tempId = `${newPrefix}_TEMP_${Date.now()}`;
            draggedNode.id = tempId;
            
            // Alt bileşenlerin ID'lerini de geçici olarak değiştir
            if (draggedNode.children && draggedNode.children.length > 0) {
                draggedNode.children.forEach((child, index) => {
                    child.id = `${tempId}.${index + 1}`;
                });
            }
        }
        
        // Hedef kategoriye doğru pozisyonda ekle
        const targetIndex = APP_STATE.assessmentTree.findIndex(n => n.id === targetId);
        if (targetIndex !== -1) {
            // Hedef etkinliğin yerine ekle
            APP_STATE.assessmentTree.splice(targetIndex, 0, draggedNode);
        } else {
            // Hedef bulunamadıysa hedef kategorinin sonuna ekle
            const targetCategoryNodes = APP_STATE.assessmentTree.filter(n => 
                targetIsTermActivity ? n.id.startsWith('A') : n.id.startsWith('F')
            );
            
            if (targetCategoryNodes.length > 0) {
                // Son etkinliğin arkasına ekle
                const lastNodeIndex = APP_STATE.assessmentTree.findIndex(n => n.id === targetCategoryNodes[targetCategoryNodes.length - 1].id);
                APP_STATE.assessmentTree.splice(lastNodeIndex + 1, 0, draggedNode);
            } else {
                // Kategori boşsa sona ekle
                APP_STATE.assessmentTree.push(draggedNode);
            }
        }
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        showModernToast(`${getComponentDisplayName(draggedId)} etkinliği kategori değiştirdi!`, "success");
        
    } catch (error) {
        console.error('❌ Kategori değiştirme hatası:', error);
        showModernToast("Etkinlik taşınırken hata oluştu!", "error");
    }
}

/**
 * Etkinliği aynı kategori içinde taşı
 */
async function moveActivityWithinCategory(draggedId, targetId) {
    console.log(`🔄 Aynı kategori içinde taşıma: ${draggedId} → ${targetId}`);
    
    // Onay al
    const confirmed = await showModernConfirm(
        'Etkinlik Taşıma Onayı',
        `${getComponentDisplayName(draggedId)} etkinliğini ${getComponentDisplayName(targetId)} etkinliğinin yerine taşımak istediğinizden emin misiniz?\\n\\nBu işlem etkinliklerin sırasını değiştirecek ve ID'lerini yeniden düzenleyecektir.`,
        {
            confirmText: 'Evet, Taşı',
            cancelText: 'İptal',
            headerClass: 'info-action',
            iconClass: 'info'
        }
    );
    
    if (!confirmed) return;
    
    try {
        const draggedIndex = APP_STATE.assessmentTree.findIndex(n => n.id === draggedId);
        const targetIndex = APP_STATE.assessmentTree.findIndex(n => n.id === targetId);
        
        if (draggedIndex === -1 || targetIndex === -1) {
            showModernToast("Taşıma işlemi için gerekli etkinlikler bulunamadı!", "error");
            return;
        }
        
        // Grup haritalamalarını kaydet
        const draggedNode = APP_STATE.assessmentTree[draggedIndex];
        const savedMappings = {};
        saveNodeGroupMappings(draggedNode, savedMappings);
        
        // Ana ağaçta sıraları değiştir
        APP_STATE.assessmentTree.splice(draggedIndex, 1);
        APP_STATE.assessmentTree.splice(targetIndex, 0, draggedNode);
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        showModernToast(`${getComponentDisplayName(draggedId)} etkinliği taşındı!`, "success");
        
    } catch (error) {
        console.error('❌ Aynı kategori taşıma hatası:', error);
        showModernToast("Etkinlik taşınırken hata oluştu!", "error");
    }
}

/**
 * Alt bileşeni farklı etkinlikler arasında taşı
 */
async function moveComponentBetweenActivities(draggedId, targetId) {
    console.log(`🔄 Alt bileşen farklı etkinlikler arası taşıma: ${draggedId} → ${targetId}`);
    
    // Parent ID'lerini al
    const draggedParent = draggedId.substring(0, draggedId.lastIndexOf('.'));
    const targetParent = targetId.substring(0, targetId.lastIndexOf('.'));
    
    // Onay al
    const confirmed = await showModernConfirm(
        'Alt Bileşen Taşıma Onayı',
        `${getComponentDisplayName(draggedId)} alt bileşenini ${getComponentDisplayName(targetParent)} etkinliğine taşımak istediğinizden emin misiniz?\\n\\nBu işlem alt bileşeni farklı bir etkinliğe taşıyacak ve ID'sini yeniden düzenleyecektir.`,
        {
            confirmText: 'Evet, Taşı',
            cancelText: 'İptal',
            headerClass: 'info-action',
            iconClass: 'info'
        }
    );
    
    if (!confirmed) return;
    
    try {
        // Kaynak parent node'u bul
        const sourceParentNode = findNodeById(draggedParent);
        if (!sourceParentNode || !sourceParentNode.children) {
            showModernToast("Kaynak etkinlik bulunamadı!", "error");
            return;
        }
        
        // Hedef parent node'u bul
        const targetParentNode = findNodeById(targetParent);
        if (!targetParentNode) {
            showModernToast("Hedef etkinlik bulunamadı!", "error");
            return;
        }
        
        // Taşınacak bileşeni bul
        const draggedIndex = sourceParentNode.children.findIndex(child => child.id === draggedId);
        if (draggedIndex === -1) {
            showModernToast("Taşınacak alt bileşen bulunamadı!", "error");
            return;
        }
        
        const draggedComponent = sourceParentNode.children[draggedIndex];
        
        // Grup haritalamalarını kaydet
        const savedMappings = {};
        saveNodeGroupMappings(draggedComponent, savedMappings);
        
        // Bileşeni kaynak parent'tan çıkar
        sourceParentNode.children.splice(draggedIndex, 1);
        
        // Hedef parent'ta children array'i yoksa oluştur
        if (!targetParentNode.children) {
            targetParentNode.children = [];
        }
        
        // Hedef pozisyonu belirle
        const targetIndex = targetParentNode.children.findIndex(child => child.id === targetId);
        if (targetIndex !== -1) {
            // Hedef bileşenin yerine ekle
            targetParentNode.children.splice(targetIndex, 0, draggedComponent);
        } else {
            // Hedef bileşen bulunamadıysa sona ekle
            targetParentNode.children.push(draggedComponent);
        }
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        showModernToast(`${getComponentDisplayName(draggedId)} alt bileşeni ${getComponentDisplayName(targetParent)} etkinliğine taşındı!`, "success");
        
    } catch (error) {
        console.error('❌ Alt bileşen taşıma hatası:', error);
        showModernToast("Alt bileşen taşınırken hata oluştu!", "error");
    }
}

/**
 * Alt bileşeni aynı parent içinde taşı
 */
async function moveComponentWithinParent(draggedId, targetId) {
    console.log(`🔄 Alt bileşen aynı parent içinde taşıma: ${draggedId} → ${targetId}`);
    
    // Parent ID'lerini al
    const draggedParent = draggedId.substring(0, draggedId.lastIndexOf('.'));
    const targetParent = targetId.substring(0, targetId.lastIndexOf('.'));
    
    // Onay al
    const confirmed = await showModernConfirm(
        'Alt Bileşen Sıralama Onayı',
        `${getComponentDisplayName(draggedId)} alt bileşenini ${getComponentDisplayName(targetId)} alt bileşeninin yerine taşımak istediğinizden emin misiniz?\\n\\nBu işlem alt bileşenlerin sırasını değiştirecek ve ID'lerini yeniden düzenleyecektir.`,
        {
            confirmText: 'Evet, Taşı',
            cancelText: 'İptal',
            headerClass: 'info-action',
            iconClass: 'info'
        }
    );
    
    if (!confirmed) return;
    
    try {
        // Parent node'u bul
        const parentNode = findNodeById(draggedParent);
        if (!parentNode || !parentNode.children) {
            showModernToast("Parent etkinlik bulunamadı!", "error");
            return;
        }
        
        // Taşınacak ve hedef bileşenleri bul
        const draggedIndex = parentNode.children.findIndex(child => child.id === draggedId);
        const targetIndex = parentNode.children.findIndex(child => child.id === targetId);
        
        if (draggedIndex === -1 || targetIndex === -1) {
            showModernToast("Alt bileşenler bulunamadı!", "error");
            return;
        }
        
        // Grup haritalamalarını kaydet
        const savedMappings = {};
        parentNode.children.forEach(child => {
            saveNodeGroupMappings(child, savedMappings);
        });
        
        // Alt bileşenleri yeniden sırala
        const draggedChild = parentNode.children[draggedIndex];
        parentNode.children.splice(draggedIndex, 1);
        parentNode.children.splice(targetIndex, 0, draggedChild);
        
        // Tüm sistemdeki ID'leri yeniden düzenle
        const oldToNewIdMap = await reorganizeAllIds();
        
        // Grup haritalamalarını geri yükle
        restoreGroupMappings(savedMappings, oldToNewIdMap);
        
        // Ağacı yeniden render et
        renderTree();
        
        // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
        
        console.log(`✅ Alt bileşen taşıma tamamlandı: ${draggedId} → yeni pozisyon`);
        showModernToast("Alt bileşen başarıyla taşındı!", "success");
        
    } catch (error) {
        console.error('❌ Alt bileşen taşıma hatası:', error);
        showModernToast("Alt bileşen taşınırken hata oluştu!", "error");
    }
}

/**
 * Etkinlik Adı Düzenleme Fonksiyonları
 */

/**
 * Etkinlik adı düzenleme modalını aç
 */
function openActivityNamingModal() {
    const modal = document.getElementById('activityNamingModal');
    if (modal) {
        modal.classList.add('active');
    }
}

/**
 * Etkinlik adı düzenleme modalını kapat
 */
function closeActivityNamingModal() {
    const modal = document.getElementById('activityNamingModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Etkinlik adlarına Vize/Final etiketlerini ekle
 */
async function applyActivityNaming() {
    const target = document.getElementById('namingTarget').value;
    const position = document.getElementById('namingPosition').value;
    const separator = document.getElementById('namingSeparator').value;
    
    console.log('🏷️ Etkinlik adı etiketleme başlıyor:', { target, position, separator });
    
    try {
        let modifiedCount = 0;
        
        // Hedef türüne göre farklı işlemler
        const shouldProcessActivities = target === 'activities' || target === 'both';
        const shouldProcessComponents = target === 'components' || target === 'both';
        
        // Ana etkinlikleri işle
        if (shouldProcessActivities) {
            APP_STATE.assessmentTree.forEach(node => {
                if (!node.id.includes('.')) { // Ana etkinlik kontrolü
                    const isTermActivity = node.id.startsWith('A');
                    const isFinalActivity = node.id.startsWith('F');
                    
                    if (isTermActivity || isFinalActivity) {
                        const label = isTermActivity ? 'Vize' : 'Final';
                        const currentName = node.name || '';
                        
                        // Etiket zaten var mı kontrol et
                        const hasLabel = currentName.includes(label);
                        
                        if (!hasLabel) {
                            let newName;
                            if (position === 'prefix') {
                                newName = label + separator + currentName;
                            } else {
                                newName = currentName + separator + label;
                            }
                            
                            node.name = newName;
                            modifiedCount++;
                            
                            console.log(`✅ Ana Etkinlik ${node.id}: "${currentName}" → "${newName}"`);
                        }
                    }
                }
            });
        }
        
        // Alt bileşenleri işle
        if (shouldProcessComponents) {
            function processNodeChildren(node) {
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        if (child.id.includes('.')) { // Alt bileşen kontrolü
                            // Ana etkinliğin kategorisini belirle
                            const parentId = child.id.split('.')[0];
                            const isTermComponent = parentId.startsWith('A');
                            const isFinalComponent = parentId.startsWith('F');
                            
                            if (isTermComponent || isFinalComponent) {
                                const label = isTermComponent ? 'Vize' : 'Final';
                                const currentName = child.name || '';
                                
                                // Etiket zaten var mı kontrol et
                                const hasLabel = currentName.includes(label);
                                
                                if (!hasLabel) {
                                    let newName;
                                    if (position === 'prefix') {
                                        newName = label + separator + currentName;
                                    } else {
                                        newName = currentName + separator + label;
                                    }
                                    
                                    child.name = newName;
                                    modifiedCount++;
                                    
                                    console.log(`✅ Alt Bileşen ${child.id}: "${currentName}" → "${newName}"`);
                                }
                            }
                        }
                        
                        // Recursive olarak alt bileşenleri de işle
                        processNodeChildren(child);
                    });
                }
            }
            
            APP_STATE.assessmentTree.forEach(node => {
                processNodeChildren(node);
            });
        }
        
        if (modifiedCount > 0) {
            renderTree();

                    // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
            const targetText = target === 'activities' ? 'etkinlik' : 
                             target === 'components' ? 'alt bileşen' : 
                             'etkinlik ve alt bileşen';
            showModernToast(`${modifiedCount} ${targetText} adına etiket eklendi!`, "success");
            closeActivityNamingModal();
        } else {
            showModernToast("Hiçbir ad değiştirilmedi. Etiketler zaten mevcut olabilir.", "warning");
        }
        

        
    } catch (error) {
        console.error('❌ Etkinlik adı etiketleme hatası:', error);
        showModernToast("Adlar düzenlenirken hata oluştu!", "error");
    }
}

/**
 * Etiket temizleme modalını aç
 */
function openActivityCleanupModal() {
    const modal = document.getElementById('activityCleanupModal');
    if (modal) {
        modal.classList.add('active');
    }
}

/**
 * Etiket temizleme modalını kapat
 */
function closeActivityCleanupModal() {
    const modal = document.getElementById('activityCleanupModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

/**
 * Etkinlik adlarından Vize/Final etiketlerini temizle
 */
async function removeActivitySuffixes() {
    const target = document.getElementById('cleanupTarget').value;
    
    const targetText = target === 'activities' ? 'ana etkinlik' : 
                      target === 'components' ? 'alt bileşen' : 
                      'etkinlik ve alt bileşen';
    
    const confirmed = await showModernConfirm(
        'Etiket Temizleme Onayı',
        `Tüm ${targetText} adlarından "Vize" ve "Final" etiketlerini kaldırmak istediğinizden emin misiniz?\\n\\nBu işlem geri alınamaz.`,
        {
            confirmText: 'Evet, Temizle',
            cancelText: 'İptal',
            headerClass: 'warning-action',
            iconClass: 'warning'
        }
    );
    
    if (!confirmed) return;
    
    console.log('🧹 Etiket temizleme başlıyor...', { target });
    
    try {
        let modifiedCount = 0;
        
        // Hedef türüne göre farklı işlemler
        const shouldProcessActivities = target === 'activities' || target === 'both';
        const shouldProcessComponents = target === 'components' || target === 'both';
        
        // Temizleme desenleri
        const patterns = [
            /\s*-\s*Vize\s*$/gi,
            /\s*\|\s*Vize\s*$/gi,
            /\s*\/\s*Vize\s*$/gi,
            /\s*Vize\s*$/gi,
            /^Vize\s*-\s*/gi,
            /^Vize\s*\|\s*/gi,
            /^Vize\s*\/\s*/gi,
            /^Vize\s*/gi,
            /\s*-\s*Final\s*$/gi,
            /\s*\|\s*Final\s*$/gi,
            /\s*\/\s*Final\s*$/gi,
            /\s*Final\s*$/gi,
            /^Final\s*-\s*/gi,
            /^Final\s*\|\s*/gi,
            /^Final\s*\/\s*/gi,
            /^Final\s*/gi
        ];
        
        // Ana etkinlikleri temizle
        if (shouldProcessActivities) {
            APP_STATE.assessmentTree.forEach(node => {
                if (!node.id.includes('.')) { // Ana etkinlik kontrolü
                    const isTermActivity = node.id.startsWith('A');
                    const isFinalActivity = node.id.startsWith('F');
                    
                    if (isTermActivity || isFinalActivity) {
                        const currentName = node.name || '';
                        let newName = currentName;
                        
                        patterns.forEach(pattern => {
                            newName = newName.replace(pattern, '');
                        });
                        
                        // Boş string kontrolü
                        newName = newName.trim();
                        if (!newName) {
                            newName = isTermActivity ? 'Yarıyıl İçi Etkinlik' : 'Yarıyıl Sonu Etkinlik';
                        }
                        
                        if (newName !== currentName) {
                            node.name = newName;
                            modifiedCount++;
                            
                            console.log(`✅ Ana Etkinlik ${node.id}: "${currentName}" → "${newName}"`);
                        }
                    }
                }
            });
        }
        
        // Alt bileşenleri temizle
        if (shouldProcessComponents) {
            function cleanNodeChildren(node) {
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        if (child.id.includes('.')) { // Alt bileşen kontrolü
                            const parentId = child.id.split('.')[0];
                            const isTermComponent = parentId.startsWith('A');
                            const isFinalComponent = parentId.startsWith('F');
                            
                            if (isTermComponent || isFinalComponent) {
                                const currentName = child.name || '';
                                let newName = currentName;
                                
                                patterns.forEach(pattern => {
                                    newName = newName.replace(pattern, '');
                                });
                                
                                // Boş string kontrolü
                                newName = newName.trim();
                                if (!newName) {
                                    newName = child.type === 'question' ? 'Soru' : 
                                             child.type === 'rubric' ? 'Rubrik' : 'Alt Bileşen';
                                }
                                
                                if (newName !== currentName) {
                                    child.name = newName;
                                    modifiedCount++;
                                    
                                    console.log(`✅ Alt Bileşen ${child.id}: "${currentName}" → "${newName}"`);
                                }
                            }
                        }
                        
                        // Recursive olarak alt bileşenleri de işle
                        cleanNodeChildren(child);
                    });
                }
            }
            
            APP_STATE.assessmentTree.forEach(node => {
                cleanNodeChildren(node);
            });
        }
        
        if (modifiedCount > 0) {
            renderTree();

                    // Değerlendirme sekmesini güncelle - CRITICAL SYNC
        updateAssessmentView();
            showModernToast(`${modifiedCount} ${targetText} adından etiketler temizlendi!`, "success");
            closeActivityCleanupModal();
        } else {
            showModernToast("Hiçbir ad değiştirilmedi. Etiket bulunamadı.", "info");
            closeActivityCleanupModal();
        }
        
    } catch (error) {
        console.error('❌ Etiket temizleme hatası:', error);
        showModernToast("Adlar temizlenirken hata oluştu!", "error");
    }
}

// Event listener'ları ekle
document.addEventListener('DOMContentLoaded', function() {
    // Vize/Final etiketleri ekle butonu
    const btnAddSuffixes = document.getElementById('btnAddActivitySuffixes');
    if (btnAddSuffixes) {
        btnAddSuffixes.addEventListener('click', openActivityNamingModal);
    }
    
    // Vize/Final etiketlerini temizle butonu
    const btnRemoveSuffixes = document.getElementById('btnRemoveActivitySuffixes');
    if (btnRemoveSuffixes) {
        btnRemoveSuffixes.addEventListener('click', openActivityCleanupModal);
    }
});


function updateGroupMappingsWithNewIds(componentId, idMapping) {
    try {
        if (!APP_STATE.courseData?.grupHaritalari || !APP_STATE.courseData.grupHaritalari[componentId]) {
            console.log(`⚠️ Grup haritalama verisi bulunamadı: ${componentId}`);
            return;
        }
        
        console.log(`🗺️ Grup haritalamalarındaki IDler güncelleniyor: ${componentId}`);
        console.log(`📋 ID Mapping:`, idMapping);
        
        const component = APP_STATE.courseData.grupHaritalari[componentId];
        if (!component.haritalar) {
            console.log(`⚠️ Component mappings bulunamadı: ${componentId}`);
            return;
        }
        
        let updateCount = 0;
        
        Object.keys(component.haritalar).forEach(groupName => {
            const groupMapping = component.haritalar[groupName];
            console.log(`🔍 ${groupName} grubu kontrol ediliyor...`, groupMapping);
            
            Object.keys(groupMapping).forEach(position => {
                const currentQuestionId = groupMapping[position];
                
                if (idMapping[currentQuestionId]) {
                    const newQuestionId = idMapping[currentQuestionId];
                    groupMapping[position] = newQuestionId;
                    updateCount++;
                    console.log(`  📝 Grup ${groupName}, Pozisyon ${position}: ${currentQuestionId} -> ${newQuestionId}`);
                }
            });
            
            console.log(`✅ ${groupName} grubu güncellendi:`, groupMapping);
        });
        
        if (updateCount > 0) {
            console.log(`✅ ${updateCount} grup haritalama IDsi güncellendi`);
            
            try {
                updateGroupMappingColors();
                updateAllInlineGroupInputs();
                updateAllMappingDisplays();
                console.log(`🎨 UI güncellemeleri tamamlandı`);
            } catch (uiError) {
                console.error("UI güncelleme hatası:", uiError);
            }
        } else {
            console.log(`ℹ️ ${componentId} için güncelleme gerekmeyen grup haritalama`);
        }
        
    } catch (error) {
        console.error("Grup haritalama ID güncelleme hatası:", error);
        console.error("componentId:", componentId);
        console.error("idMapping:", idMapping);
    }
}

// DEBUG: Test fonksiyonu
function testGroupMappingUpdate() {
    console.log('🧪 Grup haritalama güncellemesi test ediliyor...');
    const testMapping = { 'A1.3': 'A1.2', 'A1.4': 'A1.3' };
    updateGroupMappingsWithNewIds('A1', testMapping);
}

window.testGroupMappingUpdate = testGroupMappingUpdate;
